// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package s3

import (
	"context"

	"github.com/aws/aws-sdk-go-v2/aws/signer/v4"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	mock "github.com/stretchr/testify/mock"
)

// NewMockUploader creates a new instance of MockUploader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUploader(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUploader {
	mock := &MockUploader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUploader is an autogenerated mock type for the Uploader type
type MockUploader struct {
	mock.Mock
}

type MockUploader_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUploader) EXPECT() *MockUploader_Expecter {
	return &MockUploader_Expecter{mock: &_m.Mock}
}

// PutObject provides a mock function for the type MockUploader
func (_mock *MockUploader) PutObject(ctx context.Context, params *s3.PutObjectInput, optFns ...func(*s3.Options)) (*s3.PutObjectOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutObject")
	}

	var r0 *s3.PutObjectOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectInput, ...func(*s3.Options)) (*s3.PutObjectOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectInput, ...func(*s3.Options)) *s3.PutObjectOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutObjectOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutObjectInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUploader_PutObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutObject'
type MockUploader_PutObject_Call struct {
	*mock.Call
}

// PutObject is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutObjectInput
//   - optFns ...func(*s3.Options)
func (_e *MockUploader_Expecter) PutObject(ctx interface{}, params interface{}, optFns ...interface{}) *MockUploader_PutObject_Call {
	return &MockUploader_PutObject_Call{Call: _e.mock.On("PutObject",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockUploader_PutObject_Call) Run(run func(ctx context.Context, params *s3.PutObjectInput, optFns ...func(*s3.Options))) *MockUploader_PutObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutObjectInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutObjectInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockUploader_PutObject_Call) Return(putObjectOutput *s3.PutObjectOutput, err error) *MockUploader_PutObject_Call {
	_c.Call.Return(putObjectOutput, err)
	return _c
}

func (_c *MockUploader_PutObject_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutObjectInput, optFns ...func(*s3.Options)) (*s3.PutObjectOutput, error)) *MockUploader_PutObject_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockDownloader creates a new instance of MockDownloader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockDownloader(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockDownloader {
	mock := &MockDownloader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockDownloader is an autogenerated mock type for the Downloader type
type MockDownloader struct {
	mock.Mock
}

type MockDownloader_Expecter struct {
	mock *mock.Mock
}

func (_m *MockDownloader) EXPECT() *MockDownloader_Expecter {
	return &MockDownloader_Expecter{mock: &_m.Mock}
}

// GetObject provides a mock function for the type MockDownloader
func (_mock *MockDownloader) GetObject(ctx context.Context, params *s3.GetObjectInput, optFns ...func(*s3.Options)) (*s3.GetObjectOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetObject")
	}

	var r0 *s3.GetObjectOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectInput, ...func(*s3.Options)) (*s3.GetObjectOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectInput, ...func(*s3.Options)) *s3.GetObjectOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetObjectOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetObjectInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockDownloader_GetObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetObject'
type MockDownloader_GetObject_Call struct {
	*mock.Call
}

// GetObject is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetObjectInput
//   - optFns ...func(*s3.Options)
func (_e *MockDownloader_Expecter) GetObject(ctx interface{}, params interface{}, optFns ...interface{}) *MockDownloader_GetObject_Call {
	return &MockDownloader_GetObject_Call{Call: _e.mock.On("GetObject",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockDownloader_GetObject_Call) Run(run func(ctx context.Context, params *s3.GetObjectInput, optFns ...func(*s3.Options))) *MockDownloader_GetObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetObjectInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetObjectInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockDownloader_GetObject_Call) Return(getObjectOutput *s3.GetObjectOutput, err error) *MockDownloader_GetObject_Call {
	_c.Call.Return(getObjectOutput, err)
	return _c
}

func (_c *MockDownloader_GetObject_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetObjectInput, optFns ...func(*s3.Options)) (*s3.GetObjectOutput, error)) *MockDownloader_GetObject_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockMetadataGetter creates a new instance of MockMetadataGetter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMetadataGetter(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockMetadataGetter {
	mock := &MockMetadataGetter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockMetadataGetter is an autogenerated mock type for the MetadataGetter type
type MockMetadataGetter struct {
	mock.Mock
}

type MockMetadataGetter_Expecter struct {
	mock *mock.Mock
}

func (_m *MockMetadataGetter) EXPECT() *MockMetadataGetter_Expecter {
	return &MockMetadataGetter_Expecter{mock: &_m.Mock}
}

// HeadObject provides a mock function for the type MockMetadataGetter
func (_mock *MockMetadataGetter) HeadObject(ctx context.Context, params *s3.HeadObjectInput, optFns ...func(*s3.Options)) (*s3.HeadObjectOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for HeadObject")
	}

	var r0 *s3.HeadObjectOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.HeadObjectInput, ...func(*s3.Options)) (*s3.HeadObjectOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.HeadObjectInput, ...func(*s3.Options)) *s3.HeadObjectOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.HeadObjectOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.HeadObjectInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetadataGetter_HeadObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HeadObject'
type MockMetadataGetter_HeadObject_Call struct {
	*mock.Call
}

// HeadObject is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.HeadObjectInput
//   - optFns ...func(*s3.Options)
func (_e *MockMetadataGetter_Expecter) HeadObject(ctx interface{}, params interface{}, optFns ...interface{}) *MockMetadataGetter_HeadObject_Call {
	return &MockMetadataGetter_HeadObject_Call{Call: _e.mock.On("HeadObject",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockMetadataGetter_HeadObject_Call) Run(run func(ctx context.Context, params *s3.HeadObjectInput, optFns ...func(*s3.Options))) *MockMetadataGetter_HeadObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.HeadObjectInput
		if args[1] != nil {
			arg1 = args[1].(*s3.HeadObjectInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockMetadataGetter_HeadObject_Call) Return(headObjectOutput *s3.HeadObjectOutput, err error) *MockMetadataGetter_HeadObject_Call {
	_c.Call.Return(headObjectOutput, err)
	return _c
}

func (_c *MockMetadataGetter_HeadObject_Call) RunAndReturn(run func(ctx context.Context, params *s3.HeadObjectInput, optFns ...func(*s3.Options)) (*s3.HeadObjectOutput, error)) *MockMetadataGetter_HeadObject_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockDeleter creates a new instance of MockDeleter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockDeleter(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockDeleter {
	mock := &MockDeleter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockDeleter is an autogenerated mock type for the Deleter type
type MockDeleter struct {
	mock.Mock
}

type MockDeleter_Expecter struct {
	mock *mock.Mock
}

func (_m *MockDeleter) EXPECT() *MockDeleter_Expecter {
	return &MockDeleter_Expecter{mock: &_m.Mock}
}

// DeleteObject provides a mock function for the type MockDeleter
func (_mock *MockDeleter) DeleteObject(ctx context.Context, params *s3.DeleteObjectInput, optFns ...func(*s3.Options)) (*s3.DeleteObjectOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteObject")
	}

	var r0 *s3.DeleteObjectOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteObjectInput, ...func(*s3.Options)) (*s3.DeleteObjectOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteObjectInput, ...func(*s3.Options)) *s3.DeleteObjectOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteObjectOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteObjectInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockDeleter_DeleteObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteObject'
type MockDeleter_DeleteObject_Call struct {
	*mock.Call
}

// DeleteObject is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteObjectInput
//   - optFns ...func(*s3.Options)
func (_e *MockDeleter_Expecter) DeleteObject(ctx interface{}, params interface{}, optFns ...interface{}) *MockDeleter_DeleteObject_Call {
	return &MockDeleter_DeleteObject_Call{Call: _e.mock.On("DeleteObject",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockDeleter_DeleteObject_Call) Run(run func(ctx context.Context, params *s3.DeleteObjectInput, optFns ...func(*s3.Options))) *MockDeleter_DeleteObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteObjectInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteObjectInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockDeleter_DeleteObject_Call) Return(deleteObjectOutput *s3.DeleteObjectOutput, err error) *MockDeleter_DeleteObject_Call {
	_c.Call.Return(deleteObjectOutput, err)
	return _c
}

func (_c *MockDeleter_DeleteObject_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteObjectInput, optFns ...func(*s3.Options)) (*s3.DeleteObjectOutput, error)) *MockDeleter_DeleteObject_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockBatchDeleter creates a new instance of MockBatchDeleter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockBatchDeleter(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockBatchDeleter {
	mock := &MockBatchDeleter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockBatchDeleter is an autogenerated mock type for the BatchDeleter type
type MockBatchDeleter struct {
	mock.Mock
}

type MockBatchDeleter_Expecter struct {
	mock *mock.Mock
}

func (_m *MockBatchDeleter) EXPECT() *MockBatchDeleter_Expecter {
	return &MockBatchDeleter_Expecter{mock: &_m.Mock}
}

// DeleteObjects provides a mock function for the type MockBatchDeleter
func (_mock *MockBatchDeleter) DeleteObjects(ctx context.Context, params *s3.DeleteObjectsInput, optFns ...func(*s3.Options)) (*s3.DeleteObjectsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteObjects")
	}

	var r0 *s3.DeleteObjectsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteObjectsInput, ...func(*s3.Options)) (*s3.DeleteObjectsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteObjectsInput, ...func(*s3.Options)) *s3.DeleteObjectsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteObjectsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteObjectsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBatchDeleter_DeleteObjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteObjects'
type MockBatchDeleter_DeleteObjects_Call struct {
	*mock.Call
}

// DeleteObjects is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteObjectsInput
//   - optFns ...func(*s3.Options)
func (_e *MockBatchDeleter_Expecter) DeleteObjects(ctx interface{}, params interface{}, optFns ...interface{}) *MockBatchDeleter_DeleteObjects_Call {
	return &MockBatchDeleter_DeleteObjects_Call{Call: _e.mock.On("DeleteObjects",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockBatchDeleter_DeleteObjects_Call) Run(run func(ctx context.Context, params *s3.DeleteObjectsInput, optFns ...func(*s3.Options))) *MockBatchDeleter_DeleteObjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteObjectsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteObjectsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockBatchDeleter_DeleteObjects_Call) Return(deleteObjectsOutput *s3.DeleteObjectsOutput, err error) *MockBatchDeleter_DeleteObjects_Call {
	_c.Call.Return(deleteObjectsOutput, err)
	return _c
}

func (_c *MockBatchDeleter_DeleteObjects_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteObjectsInput, optFns ...func(*s3.Options)) (*s3.DeleteObjectsOutput, error)) *MockBatchDeleter_DeleteObjects_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockCopier creates a new instance of MockCopier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCopier(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockCopier {
	mock := &MockCopier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockCopier is an autogenerated mock type for the Copier type
type MockCopier struct {
	mock.Mock
}

type MockCopier_Expecter struct {
	mock *mock.Mock
}

func (_m *MockCopier) EXPECT() *MockCopier_Expecter {
	return &MockCopier_Expecter{mock: &_m.Mock}
}

// CopyObject provides a mock function for the type MockCopier
func (_mock *MockCopier) CopyObject(ctx context.Context, params *s3.CopyObjectInput, optFns ...func(*s3.Options)) (*s3.CopyObjectOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for CopyObject")
	}

	var r0 *s3.CopyObjectOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.CopyObjectInput, ...func(*s3.Options)) (*s3.CopyObjectOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.CopyObjectInput, ...func(*s3.Options)) *s3.CopyObjectOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.CopyObjectOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.CopyObjectInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCopier_CopyObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyObject'
type MockCopier_CopyObject_Call struct {
	*mock.Call
}

// CopyObject is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.CopyObjectInput
//   - optFns ...func(*s3.Options)
func (_e *MockCopier_Expecter) CopyObject(ctx interface{}, params interface{}, optFns ...interface{}) *MockCopier_CopyObject_Call {
	return &MockCopier_CopyObject_Call{Call: _e.mock.On("CopyObject",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockCopier_CopyObject_Call) Run(run func(ctx context.Context, params *s3.CopyObjectInput, optFns ...func(*s3.Options))) *MockCopier_CopyObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.CopyObjectInput
		if args[1] != nil {
			arg1 = args[1].(*s3.CopyObjectInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockCopier_CopyObject_Call) Return(copyObjectOutput *s3.CopyObjectOutput, err error) *MockCopier_CopyObject_Call {
	_c.Call.Return(copyObjectOutput, err)
	return _c
}

func (_c *MockCopier_CopyObject_Call) RunAndReturn(run func(ctx context.Context, params *s3.CopyObjectInput, optFns ...func(*s3.Options)) (*s3.CopyObjectOutput, error)) *MockCopier_CopyObject_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockLister creates a new instance of MockLister. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLister(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockLister {
	mock := &MockLister{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockLister is an autogenerated mock type for the Lister type
type MockLister struct {
	mock.Mock
}

type MockLister_Expecter struct {
	mock *mock.Mock
}

func (_m *MockLister) EXPECT() *MockLister_Expecter {
	return &MockLister_Expecter{mock: &_m.Mock}
}

// ListObjectsV2 provides a mock function for the type MockLister
func (_mock *MockLister) ListObjectsV2(ctx context.Context, params *s3.ListObjectsV2Input, optFns ...func(*s3.Options)) (*s3.ListObjectsV2Output, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListObjectsV2")
	}

	var r0 *s3.ListObjectsV2Output
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListObjectsV2Input, ...func(*s3.Options)) (*s3.ListObjectsV2Output, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListObjectsV2Input, ...func(*s3.Options)) *s3.ListObjectsV2Output); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.ListObjectsV2Output)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.ListObjectsV2Input, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLister_ListObjectsV2_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListObjectsV2'
type MockLister_ListObjectsV2_Call struct {
	*mock.Call
}

// ListObjectsV2 is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.ListObjectsV2Input
//   - optFns ...func(*s3.Options)
func (_e *MockLister_Expecter) ListObjectsV2(ctx interface{}, params interface{}, optFns ...interface{}) *MockLister_ListObjectsV2_Call {
	return &MockLister_ListObjectsV2_Call{Call: _e.mock.On("ListObjectsV2",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockLister_ListObjectsV2_Call) Run(run func(ctx context.Context, params *s3.ListObjectsV2Input, optFns ...func(*s3.Options))) *MockLister_ListObjectsV2_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.ListObjectsV2Input
		if args[1] != nil {
			arg1 = args[1].(*s3.ListObjectsV2Input)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockLister_ListObjectsV2_Call) Return(listObjectsV2Output *s3.ListObjectsV2Output, err error) *MockLister_ListObjectsV2_Call {
	_c.Call.Return(listObjectsV2Output, err)
	return _c
}

func (_c *MockLister_ListObjectsV2_Call) RunAndReturn(run func(ctx context.Context, params *s3.ListObjectsV2Input, optFns ...func(*s3.Options)) (*s3.ListObjectsV2Output, error)) *MockLister_ListObjectsV2_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockBucketLister creates a new instance of MockBucketLister. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockBucketLister(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockBucketLister {
	mock := &MockBucketLister{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockBucketLister is an autogenerated mock type for the BucketLister type
type MockBucketLister struct {
	mock.Mock
}

type MockBucketLister_Expecter struct {
	mock *mock.Mock
}

func (_m *MockBucketLister) EXPECT() *MockBucketLister_Expecter {
	return &MockBucketLister_Expecter{mock: &_m.Mock}
}

// ListBuckets provides a mock function for the type MockBucketLister
func (_mock *MockBucketLister) ListBuckets(ctx context.Context, params *s3.ListBucketsInput, optFns ...func(*s3.Options)) (*s3.ListBucketsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListBuckets")
	}

	var r0 *s3.ListBucketsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListBucketsInput, ...func(*s3.Options)) (*s3.ListBucketsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListBucketsInput, ...func(*s3.Options)) *s3.ListBucketsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.ListBucketsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.ListBucketsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBucketLister_ListBuckets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBuckets'
type MockBucketLister_ListBuckets_Call struct {
	*mock.Call
}

// ListBuckets is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.ListBucketsInput
//   - optFns ...func(*s3.Options)
func (_e *MockBucketLister_Expecter) ListBuckets(ctx interface{}, params interface{}, optFns ...interface{}) *MockBucketLister_ListBuckets_Call {
	return &MockBucketLister_ListBuckets_Call{Call: _e.mock.On("ListBuckets",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockBucketLister_ListBuckets_Call) Run(run func(ctx context.Context, params *s3.ListBucketsInput, optFns ...func(*s3.Options))) *MockBucketLister_ListBuckets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.ListBucketsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.ListBucketsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockBucketLister_ListBuckets_Call) Return(listBucketsOutput *s3.ListBucketsOutput, err error) *MockBucketLister_ListBuckets_Call {
	_c.Call.Return(listBucketsOutput, err)
	return _c
}

func (_c *MockBucketLister_ListBuckets_Call) RunAndReturn(run func(ctx context.Context, params *s3.ListBucketsInput, optFns ...func(*s3.Options)) (*s3.ListBucketsOutput, error)) *MockBucketLister_ListBuckets_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockMultipartUploader creates a new instance of MockMultipartUploader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMultipartUploader(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockMultipartUploader {
	mock := &MockMultipartUploader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockMultipartUploader is an autogenerated mock type for the MultipartUploader type
type MockMultipartUploader struct {
	mock.Mock
}

type MockMultipartUploader_Expecter struct {
	mock *mock.Mock
}

func (_m *MockMultipartUploader) EXPECT() *MockMultipartUploader_Expecter {
	return &MockMultipartUploader_Expecter{mock: &_m.Mock}
}

// AbortMultipartUpload provides a mock function for the type MockMultipartUploader
func (_mock *MockMultipartUploader) AbortMultipartUpload(ctx context.Context, params *s3.AbortMultipartUploadInput, optFns ...func(*s3.Options)) (*s3.AbortMultipartUploadOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for AbortMultipartUpload")
	}

	var r0 *s3.AbortMultipartUploadOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.AbortMultipartUploadInput, ...func(*s3.Options)) (*s3.AbortMultipartUploadOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.AbortMultipartUploadInput, ...func(*s3.Options)) *s3.AbortMultipartUploadOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.AbortMultipartUploadOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.AbortMultipartUploadInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMultipartUploader_AbortMultipartUpload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AbortMultipartUpload'
type MockMultipartUploader_AbortMultipartUpload_Call struct {
	*mock.Call
}

// AbortMultipartUpload is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.AbortMultipartUploadInput
//   - optFns ...func(*s3.Options)
func (_e *MockMultipartUploader_Expecter) AbortMultipartUpload(ctx interface{}, params interface{}, optFns ...interface{}) *MockMultipartUploader_AbortMultipartUpload_Call {
	return &MockMultipartUploader_AbortMultipartUpload_Call{Call: _e.mock.On("AbortMultipartUpload",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockMultipartUploader_AbortMultipartUpload_Call) Run(run func(ctx context.Context, params *s3.AbortMultipartUploadInput, optFns ...func(*s3.Options))) *MockMultipartUploader_AbortMultipartUpload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.AbortMultipartUploadInput
		if args[1] != nil {
			arg1 = args[1].(*s3.AbortMultipartUploadInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockMultipartUploader_AbortMultipartUpload_Call) Return(abortMultipartUploadOutput *s3.AbortMultipartUploadOutput, err error) *MockMultipartUploader_AbortMultipartUpload_Call {
	_c.Call.Return(abortMultipartUploadOutput, err)
	return _c
}

func (_c *MockMultipartUploader_AbortMultipartUpload_Call) RunAndReturn(run func(ctx context.Context, params *s3.AbortMultipartUploadInput, optFns ...func(*s3.Options)) (*s3.AbortMultipartUploadOutput, error)) *MockMultipartUploader_AbortMultipartUpload_Call {
	_c.Call.Return(run)
	return _c
}

// CompleteMultipartUpload provides a mock function for the type MockMultipartUploader
func (_mock *MockMultipartUploader) CompleteMultipartUpload(ctx context.Context, params *s3.CompleteMultipartUploadInput, optFns ...func(*s3.Options)) (*s3.CompleteMultipartUploadOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for CompleteMultipartUpload")
	}

	var r0 *s3.CompleteMultipartUploadOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.CompleteMultipartUploadInput, ...func(*s3.Options)) (*s3.CompleteMultipartUploadOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.CompleteMultipartUploadInput, ...func(*s3.Options)) *s3.CompleteMultipartUploadOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.CompleteMultipartUploadOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.CompleteMultipartUploadInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMultipartUploader_CompleteMultipartUpload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompleteMultipartUpload'
type MockMultipartUploader_CompleteMultipartUpload_Call struct {
	*mock.Call
}

// CompleteMultipartUpload is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.CompleteMultipartUploadInput
//   - optFns ...func(*s3.Options)
func (_e *MockMultipartUploader_Expecter) CompleteMultipartUpload(ctx interface{}, params interface{}, optFns ...interface{}) *MockMultipartUploader_CompleteMultipartUpload_Call {
	return &MockMultipartUploader_CompleteMultipartUpload_Call{Call: _e.mock.On("CompleteMultipartUpload",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockMultipartUploader_CompleteMultipartUpload_Call) Run(run func(ctx context.Context, params *s3.CompleteMultipartUploadInput, optFns ...func(*s3.Options))) *MockMultipartUploader_CompleteMultipartUpload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.CompleteMultipartUploadInput
		if args[1] != nil {
			arg1 = args[1].(*s3.CompleteMultipartUploadInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockMultipartUploader_CompleteMultipartUpload_Call) Return(completeMultipartUploadOutput *s3.CompleteMultipartUploadOutput, err error) *MockMultipartUploader_CompleteMultipartUpload_Call {
	_c.Call.Return(completeMultipartUploadOutput, err)
	return _c
}

func (_c *MockMultipartUploader_CompleteMultipartUpload_Call) RunAndReturn(run func(ctx context.Context, params *s3.CompleteMultipartUploadInput, optFns ...func(*s3.Options)) (*s3.CompleteMultipartUploadOutput, error)) *MockMultipartUploader_CompleteMultipartUpload_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMultipartUpload provides a mock function for the type MockMultipartUploader
func (_mock *MockMultipartUploader) CreateMultipartUpload(ctx context.Context, params *s3.CreateMultipartUploadInput, optFns ...func(*s3.Options)) (*s3.CreateMultipartUploadOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for CreateMultipartUpload")
	}

	var r0 *s3.CreateMultipartUploadOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.CreateMultipartUploadInput, ...func(*s3.Options)) (*s3.CreateMultipartUploadOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.CreateMultipartUploadInput, ...func(*s3.Options)) *s3.CreateMultipartUploadOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.CreateMultipartUploadOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.CreateMultipartUploadInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMultipartUploader_CreateMultipartUpload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMultipartUpload'
type MockMultipartUploader_CreateMultipartUpload_Call struct {
	*mock.Call
}

// CreateMultipartUpload is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.CreateMultipartUploadInput
//   - optFns ...func(*s3.Options)
func (_e *MockMultipartUploader_Expecter) CreateMultipartUpload(ctx interface{}, params interface{}, optFns ...interface{}) *MockMultipartUploader_CreateMultipartUpload_Call {
	return &MockMultipartUploader_CreateMultipartUpload_Call{Call: _e.mock.On("CreateMultipartUpload",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockMultipartUploader_CreateMultipartUpload_Call) Run(run func(ctx context.Context, params *s3.CreateMultipartUploadInput, optFns ...func(*s3.Options))) *MockMultipartUploader_CreateMultipartUpload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.CreateMultipartUploadInput
		if args[1] != nil {
			arg1 = args[1].(*s3.CreateMultipartUploadInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockMultipartUploader_CreateMultipartUpload_Call) Return(createMultipartUploadOutput *s3.CreateMultipartUploadOutput, err error) *MockMultipartUploader_CreateMultipartUpload_Call {
	_c.Call.Return(createMultipartUploadOutput, err)
	return _c
}

func (_c *MockMultipartUploader_CreateMultipartUpload_Call) RunAndReturn(run func(ctx context.Context, params *s3.CreateMultipartUploadInput, optFns ...func(*s3.Options)) (*s3.CreateMultipartUploadOutput, error)) *MockMultipartUploader_CreateMultipartUpload_Call {
	_c.Call.Return(run)
	return _c
}

// UploadPart provides a mock function for the type MockMultipartUploader
func (_mock *MockMultipartUploader) UploadPart(ctx context.Context, params *s3.UploadPartInput, optFns ...func(*s3.Options)) (*s3.UploadPartOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for UploadPart")
	}

	var r0 *s3.UploadPartOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.UploadPartInput, ...func(*s3.Options)) (*s3.UploadPartOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.UploadPartInput, ...func(*s3.Options)) *s3.UploadPartOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.UploadPartOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.UploadPartInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMultipartUploader_UploadPart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UploadPart'
type MockMultipartUploader_UploadPart_Call struct {
	*mock.Call
}

// UploadPart is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.UploadPartInput
//   - optFns ...func(*s3.Options)
func (_e *MockMultipartUploader_Expecter) UploadPart(ctx interface{}, params interface{}, optFns ...interface{}) *MockMultipartUploader_UploadPart_Call {
	return &MockMultipartUploader_UploadPart_Call{Call: _e.mock.On("UploadPart",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockMultipartUploader_UploadPart_Call) Run(run func(ctx context.Context, params *s3.UploadPartInput, optFns ...func(*s3.Options))) *MockMultipartUploader_UploadPart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.UploadPartInput
		if args[1] != nil {
			arg1 = args[1].(*s3.UploadPartInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockMultipartUploader_UploadPart_Call) Return(uploadPartOutput *s3.UploadPartOutput, err error) *MockMultipartUploader_UploadPart_Call {
	_c.Call.Return(uploadPartOutput, err)
	return _c
}

func (_c *MockMultipartUploader_UploadPart_Call) RunAndReturn(run func(ctx context.Context, params *s3.UploadPartInput, optFns ...func(*s3.Options)) (*s3.UploadPartOutput, error)) *MockMultipartUploader_UploadPart_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockMultipartLister creates a new instance of MockMultipartLister. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMultipartLister(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockMultipartLister {
	mock := &MockMultipartLister{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockMultipartLister is an autogenerated mock type for the MultipartLister type
type MockMultipartLister struct {
	mock.Mock
}

type MockMultipartLister_Expecter struct {
	mock *mock.Mock
}

func (_m *MockMultipartLister) EXPECT() *MockMultipartLister_Expecter {
	return &MockMultipartLister_Expecter{mock: &_m.Mock}
}

// ListMultipartUploads provides a mock function for the type MockMultipartLister
func (_mock *MockMultipartLister) ListMultipartUploads(ctx context.Context, params *s3.ListMultipartUploadsInput, optFns ...func(*s3.Options)) (*s3.ListMultipartUploadsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListMultipartUploads")
	}

	var r0 *s3.ListMultipartUploadsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListMultipartUploadsInput, ...func(*s3.Options)) (*s3.ListMultipartUploadsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListMultipartUploadsInput, ...func(*s3.Options)) *s3.ListMultipartUploadsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.ListMultipartUploadsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.ListMultipartUploadsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMultipartLister_ListMultipartUploads_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMultipartUploads'
type MockMultipartLister_ListMultipartUploads_Call struct {
	*mock.Call
}

// ListMultipartUploads is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.ListMultipartUploadsInput
//   - optFns ...func(*s3.Options)
func (_e *MockMultipartLister_Expecter) ListMultipartUploads(ctx interface{}, params interface{}, optFns ...interface{}) *MockMultipartLister_ListMultipartUploads_Call {
	return &MockMultipartLister_ListMultipartUploads_Call{Call: _e.mock.On("ListMultipartUploads",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockMultipartLister_ListMultipartUploads_Call) Run(run func(ctx context.Context, params *s3.ListMultipartUploadsInput, optFns ...func(*s3.Options))) *MockMultipartLister_ListMultipartUploads_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.ListMultipartUploadsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.ListMultipartUploadsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockMultipartLister_ListMultipartUploads_Call) Return(listMultipartUploadsOutput *s3.ListMultipartUploadsOutput, err error) *MockMultipartLister_ListMultipartUploads_Call {
	_c.Call.Return(listMultipartUploadsOutput, err)
	return _c
}

func (_c *MockMultipartLister_ListMultipartUploads_Call) RunAndReturn(run func(ctx context.Context, params *s3.ListMultipartUploadsInput, optFns ...func(*s3.Options)) (*s3.ListMultipartUploadsOutput, error)) *MockMultipartLister_ListMultipartUploads_Call {
	_c.Call.Return(run)
	return _c
}

// ListParts provides a mock function for the type MockMultipartLister
func (_mock *MockMultipartLister) ListParts(ctx context.Context, params *s3.ListPartsInput, optFns ...func(*s3.Options)) (*s3.ListPartsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListParts")
	}

	var r0 *s3.ListPartsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListPartsInput, ...func(*s3.Options)) (*s3.ListPartsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListPartsInput, ...func(*s3.Options)) *s3.ListPartsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.ListPartsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.ListPartsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMultipartLister_ListParts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListParts'
type MockMultipartLister_ListParts_Call struct {
	*mock.Call
}

// ListParts is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.ListPartsInput
//   - optFns ...func(*s3.Options)
func (_e *MockMultipartLister_Expecter) ListParts(ctx interface{}, params interface{}, optFns ...interface{}) *MockMultipartLister_ListParts_Call {
	return &MockMultipartLister_ListParts_Call{Call: _e.mock.On("ListParts",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockMultipartLister_ListParts_Call) Run(run func(ctx context.Context, params *s3.ListPartsInput, optFns ...func(*s3.Options))) *MockMultipartLister_ListParts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.ListPartsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.ListPartsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockMultipartLister_ListParts_Call) Return(listPartsOutput *s3.ListPartsOutput, err error) *MockMultipartLister_ListParts_Call {
	_c.Call.Return(listPartsOutput, err)
	return _c
}

func (_c *MockMultipartLister_ListParts_Call) RunAndReturn(run func(ctx context.Context, params *s3.ListPartsInput, optFns ...func(*s3.Options)) (*s3.ListPartsOutput, error)) *MockMultipartLister_ListParts_Call {
	_c.Call.Return(run)
	return _c
}

// UploadPartCopy provides a mock function for the type MockMultipartLister
func (_mock *MockMultipartLister) UploadPartCopy(ctx context.Context, params *s3.UploadPartCopyInput, optFns ...func(*s3.Options)) (*s3.UploadPartCopyOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for UploadPartCopy")
	}

	var r0 *s3.UploadPartCopyOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.UploadPartCopyInput, ...func(*s3.Options)) (*s3.UploadPartCopyOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.UploadPartCopyInput, ...func(*s3.Options)) *s3.UploadPartCopyOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.UploadPartCopyOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.UploadPartCopyInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMultipartLister_UploadPartCopy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UploadPartCopy'
type MockMultipartLister_UploadPartCopy_Call struct {
	*mock.Call
}

// UploadPartCopy is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.UploadPartCopyInput
//   - optFns ...func(*s3.Options)
func (_e *MockMultipartLister_Expecter) UploadPartCopy(ctx interface{}, params interface{}, optFns ...interface{}) *MockMultipartLister_UploadPartCopy_Call {
	return &MockMultipartLister_UploadPartCopy_Call{Call: _e.mock.On("UploadPartCopy",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockMultipartLister_UploadPartCopy_Call) Run(run func(ctx context.Context, params *s3.UploadPartCopyInput, optFns ...func(*s3.Options))) *MockMultipartLister_UploadPartCopy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.UploadPartCopyInput
		if args[1] != nil {
			arg1 = args[1].(*s3.UploadPartCopyInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockMultipartLister_UploadPartCopy_Call) Return(uploadPartCopyOutput *s3.UploadPartCopyOutput, err error) *MockMultipartLister_UploadPartCopy_Call {
	_c.Call.Return(uploadPartCopyOutput, err)
	return _c
}

func (_c *MockMultipartLister_UploadPartCopy_Call) RunAndReturn(run func(ctx context.Context, params *s3.UploadPartCopyInput, optFns ...func(*s3.Options)) (*s3.UploadPartCopyOutput, error)) *MockMultipartLister_UploadPartCopy_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockAccessController creates a new instance of MockAccessController. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAccessController(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAccessController {
	mock := &MockAccessController{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockAccessController is an autogenerated mock type for the AccessController type
type MockAccessController struct {
	mock.Mock
}

type MockAccessController_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAccessController) EXPECT() *MockAccessController_Expecter {
	return &MockAccessController_Expecter{mock: &_m.Mock}
}

// GetBucketAcl provides a mock function for the type MockAccessController
func (_mock *MockAccessController) GetBucketAcl(ctx context.Context, params *s3.GetBucketAclInput, optFns ...func(*s3.Options)) (*s3.GetBucketAclOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketAcl")
	}

	var r0 *s3.GetBucketAclOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketAclInput, ...func(*s3.Options)) (*s3.GetBucketAclOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketAclInput, ...func(*s3.Options)) *s3.GetBucketAclOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketAclOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketAclInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccessController_GetBucketAcl_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketAcl'
type MockAccessController_GetBucketAcl_Call struct {
	*mock.Call
}

// GetBucketAcl is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketAclInput
//   - optFns ...func(*s3.Options)
func (_e *MockAccessController_Expecter) GetBucketAcl(ctx interface{}, params interface{}, optFns ...interface{}) *MockAccessController_GetBucketAcl_Call {
	return &MockAccessController_GetBucketAcl_Call{Call: _e.mock.On("GetBucketAcl",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockAccessController_GetBucketAcl_Call) Run(run func(ctx context.Context, params *s3.GetBucketAclInput, optFns ...func(*s3.Options))) *MockAccessController_GetBucketAcl_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketAclInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketAclInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockAccessController_GetBucketAcl_Call) Return(getBucketAclOutput *s3.GetBucketAclOutput, err error) *MockAccessController_GetBucketAcl_Call {
	_c.Call.Return(getBucketAclOutput, err)
	return _c
}

func (_c *MockAccessController_GetBucketAcl_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketAclInput, optFns ...func(*s3.Options)) (*s3.GetBucketAclOutput, error)) *MockAccessController_GetBucketAcl_Call {
	_c.Call.Return(run)
	return _c
}

// GetObjectAcl provides a mock function for the type MockAccessController
func (_mock *MockAccessController) GetObjectAcl(ctx context.Context, params *s3.GetObjectAclInput, optFns ...func(*s3.Options)) (*s3.GetObjectAclOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetObjectAcl")
	}

	var r0 *s3.GetObjectAclOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectAclInput, ...func(*s3.Options)) (*s3.GetObjectAclOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectAclInput, ...func(*s3.Options)) *s3.GetObjectAclOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetObjectAclOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetObjectAclInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccessController_GetObjectAcl_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetObjectAcl'
type MockAccessController_GetObjectAcl_Call struct {
	*mock.Call
}

// GetObjectAcl is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetObjectAclInput
//   - optFns ...func(*s3.Options)
func (_e *MockAccessController_Expecter) GetObjectAcl(ctx interface{}, params interface{}, optFns ...interface{}) *MockAccessController_GetObjectAcl_Call {
	return &MockAccessController_GetObjectAcl_Call{Call: _e.mock.On("GetObjectAcl",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockAccessController_GetObjectAcl_Call) Run(run func(ctx context.Context, params *s3.GetObjectAclInput, optFns ...func(*s3.Options))) *MockAccessController_GetObjectAcl_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetObjectAclInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetObjectAclInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockAccessController_GetObjectAcl_Call) Return(getObjectAclOutput *s3.GetObjectAclOutput, err error) *MockAccessController_GetObjectAcl_Call {
	_c.Call.Return(getObjectAclOutput, err)
	return _c
}

func (_c *MockAccessController_GetObjectAcl_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetObjectAclInput, optFns ...func(*s3.Options)) (*s3.GetObjectAclOutput, error)) *MockAccessController_GetObjectAcl_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketAcl provides a mock function for the type MockAccessController
func (_mock *MockAccessController) PutBucketAcl(ctx context.Context, params *s3.PutBucketAclInput, optFns ...func(*s3.Options)) (*s3.PutBucketAclOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketAcl")
	}

	var r0 *s3.PutBucketAclOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketAclInput, ...func(*s3.Options)) (*s3.PutBucketAclOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketAclInput, ...func(*s3.Options)) *s3.PutBucketAclOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketAclOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketAclInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccessController_PutBucketAcl_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketAcl'
type MockAccessController_PutBucketAcl_Call struct {
	*mock.Call
}

// PutBucketAcl is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketAclInput
//   - optFns ...func(*s3.Options)
func (_e *MockAccessController_Expecter) PutBucketAcl(ctx interface{}, params interface{}, optFns ...interface{}) *MockAccessController_PutBucketAcl_Call {
	return &MockAccessController_PutBucketAcl_Call{Call: _e.mock.On("PutBucketAcl",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockAccessController_PutBucketAcl_Call) Run(run func(ctx context.Context, params *s3.PutBucketAclInput, optFns ...func(*s3.Options))) *MockAccessController_PutBucketAcl_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketAclInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketAclInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockAccessController_PutBucketAcl_Call) Return(putBucketAclOutput *s3.PutBucketAclOutput, err error) *MockAccessController_PutBucketAcl_Call {
	_c.Call.Return(putBucketAclOutput, err)
	return _c
}

func (_c *MockAccessController_PutBucketAcl_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketAclInput, optFns ...func(*s3.Options)) (*s3.PutBucketAclOutput, error)) *MockAccessController_PutBucketAcl_Call {
	_c.Call.Return(run)
	return _c
}

// PutObjectAcl provides a mock function for the type MockAccessController
func (_mock *MockAccessController) PutObjectAcl(ctx context.Context, params *s3.PutObjectAclInput, optFns ...func(*s3.Options)) (*s3.PutObjectAclOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutObjectAcl")
	}

	var r0 *s3.PutObjectAclOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectAclInput, ...func(*s3.Options)) (*s3.PutObjectAclOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectAclInput, ...func(*s3.Options)) *s3.PutObjectAclOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutObjectAclOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutObjectAclInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccessController_PutObjectAcl_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutObjectAcl'
type MockAccessController_PutObjectAcl_Call struct {
	*mock.Call
}

// PutObjectAcl is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutObjectAclInput
//   - optFns ...func(*s3.Options)
func (_e *MockAccessController_Expecter) PutObjectAcl(ctx interface{}, params interface{}, optFns ...interface{}) *MockAccessController_PutObjectAcl_Call {
	return &MockAccessController_PutObjectAcl_Call{Call: _e.mock.On("PutObjectAcl",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockAccessController_PutObjectAcl_Call) Run(run func(ctx context.Context, params *s3.PutObjectAclInput, optFns ...func(*s3.Options))) *MockAccessController_PutObjectAcl_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutObjectAclInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutObjectAclInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockAccessController_PutObjectAcl_Call) Return(putObjectAclOutput *s3.PutObjectAclOutput, err error) *MockAccessController_PutObjectAcl_Call {
	_c.Call.Return(putObjectAclOutput, err)
	return _c
}

func (_c *MockAccessController_PutObjectAcl_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutObjectAclInput, optFns ...func(*s3.Options)) (*s3.PutObjectAclOutput, error)) *MockAccessController_PutObjectAcl_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockTagger creates a new instance of MockTagger. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTagger(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTagger {
	mock := &MockTagger{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockTagger is an autogenerated mock type for the Tagger type
type MockTagger struct {
	mock.Mock
}

type MockTagger_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTagger) EXPECT() *MockTagger_Expecter {
	return &MockTagger_Expecter{mock: &_m.Mock}
}

// DeleteBucketTagging provides a mock function for the type MockTagger
func (_mock *MockTagger) DeleteBucketTagging(ctx context.Context, params *s3.DeleteBucketTaggingInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketTaggingOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketTagging")
	}

	var r0 *s3.DeleteBucketTaggingOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketTaggingInput, ...func(*s3.Options)) (*s3.DeleteBucketTaggingOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketTaggingInput, ...func(*s3.Options)) *s3.DeleteBucketTaggingOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketTaggingOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketTaggingInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTagger_DeleteBucketTagging_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketTagging'
type MockTagger_DeleteBucketTagging_Call struct {
	*mock.Call
}

// DeleteBucketTagging is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketTaggingInput
//   - optFns ...func(*s3.Options)
func (_e *MockTagger_Expecter) DeleteBucketTagging(ctx interface{}, params interface{}, optFns ...interface{}) *MockTagger_DeleteBucketTagging_Call {
	return &MockTagger_DeleteBucketTagging_Call{Call: _e.mock.On("DeleteBucketTagging",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockTagger_DeleteBucketTagging_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketTaggingInput, optFns ...func(*s3.Options))) *MockTagger_DeleteBucketTagging_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketTaggingInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketTaggingInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockTagger_DeleteBucketTagging_Call) Return(deleteBucketTaggingOutput *s3.DeleteBucketTaggingOutput, err error) *MockTagger_DeleteBucketTagging_Call {
	_c.Call.Return(deleteBucketTaggingOutput, err)
	return _c
}

func (_c *MockTagger_DeleteBucketTagging_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketTaggingInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketTaggingOutput, error)) *MockTagger_DeleteBucketTagging_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteObjectTagging provides a mock function for the type MockTagger
func (_mock *MockTagger) DeleteObjectTagging(ctx context.Context, params *s3.DeleteObjectTaggingInput, optFns ...func(*s3.Options)) (*s3.DeleteObjectTaggingOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteObjectTagging")
	}

	var r0 *s3.DeleteObjectTaggingOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteObjectTaggingInput, ...func(*s3.Options)) (*s3.DeleteObjectTaggingOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteObjectTaggingInput, ...func(*s3.Options)) *s3.DeleteObjectTaggingOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteObjectTaggingOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteObjectTaggingInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTagger_DeleteObjectTagging_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteObjectTagging'
type MockTagger_DeleteObjectTagging_Call struct {
	*mock.Call
}

// DeleteObjectTagging is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteObjectTaggingInput
//   - optFns ...func(*s3.Options)
func (_e *MockTagger_Expecter) DeleteObjectTagging(ctx interface{}, params interface{}, optFns ...interface{}) *MockTagger_DeleteObjectTagging_Call {
	return &MockTagger_DeleteObjectTagging_Call{Call: _e.mock.On("DeleteObjectTagging",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockTagger_DeleteObjectTagging_Call) Run(run func(ctx context.Context, params *s3.DeleteObjectTaggingInput, optFns ...func(*s3.Options))) *MockTagger_DeleteObjectTagging_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteObjectTaggingInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteObjectTaggingInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockTagger_DeleteObjectTagging_Call) Return(deleteObjectTaggingOutput *s3.DeleteObjectTaggingOutput, err error) *MockTagger_DeleteObjectTagging_Call {
	_c.Call.Return(deleteObjectTaggingOutput, err)
	return _c
}

func (_c *MockTagger_DeleteObjectTagging_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteObjectTaggingInput, optFns ...func(*s3.Options)) (*s3.DeleteObjectTaggingOutput, error)) *MockTagger_DeleteObjectTagging_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketTagging provides a mock function for the type MockTagger
func (_mock *MockTagger) GetBucketTagging(ctx context.Context, params *s3.GetBucketTaggingInput, optFns ...func(*s3.Options)) (*s3.GetBucketTaggingOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketTagging")
	}

	var r0 *s3.GetBucketTaggingOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketTaggingInput, ...func(*s3.Options)) (*s3.GetBucketTaggingOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketTaggingInput, ...func(*s3.Options)) *s3.GetBucketTaggingOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketTaggingOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketTaggingInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTagger_GetBucketTagging_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketTagging'
type MockTagger_GetBucketTagging_Call struct {
	*mock.Call
}

// GetBucketTagging is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketTaggingInput
//   - optFns ...func(*s3.Options)
func (_e *MockTagger_Expecter) GetBucketTagging(ctx interface{}, params interface{}, optFns ...interface{}) *MockTagger_GetBucketTagging_Call {
	return &MockTagger_GetBucketTagging_Call{Call: _e.mock.On("GetBucketTagging",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockTagger_GetBucketTagging_Call) Run(run func(ctx context.Context, params *s3.GetBucketTaggingInput, optFns ...func(*s3.Options))) *MockTagger_GetBucketTagging_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketTaggingInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketTaggingInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockTagger_GetBucketTagging_Call) Return(getBucketTaggingOutput *s3.GetBucketTaggingOutput, err error) *MockTagger_GetBucketTagging_Call {
	_c.Call.Return(getBucketTaggingOutput, err)
	return _c
}

func (_c *MockTagger_GetBucketTagging_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketTaggingInput, optFns ...func(*s3.Options)) (*s3.GetBucketTaggingOutput, error)) *MockTagger_GetBucketTagging_Call {
	_c.Call.Return(run)
	return _c
}

// GetObjectTagging provides a mock function for the type MockTagger
func (_mock *MockTagger) GetObjectTagging(ctx context.Context, params *s3.GetObjectTaggingInput, optFns ...func(*s3.Options)) (*s3.GetObjectTaggingOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetObjectTagging")
	}

	var r0 *s3.GetObjectTaggingOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectTaggingInput, ...func(*s3.Options)) (*s3.GetObjectTaggingOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectTaggingInput, ...func(*s3.Options)) *s3.GetObjectTaggingOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetObjectTaggingOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetObjectTaggingInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTagger_GetObjectTagging_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetObjectTagging'
type MockTagger_GetObjectTagging_Call struct {
	*mock.Call
}

// GetObjectTagging is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetObjectTaggingInput
//   - optFns ...func(*s3.Options)
func (_e *MockTagger_Expecter) GetObjectTagging(ctx interface{}, params interface{}, optFns ...interface{}) *MockTagger_GetObjectTagging_Call {
	return &MockTagger_GetObjectTagging_Call{Call: _e.mock.On("GetObjectTagging",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockTagger_GetObjectTagging_Call) Run(run func(ctx context.Context, params *s3.GetObjectTaggingInput, optFns ...func(*s3.Options))) *MockTagger_GetObjectTagging_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetObjectTaggingInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetObjectTaggingInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockTagger_GetObjectTagging_Call) Return(getObjectTaggingOutput *s3.GetObjectTaggingOutput, err error) *MockTagger_GetObjectTagging_Call {
	_c.Call.Return(getObjectTaggingOutput, err)
	return _c
}

func (_c *MockTagger_GetObjectTagging_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetObjectTaggingInput, optFns ...func(*s3.Options)) (*s3.GetObjectTaggingOutput, error)) *MockTagger_GetObjectTagging_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketTagging provides a mock function for the type MockTagger
func (_mock *MockTagger) PutBucketTagging(ctx context.Context, params *s3.PutBucketTaggingInput, optFns ...func(*s3.Options)) (*s3.PutBucketTaggingOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketTagging")
	}

	var r0 *s3.PutBucketTaggingOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketTaggingInput, ...func(*s3.Options)) (*s3.PutBucketTaggingOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketTaggingInput, ...func(*s3.Options)) *s3.PutBucketTaggingOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketTaggingOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketTaggingInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTagger_PutBucketTagging_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketTagging'
type MockTagger_PutBucketTagging_Call struct {
	*mock.Call
}

// PutBucketTagging is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketTaggingInput
//   - optFns ...func(*s3.Options)
func (_e *MockTagger_Expecter) PutBucketTagging(ctx interface{}, params interface{}, optFns ...interface{}) *MockTagger_PutBucketTagging_Call {
	return &MockTagger_PutBucketTagging_Call{Call: _e.mock.On("PutBucketTagging",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockTagger_PutBucketTagging_Call) Run(run func(ctx context.Context, params *s3.PutBucketTaggingInput, optFns ...func(*s3.Options))) *MockTagger_PutBucketTagging_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketTaggingInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketTaggingInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockTagger_PutBucketTagging_Call) Return(putBucketTaggingOutput *s3.PutBucketTaggingOutput, err error) *MockTagger_PutBucketTagging_Call {
	_c.Call.Return(putBucketTaggingOutput, err)
	return _c
}

func (_c *MockTagger_PutBucketTagging_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketTaggingInput, optFns ...func(*s3.Options)) (*s3.PutBucketTaggingOutput, error)) *MockTagger_PutBucketTagging_Call {
	_c.Call.Return(run)
	return _c
}

// PutObjectTagging provides a mock function for the type MockTagger
func (_mock *MockTagger) PutObjectTagging(ctx context.Context, params *s3.PutObjectTaggingInput, optFns ...func(*s3.Options)) (*s3.PutObjectTaggingOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutObjectTagging")
	}

	var r0 *s3.PutObjectTaggingOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectTaggingInput, ...func(*s3.Options)) (*s3.PutObjectTaggingOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectTaggingInput, ...func(*s3.Options)) *s3.PutObjectTaggingOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutObjectTaggingOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutObjectTaggingInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTagger_PutObjectTagging_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutObjectTagging'
type MockTagger_PutObjectTagging_Call struct {
	*mock.Call
}

// PutObjectTagging is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutObjectTaggingInput
//   - optFns ...func(*s3.Options)
func (_e *MockTagger_Expecter) PutObjectTagging(ctx interface{}, params interface{}, optFns ...interface{}) *MockTagger_PutObjectTagging_Call {
	return &MockTagger_PutObjectTagging_Call{Call: _e.mock.On("PutObjectTagging",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockTagger_PutObjectTagging_Call) Run(run func(ctx context.Context, params *s3.PutObjectTaggingInput, optFns ...func(*s3.Options))) *MockTagger_PutObjectTagging_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutObjectTaggingInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutObjectTaggingInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockTagger_PutObjectTagging_Call) Return(putObjectTaggingOutput *s3.PutObjectTaggingOutput, err error) *MockTagger_PutObjectTagging_Call {
	_c.Call.Return(putObjectTaggingOutput, err)
	return _c
}

func (_c *MockTagger_PutObjectTagging_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutObjectTaggingInput, optFns ...func(*s3.Options)) (*s3.PutObjectTaggingOutput, error)) *MockTagger_PutObjectTagging_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockPolicyManager creates a new instance of MockPolicyManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPolicyManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockPolicyManager {
	mock := &MockPolicyManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockPolicyManager is an autogenerated mock type for the PolicyManager type
type MockPolicyManager struct {
	mock.Mock
}

type MockPolicyManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPolicyManager) EXPECT() *MockPolicyManager_Expecter {
	return &MockPolicyManager_Expecter{mock: &_m.Mock}
}

// DeleteBucketPolicy provides a mock function for the type MockPolicyManager
func (_mock *MockPolicyManager) DeleteBucketPolicy(ctx context.Context, params *s3.DeleteBucketPolicyInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketPolicyOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketPolicy")
	}

	var r0 *s3.DeleteBucketPolicyOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketPolicyInput, ...func(*s3.Options)) (*s3.DeleteBucketPolicyOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketPolicyInput, ...func(*s3.Options)) *s3.DeleteBucketPolicyOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketPolicyOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketPolicyInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPolicyManager_DeleteBucketPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketPolicy'
type MockPolicyManager_DeleteBucketPolicy_Call struct {
	*mock.Call
}

// DeleteBucketPolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketPolicyInput
//   - optFns ...func(*s3.Options)
func (_e *MockPolicyManager_Expecter) DeleteBucketPolicy(ctx interface{}, params interface{}, optFns ...interface{}) *MockPolicyManager_DeleteBucketPolicy_Call {
	return &MockPolicyManager_DeleteBucketPolicy_Call{Call: _e.mock.On("DeleteBucketPolicy",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockPolicyManager_DeleteBucketPolicy_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketPolicyInput, optFns ...func(*s3.Options))) *MockPolicyManager_DeleteBucketPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketPolicyInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketPolicyInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockPolicyManager_DeleteBucketPolicy_Call) Return(deleteBucketPolicyOutput *s3.DeleteBucketPolicyOutput, err error) *MockPolicyManager_DeleteBucketPolicy_Call {
	_c.Call.Return(deleteBucketPolicyOutput, err)
	return _c
}

func (_c *MockPolicyManager_DeleteBucketPolicy_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketPolicyInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketPolicyOutput, error)) *MockPolicyManager_DeleteBucketPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketPolicy provides a mock function for the type MockPolicyManager
func (_mock *MockPolicyManager) GetBucketPolicy(ctx context.Context, params *s3.GetBucketPolicyInput, optFns ...func(*s3.Options)) (*s3.GetBucketPolicyOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketPolicy")
	}

	var r0 *s3.GetBucketPolicyOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketPolicyInput, ...func(*s3.Options)) (*s3.GetBucketPolicyOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketPolicyInput, ...func(*s3.Options)) *s3.GetBucketPolicyOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketPolicyOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketPolicyInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPolicyManager_GetBucketPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketPolicy'
type MockPolicyManager_GetBucketPolicy_Call struct {
	*mock.Call
}

// GetBucketPolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketPolicyInput
//   - optFns ...func(*s3.Options)
func (_e *MockPolicyManager_Expecter) GetBucketPolicy(ctx interface{}, params interface{}, optFns ...interface{}) *MockPolicyManager_GetBucketPolicy_Call {
	return &MockPolicyManager_GetBucketPolicy_Call{Call: _e.mock.On("GetBucketPolicy",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockPolicyManager_GetBucketPolicy_Call) Run(run func(ctx context.Context, params *s3.GetBucketPolicyInput, optFns ...func(*s3.Options))) *MockPolicyManager_GetBucketPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketPolicyInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketPolicyInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockPolicyManager_GetBucketPolicy_Call) Return(getBucketPolicyOutput *s3.GetBucketPolicyOutput, err error) *MockPolicyManager_GetBucketPolicy_Call {
	_c.Call.Return(getBucketPolicyOutput, err)
	return _c
}

func (_c *MockPolicyManager_GetBucketPolicy_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketPolicyInput, optFns ...func(*s3.Options)) (*s3.GetBucketPolicyOutput, error)) *MockPolicyManager_GetBucketPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketPolicyStatus provides a mock function for the type MockPolicyManager
func (_mock *MockPolicyManager) GetBucketPolicyStatus(ctx context.Context, params *s3.GetBucketPolicyStatusInput, optFns ...func(*s3.Options)) (*s3.GetBucketPolicyStatusOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketPolicyStatus")
	}

	var r0 *s3.GetBucketPolicyStatusOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketPolicyStatusInput, ...func(*s3.Options)) (*s3.GetBucketPolicyStatusOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketPolicyStatusInput, ...func(*s3.Options)) *s3.GetBucketPolicyStatusOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketPolicyStatusOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketPolicyStatusInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPolicyManager_GetBucketPolicyStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketPolicyStatus'
type MockPolicyManager_GetBucketPolicyStatus_Call struct {
	*mock.Call
}

// GetBucketPolicyStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketPolicyStatusInput
//   - optFns ...func(*s3.Options)
func (_e *MockPolicyManager_Expecter) GetBucketPolicyStatus(ctx interface{}, params interface{}, optFns ...interface{}) *MockPolicyManager_GetBucketPolicyStatus_Call {
	return &MockPolicyManager_GetBucketPolicyStatus_Call{Call: _e.mock.On("GetBucketPolicyStatus",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockPolicyManager_GetBucketPolicyStatus_Call) Run(run func(ctx context.Context, params *s3.GetBucketPolicyStatusInput, optFns ...func(*s3.Options))) *MockPolicyManager_GetBucketPolicyStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketPolicyStatusInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketPolicyStatusInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockPolicyManager_GetBucketPolicyStatus_Call) Return(getBucketPolicyStatusOutput *s3.GetBucketPolicyStatusOutput, err error) *MockPolicyManager_GetBucketPolicyStatus_Call {
	_c.Call.Return(getBucketPolicyStatusOutput, err)
	return _c
}

func (_c *MockPolicyManager_GetBucketPolicyStatus_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketPolicyStatusInput, optFns ...func(*s3.Options)) (*s3.GetBucketPolicyStatusOutput, error)) *MockPolicyManager_GetBucketPolicyStatus_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketPolicy provides a mock function for the type MockPolicyManager
func (_mock *MockPolicyManager) PutBucketPolicy(ctx context.Context, params *s3.PutBucketPolicyInput, optFns ...func(*s3.Options)) (*s3.PutBucketPolicyOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketPolicy")
	}

	var r0 *s3.PutBucketPolicyOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketPolicyInput, ...func(*s3.Options)) (*s3.PutBucketPolicyOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketPolicyInput, ...func(*s3.Options)) *s3.PutBucketPolicyOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketPolicyOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketPolicyInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPolicyManager_PutBucketPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketPolicy'
type MockPolicyManager_PutBucketPolicy_Call struct {
	*mock.Call
}

// PutBucketPolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketPolicyInput
//   - optFns ...func(*s3.Options)
func (_e *MockPolicyManager_Expecter) PutBucketPolicy(ctx interface{}, params interface{}, optFns ...interface{}) *MockPolicyManager_PutBucketPolicy_Call {
	return &MockPolicyManager_PutBucketPolicy_Call{Call: _e.mock.On("PutBucketPolicy",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockPolicyManager_PutBucketPolicy_Call) Run(run func(ctx context.Context, params *s3.PutBucketPolicyInput, optFns ...func(*s3.Options))) *MockPolicyManager_PutBucketPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketPolicyInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketPolicyInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockPolicyManager_PutBucketPolicy_Call) Return(putBucketPolicyOutput *s3.PutBucketPolicyOutput, err error) *MockPolicyManager_PutBucketPolicy_Call {
	_c.Call.Return(putBucketPolicyOutput, err)
	return _c
}

func (_c *MockPolicyManager_PutBucketPolicy_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketPolicyInput, optFns ...func(*s3.Options)) (*s3.PutBucketPolicyOutput, error)) *MockPolicyManager_PutBucketPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockPublicAccessBlocker creates a new instance of MockPublicAccessBlocker. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPublicAccessBlocker(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockPublicAccessBlocker {
	mock := &MockPublicAccessBlocker{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockPublicAccessBlocker is an autogenerated mock type for the PublicAccessBlocker type
type MockPublicAccessBlocker struct {
	mock.Mock
}

type MockPublicAccessBlocker_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPublicAccessBlocker) EXPECT() *MockPublicAccessBlocker_Expecter {
	return &MockPublicAccessBlocker_Expecter{mock: &_m.Mock}
}

// DeletePublicAccessBlock provides a mock function for the type MockPublicAccessBlocker
func (_mock *MockPublicAccessBlocker) DeletePublicAccessBlock(ctx context.Context, params *s3.DeletePublicAccessBlockInput, optFns ...func(*s3.Options)) (*s3.DeletePublicAccessBlockOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeletePublicAccessBlock")
	}

	var r0 *s3.DeletePublicAccessBlockOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeletePublicAccessBlockInput, ...func(*s3.Options)) (*s3.DeletePublicAccessBlockOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeletePublicAccessBlockInput, ...func(*s3.Options)) *s3.DeletePublicAccessBlockOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeletePublicAccessBlockOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeletePublicAccessBlockInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPublicAccessBlocker_DeletePublicAccessBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePublicAccessBlock'
type MockPublicAccessBlocker_DeletePublicAccessBlock_Call struct {
	*mock.Call
}

// DeletePublicAccessBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeletePublicAccessBlockInput
//   - optFns ...func(*s3.Options)
func (_e *MockPublicAccessBlocker_Expecter) DeletePublicAccessBlock(ctx interface{}, params interface{}, optFns ...interface{}) *MockPublicAccessBlocker_DeletePublicAccessBlock_Call {
	return &MockPublicAccessBlocker_DeletePublicAccessBlock_Call{Call: _e.mock.On("DeletePublicAccessBlock",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockPublicAccessBlocker_DeletePublicAccessBlock_Call) Run(run func(ctx context.Context, params *s3.DeletePublicAccessBlockInput, optFns ...func(*s3.Options))) *MockPublicAccessBlocker_DeletePublicAccessBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeletePublicAccessBlockInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeletePublicAccessBlockInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockPublicAccessBlocker_DeletePublicAccessBlock_Call) Return(deletePublicAccessBlockOutput *s3.DeletePublicAccessBlockOutput, err error) *MockPublicAccessBlocker_DeletePublicAccessBlock_Call {
	_c.Call.Return(deletePublicAccessBlockOutput, err)
	return _c
}

func (_c *MockPublicAccessBlocker_DeletePublicAccessBlock_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeletePublicAccessBlockInput, optFns ...func(*s3.Options)) (*s3.DeletePublicAccessBlockOutput, error)) *MockPublicAccessBlocker_DeletePublicAccessBlock_Call {
	_c.Call.Return(run)
	return _c
}

// GetPublicAccessBlock provides a mock function for the type MockPublicAccessBlocker
func (_mock *MockPublicAccessBlocker) GetPublicAccessBlock(ctx context.Context, params *s3.GetPublicAccessBlockInput, optFns ...func(*s3.Options)) (*s3.GetPublicAccessBlockOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetPublicAccessBlock")
	}

	var r0 *s3.GetPublicAccessBlockOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetPublicAccessBlockInput, ...func(*s3.Options)) (*s3.GetPublicAccessBlockOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetPublicAccessBlockInput, ...func(*s3.Options)) *s3.GetPublicAccessBlockOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetPublicAccessBlockOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetPublicAccessBlockInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPublicAccessBlocker_GetPublicAccessBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPublicAccessBlock'
type MockPublicAccessBlocker_GetPublicAccessBlock_Call struct {
	*mock.Call
}

// GetPublicAccessBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetPublicAccessBlockInput
//   - optFns ...func(*s3.Options)
func (_e *MockPublicAccessBlocker_Expecter) GetPublicAccessBlock(ctx interface{}, params interface{}, optFns ...interface{}) *MockPublicAccessBlocker_GetPublicAccessBlock_Call {
	return &MockPublicAccessBlocker_GetPublicAccessBlock_Call{Call: _e.mock.On("GetPublicAccessBlock",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockPublicAccessBlocker_GetPublicAccessBlock_Call) Run(run func(ctx context.Context, params *s3.GetPublicAccessBlockInput, optFns ...func(*s3.Options))) *MockPublicAccessBlocker_GetPublicAccessBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetPublicAccessBlockInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetPublicAccessBlockInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockPublicAccessBlocker_GetPublicAccessBlock_Call) Return(getPublicAccessBlockOutput *s3.GetPublicAccessBlockOutput, err error) *MockPublicAccessBlocker_GetPublicAccessBlock_Call {
	_c.Call.Return(getPublicAccessBlockOutput, err)
	return _c
}

func (_c *MockPublicAccessBlocker_GetPublicAccessBlock_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetPublicAccessBlockInput, optFns ...func(*s3.Options)) (*s3.GetPublicAccessBlockOutput, error)) *MockPublicAccessBlocker_GetPublicAccessBlock_Call {
	_c.Call.Return(run)
	return _c
}

// PutPublicAccessBlock provides a mock function for the type MockPublicAccessBlocker
func (_mock *MockPublicAccessBlocker) PutPublicAccessBlock(ctx context.Context, params *s3.PutPublicAccessBlockInput, optFns ...func(*s3.Options)) (*s3.PutPublicAccessBlockOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutPublicAccessBlock")
	}

	var r0 *s3.PutPublicAccessBlockOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutPublicAccessBlockInput, ...func(*s3.Options)) (*s3.PutPublicAccessBlockOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutPublicAccessBlockInput, ...func(*s3.Options)) *s3.PutPublicAccessBlockOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutPublicAccessBlockOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutPublicAccessBlockInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPublicAccessBlocker_PutPublicAccessBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutPublicAccessBlock'
type MockPublicAccessBlocker_PutPublicAccessBlock_Call struct {
	*mock.Call
}

// PutPublicAccessBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutPublicAccessBlockInput
//   - optFns ...func(*s3.Options)
func (_e *MockPublicAccessBlocker_Expecter) PutPublicAccessBlock(ctx interface{}, params interface{}, optFns ...interface{}) *MockPublicAccessBlocker_PutPublicAccessBlock_Call {
	return &MockPublicAccessBlocker_PutPublicAccessBlock_Call{Call: _e.mock.On("PutPublicAccessBlock",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockPublicAccessBlocker_PutPublicAccessBlock_Call) Run(run func(ctx context.Context, params *s3.PutPublicAccessBlockInput, optFns ...func(*s3.Options))) *MockPublicAccessBlocker_PutPublicAccessBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutPublicAccessBlockInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutPublicAccessBlockInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockPublicAccessBlocker_PutPublicAccessBlock_Call) Return(putPublicAccessBlockOutput *s3.PutPublicAccessBlockOutput, err error) *MockPublicAccessBlocker_PutPublicAccessBlock_Call {
	_c.Call.Return(putPublicAccessBlockOutput, err)
	return _c
}

func (_c *MockPublicAccessBlocker_PutPublicAccessBlock_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutPublicAccessBlockInput, optFns ...func(*s3.Options)) (*s3.PutPublicAccessBlockOutput, error)) *MockPublicAccessBlocker_PutPublicAccessBlock_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockEncryptor creates a new instance of MockEncryptor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockEncryptor(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockEncryptor {
	mock := &MockEncryptor{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockEncryptor is an autogenerated mock type for the Encryptor type
type MockEncryptor struct {
	mock.Mock
}

type MockEncryptor_Expecter struct {
	mock *mock.Mock
}

func (_m *MockEncryptor) EXPECT() *MockEncryptor_Expecter {
	return &MockEncryptor_Expecter{mock: &_m.Mock}
}

// DeleteBucketEncryption provides a mock function for the type MockEncryptor
func (_mock *MockEncryptor) DeleteBucketEncryption(ctx context.Context, params *s3.DeleteBucketEncryptionInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketEncryptionOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketEncryption")
	}

	var r0 *s3.DeleteBucketEncryptionOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketEncryptionInput, ...func(*s3.Options)) (*s3.DeleteBucketEncryptionOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketEncryptionInput, ...func(*s3.Options)) *s3.DeleteBucketEncryptionOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketEncryptionOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketEncryptionInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEncryptor_DeleteBucketEncryption_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketEncryption'
type MockEncryptor_DeleteBucketEncryption_Call struct {
	*mock.Call
}

// DeleteBucketEncryption is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketEncryptionInput
//   - optFns ...func(*s3.Options)
func (_e *MockEncryptor_Expecter) DeleteBucketEncryption(ctx interface{}, params interface{}, optFns ...interface{}) *MockEncryptor_DeleteBucketEncryption_Call {
	return &MockEncryptor_DeleteBucketEncryption_Call{Call: _e.mock.On("DeleteBucketEncryption",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockEncryptor_DeleteBucketEncryption_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketEncryptionInput, optFns ...func(*s3.Options))) *MockEncryptor_DeleteBucketEncryption_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketEncryptionInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketEncryptionInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockEncryptor_DeleteBucketEncryption_Call) Return(deleteBucketEncryptionOutput *s3.DeleteBucketEncryptionOutput, err error) *MockEncryptor_DeleteBucketEncryption_Call {
	_c.Call.Return(deleteBucketEncryptionOutput, err)
	return _c
}

func (_c *MockEncryptor_DeleteBucketEncryption_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketEncryptionInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketEncryptionOutput, error)) *MockEncryptor_DeleteBucketEncryption_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketEncryption provides a mock function for the type MockEncryptor
func (_mock *MockEncryptor) GetBucketEncryption(ctx context.Context, params *s3.GetBucketEncryptionInput, optFns ...func(*s3.Options)) (*s3.GetBucketEncryptionOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketEncryption")
	}

	var r0 *s3.GetBucketEncryptionOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketEncryptionInput, ...func(*s3.Options)) (*s3.GetBucketEncryptionOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketEncryptionInput, ...func(*s3.Options)) *s3.GetBucketEncryptionOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketEncryptionOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketEncryptionInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEncryptor_GetBucketEncryption_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketEncryption'
type MockEncryptor_GetBucketEncryption_Call struct {
	*mock.Call
}

// GetBucketEncryption is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketEncryptionInput
//   - optFns ...func(*s3.Options)
func (_e *MockEncryptor_Expecter) GetBucketEncryption(ctx interface{}, params interface{}, optFns ...interface{}) *MockEncryptor_GetBucketEncryption_Call {
	return &MockEncryptor_GetBucketEncryption_Call{Call: _e.mock.On("GetBucketEncryption",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockEncryptor_GetBucketEncryption_Call) Run(run func(ctx context.Context, params *s3.GetBucketEncryptionInput, optFns ...func(*s3.Options))) *MockEncryptor_GetBucketEncryption_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketEncryptionInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketEncryptionInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockEncryptor_GetBucketEncryption_Call) Return(getBucketEncryptionOutput *s3.GetBucketEncryptionOutput, err error) *MockEncryptor_GetBucketEncryption_Call {
	_c.Call.Return(getBucketEncryptionOutput, err)
	return _c
}

func (_c *MockEncryptor_GetBucketEncryption_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketEncryptionInput, optFns ...func(*s3.Options)) (*s3.GetBucketEncryptionOutput, error)) *MockEncryptor_GetBucketEncryption_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketEncryption provides a mock function for the type MockEncryptor
func (_mock *MockEncryptor) PutBucketEncryption(ctx context.Context, params *s3.PutBucketEncryptionInput, optFns ...func(*s3.Options)) (*s3.PutBucketEncryptionOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketEncryption")
	}

	var r0 *s3.PutBucketEncryptionOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketEncryptionInput, ...func(*s3.Options)) (*s3.PutBucketEncryptionOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketEncryptionInput, ...func(*s3.Options)) *s3.PutBucketEncryptionOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketEncryptionOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketEncryptionInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEncryptor_PutBucketEncryption_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketEncryption'
type MockEncryptor_PutBucketEncryption_Call struct {
	*mock.Call
}

// PutBucketEncryption is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketEncryptionInput
//   - optFns ...func(*s3.Options)
func (_e *MockEncryptor_Expecter) PutBucketEncryption(ctx interface{}, params interface{}, optFns ...interface{}) *MockEncryptor_PutBucketEncryption_Call {
	return &MockEncryptor_PutBucketEncryption_Call{Call: _e.mock.On("PutBucketEncryption",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockEncryptor_PutBucketEncryption_Call) Run(run func(ctx context.Context, params *s3.PutBucketEncryptionInput, optFns ...func(*s3.Options))) *MockEncryptor_PutBucketEncryption_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketEncryptionInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketEncryptionInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockEncryptor_PutBucketEncryption_Call) Return(putBucketEncryptionOutput *s3.PutBucketEncryptionOutput, err error) *MockEncryptor_PutBucketEncryption_Call {
	_c.Call.Return(putBucketEncryptionOutput, err)
	return _c
}

func (_c *MockEncryptor_PutBucketEncryption_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketEncryptionInput, optFns ...func(*s3.Options)) (*s3.PutBucketEncryptionOutput, error)) *MockEncryptor_PutBucketEncryption_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockLifecycleManager creates a new instance of MockLifecycleManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLifecycleManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockLifecycleManager {
	mock := &MockLifecycleManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockLifecycleManager is an autogenerated mock type for the LifecycleManager type
type MockLifecycleManager struct {
	mock.Mock
}

type MockLifecycleManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockLifecycleManager) EXPECT() *MockLifecycleManager_Expecter {
	return &MockLifecycleManager_Expecter{mock: &_m.Mock}
}

// DeleteBucketLifecycle provides a mock function for the type MockLifecycleManager
func (_mock *MockLifecycleManager) DeleteBucketLifecycle(ctx context.Context, params *s3.DeleteBucketLifecycleInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketLifecycleOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketLifecycle")
	}

	var r0 *s3.DeleteBucketLifecycleOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketLifecycleInput, ...func(*s3.Options)) (*s3.DeleteBucketLifecycleOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketLifecycleInput, ...func(*s3.Options)) *s3.DeleteBucketLifecycleOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketLifecycleOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketLifecycleInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLifecycleManager_DeleteBucketLifecycle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketLifecycle'
type MockLifecycleManager_DeleteBucketLifecycle_Call struct {
	*mock.Call
}

// DeleteBucketLifecycle is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketLifecycleInput
//   - optFns ...func(*s3.Options)
func (_e *MockLifecycleManager_Expecter) DeleteBucketLifecycle(ctx interface{}, params interface{}, optFns ...interface{}) *MockLifecycleManager_DeleteBucketLifecycle_Call {
	return &MockLifecycleManager_DeleteBucketLifecycle_Call{Call: _e.mock.On("DeleteBucketLifecycle",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockLifecycleManager_DeleteBucketLifecycle_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketLifecycleInput, optFns ...func(*s3.Options))) *MockLifecycleManager_DeleteBucketLifecycle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketLifecycleInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketLifecycleInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockLifecycleManager_DeleteBucketLifecycle_Call) Return(deleteBucketLifecycleOutput *s3.DeleteBucketLifecycleOutput, err error) *MockLifecycleManager_DeleteBucketLifecycle_Call {
	_c.Call.Return(deleteBucketLifecycleOutput, err)
	return _c
}

func (_c *MockLifecycleManager_DeleteBucketLifecycle_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketLifecycleInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketLifecycleOutput, error)) *MockLifecycleManager_DeleteBucketLifecycle_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketLifecycleConfiguration provides a mock function for the type MockLifecycleManager
func (_mock *MockLifecycleManager) GetBucketLifecycleConfiguration(ctx context.Context, params *s3.GetBucketLifecycleConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketLifecycleConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketLifecycleConfiguration")
	}

	var r0 *s3.GetBucketLifecycleConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketLifecycleConfigurationInput, ...func(*s3.Options)) (*s3.GetBucketLifecycleConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketLifecycleConfigurationInput, ...func(*s3.Options)) *s3.GetBucketLifecycleConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketLifecycleConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketLifecycleConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLifecycleManager_GetBucketLifecycleConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketLifecycleConfiguration'
type MockLifecycleManager_GetBucketLifecycleConfiguration_Call struct {
	*mock.Call
}

// GetBucketLifecycleConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketLifecycleConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockLifecycleManager_Expecter) GetBucketLifecycleConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockLifecycleManager_GetBucketLifecycleConfiguration_Call {
	return &MockLifecycleManager_GetBucketLifecycleConfiguration_Call{Call: _e.mock.On("GetBucketLifecycleConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockLifecycleManager_GetBucketLifecycleConfiguration_Call) Run(run func(ctx context.Context, params *s3.GetBucketLifecycleConfigurationInput, optFns ...func(*s3.Options))) *MockLifecycleManager_GetBucketLifecycleConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketLifecycleConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketLifecycleConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockLifecycleManager_GetBucketLifecycleConfiguration_Call) Return(getBucketLifecycleConfigurationOutput *s3.GetBucketLifecycleConfigurationOutput, err error) *MockLifecycleManager_GetBucketLifecycleConfiguration_Call {
	_c.Call.Return(getBucketLifecycleConfigurationOutput, err)
	return _c
}

func (_c *MockLifecycleManager_GetBucketLifecycleConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketLifecycleConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketLifecycleConfigurationOutput, error)) *MockLifecycleManager_GetBucketLifecycleConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketLifecycleConfiguration provides a mock function for the type MockLifecycleManager
func (_mock *MockLifecycleManager) PutBucketLifecycleConfiguration(ctx context.Context, params *s3.PutBucketLifecycleConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketLifecycleConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketLifecycleConfiguration")
	}

	var r0 *s3.PutBucketLifecycleConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketLifecycleConfigurationInput, ...func(*s3.Options)) (*s3.PutBucketLifecycleConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketLifecycleConfigurationInput, ...func(*s3.Options)) *s3.PutBucketLifecycleConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketLifecycleConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketLifecycleConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLifecycleManager_PutBucketLifecycleConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketLifecycleConfiguration'
type MockLifecycleManager_PutBucketLifecycleConfiguration_Call struct {
	*mock.Call
}

// PutBucketLifecycleConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketLifecycleConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockLifecycleManager_Expecter) PutBucketLifecycleConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockLifecycleManager_PutBucketLifecycleConfiguration_Call {
	return &MockLifecycleManager_PutBucketLifecycleConfiguration_Call{Call: _e.mock.On("PutBucketLifecycleConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockLifecycleManager_PutBucketLifecycleConfiguration_Call) Run(run func(ctx context.Context, params *s3.PutBucketLifecycleConfigurationInput, optFns ...func(*s3.Options))) *MockLifecycleManager_PutBucketLifecycleConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketLifecycleConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketLifecycleConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockLifecycleManager_PutBucketLifecycleConfiguration_Call) Return(putBucketLifecycleConfigurationOutput *s3.PutBucketLifecycleConfigurationOutput, err error) *MockLifecycleManager_PutBucketLifecycleConfiguration_Call {
	_c.Call.Return(putBucketLifecycleConfigurationOutput, err)
	return _c
}

func (_c *MockLifecycleManager_PutBucketLifecycleConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketLifecycleConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketLifecycleConfigurationOutput, error)) *MockLifecycleManager_PutBucketLifecycleConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockVersioner creates a new instance of MockVersioner. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockVersioner(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockVersioner {
	mock := &MockVersioner{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockVersioner is an autogenerated mock type for the Versioner type
type MockVersioner struct {
	mock.Mock
}

type MockVersioner_Expecter struct {
	mock *mock.Mock
}

func (_m *MockVersioner) EXPECT() *MockVersioner_Expecter {
	return &MockVersioner_Expecter{mock: &_m.Mock}
}

// GetBucketVersioning provides a mock function for the type MockVersioner
func (_mock *MockVersioner) GetBucketVersioning(ctx context.Context, params *s3.GetBucketVersioningInput, optFns ...func(*s3.Options)) (*s3.GetBucketVersioningOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketVersioning")
	}

	var r0 *s3.GetBucketVersioningOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketVersioningInput, ...func(*s3.Options)) (*s3.GetBucketVersioningOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketVersioningInput, ...func(*s3.Options)) *s3.GetBucketVersioningOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketVersioningOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketVersioningInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockVersioner_GetBucketVersioning_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketVersioning'
type MockVersioner_GetBucketVersioning_Call struct {
	*mock.Call
}

// GetBucketVersioning is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketVersioningInput
//   - optFns ...func(*s3.Options)
func (_e *MockVersioner_Expecter) GetBucketVersioning(ctx interface{}, params interface{}, optFns ...interface{}) *MockVersioner_GetBucketVersioning_Call {
	return &MockVersioner_GetBucketVersioning_Call{Call: _e.mock.On("GetBucketVersioning",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockVersioner_GetBucketVersioning_Call) Run(run func(ctx context.Context, params *s3.GetBucketVersioningInput, optFns ...func(*s3.Options))) *MockVersioner_GetBucketVersioning_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketVersioningInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketVersioningInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockVersioner_GetBucketVersioning_Call) Return(getBucketVersioningOutput *s3.GetBucketVersioningOutput, err error) *MockVersioner_GetBucketVersioning_Call {
	_c.Call.Return(getBucketVersioningOutput, err)
	return _c
}

func (_c *MockVersioner_GetBucketVersioning_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketVersioningInput, optFns ...func(*s3.Options)) (*s3.GetBucketVersioningOutput, error)) *MockVersioner_GetBucketVersioning_Call {
	_c.Call.Return(run)
	return _c
}

// ListObjectVersions provides a mock function for the type MockVersioner
func (_mock *MockVersioner) ListObjectVersions(ctx context.Context, params *s3.ListObjectVersionsInput, optFns ...func(*s3.Options)) (*s3.ListObjectVersionsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListObjectVersions")
	}

	var r0 *s3.ListObjectVersionsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListObjectVersionsInput, ...func(*s3.Options)) (*s3.ListObjectVersionsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListObjectVersionsInput, ...func(*s3.Options)) *s3.ListObjectVersionsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.ListObjectVersionsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.ListObjectVersionsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockVersioner_ListObjectVersions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListObjectVersions'
type MockVersioner_ListObjectVersions_Call struct {
	*mock.Call
}

// ListObjectVersions is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.ListObjectVersionsInput
//   - optFns ...func(*s3.Options)
func (_e *MockVersioner_Expecter) ListObjectVersions(ctx interface{}, params interface{}, optFns ...interface{}) *MockVersioner_ListObjectVersions_Call {
	return &MockVersioner_ListObjectVersions_Call{Call: _e.mock.On("ListObjectVersions",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockVersioner_ListObjectVersions_Call) Run(run func(ctx context.Context, params *s3.ListObjectVersionsInput, optFns ...func(*s3.Options))) *MockVersioner_ListObjectVersions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.ListObjectVersionsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.ListObjectVersionsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockVersioner_ListObjectVersions_Call) Return(listObjectVersionsOutput *s3.ListObjectVersionsOutput, err error) *MockVersioner_ListObjectVersions_Call {
	_c.Call.Return(listObjectVersionsOutput, err)
	return _c
}

func (_c *MockVersioner_ListObjectVersions_Call) RunAndReturn(run func(ctx context.Context, params *s3.ListObjectVersionsInput, optFns ...func(*s3.Options)) (*s3.ListObjectVersionsOutput, error)) *MockVersioner_ListObjectVersions_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketVersioning provides a mock function for the type MockVersioner
func (_mock *MockVersioner) PutBucketVersioning(ctx context.Context, params *s3.PutBucketVersioningInput, optFns ...func(*s3.Options)) (*s3.PutBucketVersioningOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketVersioning")
	}

	var r0 *s3.PutBucketVersioningOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketVersioningInput, ...func(*s3.Options)) (*s3.PutBucketVersioningOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketVersioningInput, ...func(*s3.Options)) *s3.PutBucketVersioningOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketVersioningOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketVersioningInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockVersioner_PutBucketVersioning_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketVersioning'
type MockVersioner_PutBucketVersioning_Call struct {
	*mock.Call
}

// PutBucketVersioning is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketVersioningInput
//   - optFns ...func(*s3.Options)
func (_e *MockVersioner_Expecter) PutBucketVersioning(ctx interface{}, params interface{}, optFns ...interface{}) *MockVersioner_PutBucketVersioning_Call {
	return &MockVersioner_PutBucketVersioning_Call{Call: _e.mock.On("PutBucketVersioning",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockVersioner_PutBucketVersioning_Call) Run(run func(ctx context.Context, params *s3.PutBucketVersioningInput, optFns ...func(*s3.Options))) *MockVersioner_PutBucketVersioning_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketVersioningInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketVersioningInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockVersioner_PutBucketVersioning_Call) Return(putBucketVersioningOutput *s3.PutBucketVersioningOutput, err error) *MockVersioner_PutBucketVersioning_Call {
	_c.Call.Return(putBucketVersioningOutput, err)
	return _c
}

func (_c *MockVersioner_PutBucketVersioning_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketVersioningInput, optFns ...func(*s3.Options)) (*s3.PutBucketVersioningOutput, error)) *MockVersioner_PutBucketVersioning_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockWebsiteManager creates a new instance of MockWebsiteManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockWebsiteManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockWebsiteManager {
	mock := &MockWebsiteManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockWebsiteManager is an autogenerated mock type for the WebsiteManager type
type MockWebsiteManager struct {
	mock.Mock
}

type MockWebsiteManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockWebsiteManager) EXPECT() *MockWebsiteManager_Expecter {
	return &MockWebsiteManager_Expecter{mock: &_m.Mock}
}

// DeleteBucketWebsite provides a mock function for the type MockWebsiteManager
func (_mock *MockWebsiteManager) DeleteBucketWebsite(ctx context.Context, params *s3.DeleteBucketWebsiteInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketWebsiteOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketWebsite")
	}

	var r0 *s3.DeleteBucketWebsiteOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketWebsiteInput, ...func(*s3.Options)) (*s3.DeleteBucketWebsiteOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketWebsiteInput, ...func(*s3.Options)) *s3.DeleteBucketWebsiteOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketWebsiteOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketWebsiteInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockWebsiteManager_DeleteBucketWebsite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketWebsite'
type MockWebsiteManager_DeleteBucketWebsite_Call struct {
	*mock.Call
}

// DeleteBucketWebsite is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketWebsiteInput
//   - optFns ...func(*s3.Options)
func (_e *MockWebsiteManager_Expecter) DeleteBucketWebsite(ctx interface{}, params interface{}, optFns ...interface{}) *MockWebsiteManager_DeleteBucketWebsite_Call {
	return &MockWebsiteManager_DeleteBucketWebsite_Call{Call: _e.mock.On("DeleteBucketWebsite",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockWebsiteManager_DeleteBucketWebsite_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketWebsiteInput, optFns ...func(*s3.Options))) *MockWebsiteManager_DeleteBucketWebsite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketWebsiteInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketWebsiteInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockWebsiteManager_DeleteBucketWebsite_Call) Return(deleteBucketWebsiteOutput *s3.DeleteBucketWebsiteOutput, err error) *MockWebsiteManager_DeleteBucketWebsite_Call {
	_c.Call.Return(deleteBucketWebsiteOutput, err)
	return _c
}

func (_c *MockWebsiteManager_DeleteBucketWebsite_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketWebsiteInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketWebsiteOutput, error)) *MockWebsiteManager_DeleteBucketWebsite_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketWebsite provides a mock function for the type MockWebsiteManager
func (_mock *MockWebsiteManager) GetBucketWebsite(ctx context.Context, params *s3.GetBucketWebsiteInput, optFns ...func(*s3.Options)) (*s3.GetBucketWebsiteOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketWebsite")
	}

	var r0 *s3.GetBucketWebsiteOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketWebsiteInput, ...func(*s3.Options)) (*s3.GetBucketWebsiteOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketWebsiteInput, ...func(*s3.Options)) *s3.GetBucketWebsiteOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketWebsiteOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketWebsiteInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockWebsiteManager_GetBucketWebsite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketWebsite'
type MockWebsiteManager_GetBucketWebsite_Call struct {
	*mock.Call
}

// GetBucketWebsite is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketWebsiteInput
//   - optFns ...func(*s3.Options)
func (_e *MockWebsiteManager_Expecter) GetBucketWebsite(ctx interface{}, params interface{}, optFns ...interface{}) *MockWebsiteManager_GetBucketWebsite_Call {
	return &MockWebsiteManager_GetBucketWebsite_Call{Call: _e.mock.On("GetBucketWebsite",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockWebsiteManager_GetBucketWebsite_Call) Run(run func(ctx context.Context, params *s3.GetBucketWebsiteInput, optFns ...func(*s3.Options))) *MockWebsiteManager_GetBucketWebsite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketWebsiteInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketWebsiteInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockWebsiteManager_GetBucketWebsite_Call) Return(getBucketWebsiteOutput *s3.GetBucketWebsiteOutput, err error) *MockWebsiteManager_GetBucketWebsite_Call {
	_c.Call.Return(getBucketWebsiteOutput, err)
	return _c
}

func (_c *MockWebsiteManager_GetBucketWebsite_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketWebsiteInput, optFns ...func(*s3.Options)) (*s3.GetBucketWebsiteOutput, error)) *MockWebsiteManager_GetBucketWebsite_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketWebsite provides a mock function for the type MockWebsiteManager
func (_mock *MockWebsiteManager) PutBucketWebsite(ctx context.Context, params *s3.PutBucketWebsiteInput, optFns ...func(*s3.Options)) (*s3.PutBucketWebsiteOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketWebsite")
	}

	var r0 *s3.PutBucketWebsiteOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketWebsiteInput, ...func(*s3.Options)) (*s3.PutBucketWebsiteOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketWebsiteInput, ...func(*s3.Options)) *s3.PutBucketWebsiteOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketWebsiteOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketWebsiteInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockWebsiteManager_PutBucketWebsite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketWebsite'
type MockWebsiteManager_PutBucketWebsite_Call struct {
	*mock.Call
}

// PutBucketWebsite is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketWebsiteInput
//   - optFns ...func(*s3.Options)
func (_e *MockWebsiteManager_Expecter) PutBucketWebsite(ctx interface{}, params interface{}, optFns ...interface{}) *MockWebsiteManager_PutBucketWebsite_Call {
	return &MockWebsiteManager_PutBucketWebsite_Call{Call: _e.mock.On("PutBucketWebsite",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockWebsiteManager_PutBucketWebsite_Call) Run(run func(ctx context.Context, params *s3.PutBucketWebsiteInput, optFns ...func(*s3.Options))) *MockWebsiteManager_PutBucketWebsite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketWebsiteInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketWebsiteInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockWebsiteManager_PutBucketWebsite_Call) Return(putBucketWebsiteOutput *s3.PutBucketWebsiteOutput, err error) *MockWebsiteManager_PutBucketWebsite_Call {
	_c.Call.Return(putBucketWebsiteOutput, err)
	return _c
}

func (_c *MockWebsiteManager_PutBucketWebsite_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketWebsiteInput, optFns ...func(*s3.Options)) (*s3.PutBucketWebsiteOutput, error)) *MockWebsiteManager_PutBucketWebsite_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockLoggingManager creates a new instance of MockLoggingManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLoggingManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockLoggingManager {
	mock := &MockLoggingManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockLoggingManager is an autogenerated mock type for the LoggingManager type
type MockLoggingManager struct {
	mock.Mock
}

type MockLoggingManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockLoggingManager) EXPECT() *MockLoggingManager_Expecter {
	return &MockLoggingManager_Expecter{mock: &_m.Mock}
}

// GetBucketLogging provides a mock function for the type MockLoggingManager
func (_mock *MockLoggingManager) GetBucketLogging(ctx context.Context, params *s3.GetBucketLoggingInput, optFns ...func(*s3.Options)) (*s3.GetBucketLoggingOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketLogging")
	}

	var r0 *s3.GetBucketLoggingOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketLoggingInput, ...func(*s3.Options)) (*s3.GetBucketLoggingOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketLoggingInput, ...func(*s3.Options)) *s3.GetBucketLoggingOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketLoggingOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketLoggingInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLoggingManager_GetBucketLogging_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketLogging'
type MockLoggingManager_GetBucketLogging_Call struct {
	*mock.Call
}

// GetBucketLogging is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketLoggingInput
//   - optFns ...func(*s3.Options)
func (_e *MockLoggingManager_Expecter) GetBucketLogging(ctx interface{}, params interface{}, optFns ...interface{}) *MockLoggingManager_GetBucketLogging_Call {
	return &MockLoggingManager_GetBucketLogging_Call{Call: _e.mock.On("GetBucketLogging",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockLoggingManager_GetBucketLogging_Call) Run(run func(ctx context.Context, params *s3.GetBucketLoggingInput, optFns ...func(*s3.Options))) *MockLoggingManager_GetBucketLogging_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketLoggingInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketLoggingInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockLoggingManager_GetBucketLogging_Call) Return(getBucketLoggingOutput *s3.GetBucketLoggingOutput, err error) *MockLoggingManager_GetBucketLogging_Call {
	_c.Call.Return(getBucketLoggingOutput, err)
	return _c
}

func (_c *MockLoggingManager_GetBucketLogging_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketLoggingInput, optFns ...func(*s3.Options)) (*s3.GetBucketLoggingOutput, error)) *MockLoggingManager_GetBucketLogging_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketLogging provides a mock function for the type MockLoggingManager
func (_mock *MockLoggingManager) PutBucketLogging(ctx context.Context, params *s3.PutBucketLoggingInput, optFns ...func(*s3.Options)) (*s3.PutBucketLoggingOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketLogging")
	}

	var r0 *s3.PutBucketLoggingOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketLoggingInput, ...func(*s3.Options)) (*s3.PutBucketLoggingOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketLoggingInput, ...func(*s3.Options)) *s3.PutBucketLoggingOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketLoggingOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketLoggingInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLoggingManager_PutBucketLogging_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketLogging'
type MockLoggingManager_PutBucketLogging_Call struct {
	*mock.Call
}

// PutBucketLogging is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketLoggingInput
//   - optFns ...func(*s3.Options)
func (_e *MockLoggingManager_Expecter) PutBucketLogging(ctx interface{}, params interface{}, optFns ...interface{}) *MockLoggingManager_PutBucketLogging_Call {
	return &MockLoggingManager_PutBucketLogging_Call{Call: _e.mock.On("PutBucketLogging",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockLoggingManager_PutBucketLogging_Call) Run(run func(ctx context.Context, params *s3.PutBucketLoggingInput, optFns ...func(*s3.Options))) *MockLoggingManager_PutBucketLogging_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketLoggingInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketLoggingInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockLoggingManager_PutBucketLogging_Call) Return(putBucketLoggingOutput *s3.PutBucketLoggingOutput, err error) *MockLoggingManager_PutBucketLogging_Call {
	_c.Call.Return(putBucketLoggingOutput, err)
	return _c
}

func (_c *MockLoggingManager_PutBucketLogging_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketLoggingInput, optFns ...func(*s3.Options)) (*s3.PutBucketLoggingOutput, error)) *MockLoggingManager_PutBucketLogging_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockNotificationManager creates a new instance of MockNotificationManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockNotificationManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockNotificationManager {
	mock := &MockNotificationManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockNotificationManager is an autogenerated mock type for the NotificationManager type
type MockNotificationManager struct {
	mock.Mock
}

type MockNotificationManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockNotificationManager) EXPECT() *MockNotificationManager_Expecter {
	return &MockNotificationManager_Expecter{mock: &_m.Mock}
}

// GetBucketNotificationConfiguration provides a mock function for the type MockNotificationManager
func (_mock *MockNotificationManager) GetBucketNotificationConfiguration(ctx context.Context, params *s3.GetBucketNotificationConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketNotificationConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketNotificationConfiguration")
	}

	var r0 *s3.GetBucketNotificationConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketNotificationConfigurationInput, ...func(*s3.Options)) (*s3.GetBucketNotificationConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketNotificationConfigurationInput, ...func(*s3.Options)) *s3.GetBucketNotificationConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketNotificationConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketNotificationConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockNotificationManager_GetBucketNotificationConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketNotificationConfiguration'
type MockNotificationManager_GetBucketNotificationConfiguration_Call struct {
	*mock.Call
}

// GetBucketNotificationConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketNotificationConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockNotificationManager_Expecter) GetBucketNotificationConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockNotificationManager_GetBucketNotificationConfiguration_Call {
	return &MockNotificationManager_GetBucketNotificationConfiguration_Call{Call: _e.mock.On("GetBucketNotificationConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockNotificationManager_GetBucketNotificationConfiguration_Call) Run(run func(ctx context.Context, params *s3.GetBucketNotificationConfigurationInput, optFns ...func(*s3.Options))) *MockNotificationManager_GetBucketNotificationConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketNotificationConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketNotificationConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockNotificationManager_GetBucketNotificationConfiguration_Call) Return(getBucketNotificationConfigurationOutput *s3.GetBucketNotificationConfigurationOutput, err error) *MockNotificationManager_GetBucketNotificationConfiguration_Call {
	_c.Call.Return(getBucketNotificationConfigurationOutput, err)
	return _c
}

func (_c *MockNotificationManager_GetBucketNotificationConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketNotificationConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketNotificationConfigurationOutput, error)) *MockNotificationManager_GetBucketNotificationConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketNotificationConfiguration provides a mock function for the type MockNotificationManager
func (_mock *MockNotificationManager) PutBucketNotificationConfiguration(ctx context.Context, params *s3.PutBucketNotificationConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketNotificationConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketNotificationConfiguration")
	}

	var r0 *s3.PutBucketNotificationConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketNotificationConfigurationInput, ...func(*s3.Options)) (*s3.PutBucketNotificationConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketNotificationConfigurationInput, ...func(*s3.Options)) *s3.PutBucketNotificationConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketNotificationConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketNotificationConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockNotificationManager_PutBucketNotificationConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketNotificationConfiguration'
type MockNotificationManager_PutBucketNotificationConfiguration_Call struct {
	*mock.Call
}

// PutBucketNotificationConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketNotificationConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockNotificationManager_Expecter) PutBucketNotificationConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockNotificationManager_PutBucketNotificationConfiguration_Call {
	return &MockNotificationManager_PutBucketNotificationConfiguration_Call{Call: _e.mock.On("PutBucketNotificationConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockNotificationManager_PutBucketNotificationConfiguration_Call) Run(run func(ctx context.Context, params *s3.PutBucketNotificationConfigurationInput, optFns ...func(*s3.Options))) *MockNotificationManager_PutBucketNotificationConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketNotificationConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketNotificationConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockNotificationManager_PutBucketNotificationConfiguration_Call) Return(putBucketNotificationConfigurationOutput *s3.PutBucketNotificationConfigurationOutput, err error) *MockNotificationManager_PutBucketNotificationConfiguration_Call {
	_c.Call.Return(putBucketNotificationConfigurationOutput, err)
	return _c
}

func (_c *MockNotificationManager_PutBucketNotificationConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketNotificationConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketNotificationConfigurationOutput, error)) *MockNotificationManager_PutBucketNotificationConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockReplicationManager creates a new instance of MockReplicationManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockReplicationManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockReplicationManager {
	mock := &MockReplicationManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockReplicationManager is an autogenerated mock type for the ReplicationManager type
type MockReplicationManager struct {
	mock.Mock
}

type MockReplicationManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockReplicationManager) EXPECT() *MockReplicationManager_Expecter {
	return &MockReplicationManager_Expecter{mock: &_m.Mock}
}

// DeleteBucketReplication provides a mock function for the type MockReplicationManager
func (_mock *MockReplicationManager) DeleteBucketReplication(ctx context.Context, params *s3.DeleteBucketReplicationInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketReplicationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketReplication")
	}

	var r0 *s3.DeleteBucketReplicationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketReplicationInput, ...func(*s3.Options)) (*s3.DeleteBucketReplicationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketReplicationInput, ...func(*s3.Options)) *s3.DeleteBucketReplicationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketReplicationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketReplicationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReplicationManager_DeleteBucketReplication_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketReplication'
type MockReplicationManager_DeleteBucketReplication_Call struct {
	*mock.Call
}

// DeleteBucketReplication is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketReplicationInput
//   - optFns ...func(*s3.Options)
func (_e *MockReplicationManager_Expecter) DeleteBucketReplication(ctx interface{}, params interface{}, optFns ...interface{}) *MockReplicationManager_DeleteBucketReplication_Call {
	return &MockReplicationManager_DeleteBucketReplication_Call{Call: _e.mock.On("DeleteBucketReplication",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockReplicationManager_DeleteBucketReplication_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketReplicationInput, optFns ...func(*s3.Options))) *MockReplicationManager_DeleteBucketReplication_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketReplicationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketReplicationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockReplicationManager_DeleteBucketReplication_Call) Return(deleteBucketReplicationOutput *s3.DeleteBucketReplicationOutput, err error) *MockReplicationManager_DeleteBucketReplication_Call {
	_c.Call.Return(deleteBucketReplicationOutput, err)
	return _c
}

func (_c *MockReplicationManager_DeleteBucketReplication_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketReplicationInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketReplicationOutput, error)) *MockReplicationManager_DeleteBucketReplication_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketReplication provides a mock function for the type MockReplicationManager
func (_mock *MockReplicationManager) GetBucketReplication(ctx context.Context, params *s3.GetBucketReplicationInput, optFns ...func(*s3.Options)) (*s3.GetBucketReplicationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketReplication")
	}

	var r0 *s3.GetBucketReplicationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketReplicationInput, ...func(*s3.Options)) (*s3.GetBucketReplicationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketReplicationInput, ...func(*s3.Options)) *s3.GetBucketReplicationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketReplicationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketReplicationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReplicationManager_GetBucketReplication_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketReplication'
type MockReplicationManager_GetBucketReplication_Call struct {
	*mock.Call
}

// GetBucketReplication is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketReplicationInput
//   - optFns ...func(*s3.Options)
func (_e *MockReplicationManager_Expecter) GetBucketReplication(ctx interface{}, params interface{}, optFns ...interface{}) *MockReplicationManager_GetBucketReplication_Call {
	return &MockReplicationManager_GetBucketReplication_Call{Call: _e.mock.On("GetBucketReplication",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockReplicationManager_GetBucketReplication_Call) Run(run func(ctx context.Context, params *s3.GetBucketReplicationInput, optFns ...func(*s3.Options))) *MockReplicationManager_GetBucketReplication_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketReplicationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketReplicationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockReplicationManager_GetBucketReplication_Call) Return(getBucketReplicationOutput *s3.GetBucketReplicationOutput, err error) *MockReplicationManager_GetBucketReplication_Call {
	_c.Call.Return(getBucketReplicationOutput, err)
	return _c
}

func (_c *MockReplicationManager_GetBucketReplication_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketReplicationInput, optFns ...func(*s3.Options)) (*s3.GetBucketReplicationOutput, error)) *MockReplicationManager_GetBucketReplication_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketReplication provides a mock function for the type MockReplicationManager
func (_mock *MockReplicationManager) PutBucketReplication(ctx context.Context, params *s3.PutBucketReplicationInput, optFns ...func(*s3.Options)) (*s3.PutBucketReplicationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketReplication")
	}

	var r0 *s3.PutBucketReplicationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketReplicationInput, ...func(*s3.Options)) (*s3.PutBucketReplicationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketReplicationInput, ...func(*s3.Options)) *s3.PutBucketReplicationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketReplicationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketReplicationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReplicationManager_PutBucketReplication_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketReplication'
type MockReplicationManager_PutBucketReplication_Call struct {
	*mock.Call
}

// PutBucketReplication is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketReplicationInput
//   - optFns ...func(*s3.Options)
func (_e *MockReplicationManager_Expecter) PutBucketReplication(ctx interface{}, params interface{}, optFns ...interface{}) *MockReplicationManager_PutBucketReplication_Call {
	return &MockReplicationManager_PutBucketReplication_Call{Call: _e.mock.On("PutBucketReplication",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockReplicationManager_PutBucketReplication_Call) Run(run func(ctx context.Context, params *s3.PutBucketReplicationInput, optFns ...func(*s3.Options))) *MockReplicationManager_PutBucketReplication_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketReplicationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketReplicationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockReplicationManager_PutBucketReplication_Call) Return(putBucketReplicationOutput *s3.PutBucketReplicationOutput, err error) *MockReplicationManager_PutBucketReplication_Call {
	_c.Call.Return(putBucketReplicationOutput, err)
	return _c
}

func (_c *MockReplicationManager_PutBucketReplication_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketReplicationInput, optFns ...func(*s3.Options)) (*s3.PutBucketReplicationOutput, error)) *MockReplicationManager_PutBucketReplication_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockCORSManager creates a new instance of MockCORSManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCORSManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockCORSManager {
	mock := &MockCORSManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockCORSManager is an autogenerated mock type for the CORSManager type
type MockCORSManager struct {
	mock.Mock
}

type MockCORSManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockCORSManager) EXPECT() *MockCORSManager_Expecter {
	return &MockCORSManager_Expecter{mock: &_m.Mock}
}

// DeleteBucketCors provides a mock function for the type MockCORSManager
func (_mock *MockCORSManager) DeleteBucketCors(ctx context.Context, params *s3.DeleteBucketCorsInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketCorsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketCors")
	}

	var r0 *s3.DeleteBucketCorsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketCorsInput, ...func(*s3.Options)) (*s3.DeleteBucketCorsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketCorsInput, ...func(*s3.Options)) *s3.DeleteBucketCorsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketCorsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketCorsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCORSManager_DeleteBucketCors_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketCors'
type MockCORSManager_DeleteBucketCors_Call struct {
	*mock.Call
}

// DeleteBucketCors is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketCorsInput
//   - optFns ...func(*s3.Options)
func (_e *MockCORSManager_Expecter) DeleteBucketCors(ctx interface{}, params interface{}, optFns ...interface{}) *MockCORSManager_DeleteBucketCors_Call {
	return &MockCORSManager_DeleteBucketCors_Call{Call: _e.mock.On("DeleteBucketCors",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockCORSManager_DeleteBucketCors_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketCorsInput, optFns ...func(*s3.Options))) *MockCORSManager_DeleteBucketCors_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketCorsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketCorsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockCORSManager_DeleteBucketCors_Call) Return(deleteBucketCorsOutput *s3.DeleteBucketCorsOutput, err error) *MockCORSManager_DeleteBucketCors_Call {
	_c.Call.Return(deleteBucketCorsOutput, err)
	return _c
}

func (_c *MockCORSManager_DeleteBucketCors_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketCorsInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketCorsOutput, error)) *MockCORSManager_DeleteBucketCors_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketCors provides a mock function for the type MockCORSManager
func (_mock *MockCORSManager) GetBucketCors(ctx context.Context, params *s3.GetBucketCorsInput, optFns ...func(*s3.Options)) (*s3.GetBucketCorsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketCors")
	}

	var r0 *s3.GetBucketCorsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketCorsInput, ...func(*s3.Options)) (*s3.GetBucketCorsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketCorsInput, ...func(*s3.Options)) *s3.GetBucketCorsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketCorsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketCorsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCORSManager_GetBucketCors_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketCors'
type MockCORSManager_GetBucketCors_Call struct {
	*mock.Call
}

// GetBucketCors is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketCorsInput
//   - optFns ...func(*s3.Options)
func (_e *MockCORSManager_Expecter) GetBucketCors(ctx interface{}, params interface{}, optFns ...interface{}) *MockCORSManager_GetBucketCors_Call {
	return &MockCORSManager_GetBucketCors_Call{Call: _e.mock.On("GetBucketCors",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockCORSManager_GetBucketCors_Call) Run(run func(ctx context.Context, params *s3.GetBucketCorsInput, optFns ...func(*s3.Options))) *MockCORSManager_GetBucketCors_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketCorsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketCorsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockCORSManager_GetBucketCors_Call) Return(getBucketCorsOutput *s3.GetBucketCorsOutput, err error) *MockCORSManager_GetBucketCors_Call {
	_c.Call.Return(getBucketCorsOutput, err)
	return _c
}

func (_c *MockCORSManager_GetBucketCors_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketCorsInput, optFns ...func(*s3.Options)) (*s3.GetBucketCorsOutput, error)) *MockCORSManager_GetBucketCors_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketCors provides a mock function for the type MockCORSManager
func (_mock *MockCORSManager) PutBucketCors(ctx context.Context, params *s3.PutBucketCorsInput, optFns ...func(*s3.Options)) (*s3.PutBucketCorsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketCors")
	}

	var r0 *s3.PutBucketCorsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketCorsInput, ...func(*s3.Options)) (*s3.PutBucketCorsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketCorsInput, ...func(*s3.Options)) *s3.PutBucketCorsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketCorsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketCorsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockCORSManager_PutBucketCors_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketCors'
type MockCORSManager_PutBucketCors_Call struct {
	*mock.Call
}

// PutBucketCors is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketCorsInput
//   - optFns ...func(*s3.Options)
func (_e *MockCORSManager_Expecter) PutBucketCors(ctx interface{}, params interface{}, optFns ...interface{}) *MockCORSManager_PutBucketCors_Call {
	return &MockCORSManager_PutBucketCors_Call{Call: _e.mock.On("PutBucketCors",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockCORSManager_PutBucketCors_Call) Run(run func(ctx context.Context, params *s3.PutBucketCorsInput, optFns ...func(*s3.Options))) *MockCORSManager_PutBucketCors_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketCorsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketCorsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockCORSManager_PutBucketCors_Call) Return(putBucketCorsOutput *s3.PutBucketCorsOutput, err error) *MockCORSManager_PutBucketCors_Call {
	_c.Call.Return(putBucketCorsOutput, err)
	return _c
}

func (_c *MockCORSManager_PutBucketCors_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketCorsInput, optFns ...func(*s3.Options)) (*s3.PutBucketCorsOutput, error)) *MockCORSManager_PutBucketCors_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockAccelerator creates a new instance of MockAccelerator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAccelerator(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAccelerator {
	mock := &MockAccelerator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockAccelerator is an autogenerated mock type for the Accelerator type
type MockAccelerator struct {
	mock.Mock
}

type MockAccelerator_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAccelerator) EXPECT() *MockAccelerator_Expecter {
	return &MockAccelerator_Expecter{mock: &_m.Mock}
}

// GetBucketAccelerateConfiguration provides a mock function for the type MockAccelerator
func (_mock *MockAccelerator) GetBucketAccelerateConfiguration(ctx context.Context, params *s3.GetBucketAccelerateConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketAccelerateConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketAccelerateConfiguration")
	}

	var r0 *s3.GetBucketAccelerateConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketAccelerateConfigurationInput, ...func(*s3.Options)) (*s3.GetBucketAccelerateConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketAccelerateConfigurationInput, ...func(*s3.Options)) *s3.GetBucketAccelerateConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketAccelerateConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketAccelerateConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccelerator_GetBucketAccelerateConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketAccelerateConfiguration'
type MockAccelerator_GetBucketAccelerateConfiguration_Call struct {
	*mock.Call
}

// GetBucketAccelerateConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketAccelerateConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockAccelerator_Expecter) GetBucketAccelerateConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockAccelerator_GetBucketAccelerateConfiguration_Call {
	return &MockAccelerator_GetBucketAccelerateConfiguration_Call{Call: _e.mock.On("GetBucketAccelerateConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockAccelerator_GetBucketAccelerateConfiguration_Call) Run(run func(ctx context.Context, params *s3.GetBucketAccelerateConfigurationInput, optFns ...func(*s3.Options))) *MockAccelerator_GetBucketAccelerateConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketAccelerateConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketAccelerateConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockAccelerator_GetBucketAccelerateConfiguration_Call) Return(getBucketAccelerateConfigurationOutput *s3.GetBucketAccelerateConfigurationOutput, err error) *MockAccelerator_GetBucketAccelerateConfiguration_Call {
	_c.Call.Return(getBucketAccelerateConfigurationOutput, err)
	return _c
}

func (_c *MockAccelerator_GetBucketAccelerateConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketAccelerateConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketAccelerateConfigurationOutput, error)) *MockAccelerator_GetBucketAccelerateConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketAccelerateConfiguration provides a mock function for the type MockAccelerator
func (_mock *MockAccelerator) PutBucketAccelerateConfiguration(ctx context.Context, params *s3.PutBucketAccelerateConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketAccelerateConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketAccelerateConfiguration")
	}

	var r0 *s3.PutBucketAccelerateConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketAccelerateConfigurationInput, ...func(*s3.Options)) (*s3.PutBucketAccelerateConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketAccelerateConfigurationInput, ...func(*s3.Options)) *s3.PutBucketAccelerateConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketAccelerateConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketAccelerateConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAccelerator_PutBucketAccelerateConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketAccelerateConfiguration'
type MockAccelerator_PutBucketAccelerateConfiguration_Call struct {
	*mock.Call
}

// PutBucketAccelerateConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketAccelerateConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockAccelerator_Expecter) PutBucketAccelerateConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockAccelerator_PutBucketAccelerateConfiguration_Call {
	return &MockAccelerator_PutBucketAccelerateConfiguration_Call{Call: _e.mock.On("PutBucketAccelerateConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockAccelerator_PutBucketAccelerateConfiguration_Call) Run(run func(ctx context.Context, params *s3.PutBucketAccelerateConfigurationInput, optFns ...func(*s3.Options))) *MockAccelerator_PutBucketAccelerateConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketAccelerateConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketAccelerateConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockAccelerator_PutBucketAccelerateConfiguration_Call) Return(putBucketAccelerateConfigurationOutput *s3.PutBucketAccelerateConfigurationOutput, err error) *MockAccelerator_PutBucketAccelerateConfiguration_Call {
	_c.Call.Return(putBucketAccelerateConfigurationOutput, err)
	return _c
}

func (_c *MockAccelerator_PutBucketAccelerateConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketAccelerateConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketAccelerateConfigurationOutput, error)) *MockAccelerator_PutBucketAccelerateConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockMetricsManager creates a new instance of MockMetricsManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockMetricsManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockMetricsManager {
	mock := &MockMetricsManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockMetricsManager is an autogenerated mock type for the MetricsManager type
type MockMetricsManager struct {
	mock.Mock
}

type MockMetricsManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockMetricsManager) EXPECT() *MockMetricsManager_Expecter {
	return &MockMetricsManager_Expecter{mock: &_m.Mock}
}

// DeleteBucketMetricsConfiguration provides a mock function for the type MockMetricsManager
func (_mock *MockMetricsManager) DeleteBucketMetricsConfiguration(ctx context.Context, params *s3.DeleteBucketMetricsConfigurationInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketMetricsConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketMetricsConfiguration")
	}

	var r0 *s3.DeleteBucketMetricsConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketMetricsConfigurationInput, ...func(*s3.Options)) (*s3.DeleteBucketMetricsConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketMetricsConfigurationInput, ...func(*s3.Options)) *s3.DeleteBucketMetricsConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketMetricsConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketMetricsConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricsManager_DeleteBucketMetricsConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketMetricsConfiguration'
type MockMetricsManager_DeleteBucketMetricsConfiguration_Call struct {
	*mock.Call
}

// DeleteBucketMetricsConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketMetricsConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockMetricsManager_Expecter) DeleteBucketMetricsConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockMetricsManager_DeleteBucketMetricsConfiguration_Call {
	return &MockMetricsManager_DeleteBucketMetricsConfiguration_Call{Call: _e.mock.On("DeleteBucketMetricsConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockMetricsManager_DeleteBucketMetricsConfiguration_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketMetricsConfigurationInput, optFns ...func(*s3.Options))) *MockMetricsManager_DeleteBucketMetricsConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketMetricsConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketMetricsConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockMetricsManager_DeleteBucketMetricsConfiguration_Call) Return(deleteBucketMetricsConfigurationOutput *s3.DeleteBucketMetricsConfigurationOutput, err error) *MockMetricsManager_DeleteBucketMetricsConfiguration_Call {
	_c.Call.Return(deleteBucketMetricsConfigurationOutput, err)
	return _c
}

func (_c *MockMetricsManager_DeleteBucketMetricsConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketMetricsConfigurationInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketMetricsConfigurationOutput, error)) *MockMetricsManager_DeleteBucketMetricsConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketMetricsConfiguration provides a mock function for the type MockMetricsManager
func (_mock *MockMetricsManager) GetBucketMetricsConfiguration(ctx context.Context, params *s3.GetBucketMetricsConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketMetricsConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketMetricsConfiguration")
	}

	var r0 *s3.GetBucketMetricsConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketMetricsConfigurationInput, ...func(*s3.Options)) (*s3.GetBucketMetricsConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketMetricsConfigurationInput, ...func(*s3.Options)) *s3.GetBucketMetricsConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketMetricsConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketMetricsConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricsManager_GetBucketMetricsConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketMetricsConfiguration'
type MockMetricsManager_GetBucketMetricsConfiguration_Call struct {
	*mock.Call
}

// GetBucketMetricsConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketMetricsConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockMetricsManager_Expecter) GetBucketMetricsConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockMetricsManager_GetBucketMetricsConfiguration_Call {
	return &MockMetricsManager_GetBucketMetricsConfiguration_Call{Call: _e.mock.On("GetBucketMetricsConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockMetricsManager_GetBucketMetricsConfiguration_Call) Run(run func(ctx context.Context, params *s3.GetBucketMetricsConfigurationInput, optFns ...func(*s3.Options))) *MockMetricsManager_GetBucketMetricsConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketMetricsConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketMetricsConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockMetricsManager_GetBucketMetricsConfiguration_Call) Return(getBucketMetricsConfigurationOutput *s3.GetBucketMetricsConfigurationOutput, err error) *MockMetricsManager_GetBucketMetricsConfiguration_Call {
	_c.Call.Return(getBucketMetricsConfigurationOutput, err)
	return _c
}

func (_c *MockMetricsManager_GetBucketMetricsConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketMetricsConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketMetricsConfigurationOutput, error)) *MockMetricsManager_GetBucketMetricsConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketMetricsConfiguration provides a mock function for the type MockMetricsManager
func (_mock *MockMetricsManager) PutBucketMetricsConfiguration(ctx context.Context, params *s3.PutBucketMetricsConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketMetricsConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketMetricsConfiguration")
	}

	var r0 *s3.PutBucketMetricsConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketMetricsConfigurationInput, ...func(*s3.Options)) (*s3.PutBucketMetricsConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketMetricsConfigurationInput, ...func(*s3.Options)) *s3.PutBucketMetricsConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketMetricsConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketMetricsConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockMetricsManager_PutBucketMetricsConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketMetricsConfiguration'
type MockMetricsManager_PutBucketMetricsConfiguration_Call struct {
	*mock.Call
}

// PutBucketMetricsConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketMetricsConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockMetricsManager_Expecter) PutBucketMetricsConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockMetricsManager_PutBucketMetricsConfiguration_Call {
	return &MockMetricsManager_PutBucketMetricsConfiguration_Call{Call: _e.mock.On("PutBucketMetricsConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockMetricsManager_PutBucketMetricsConfiguration_Call) Run(run func(ctx context.Context, params *s3.PutBucketMetricsConfigurationInput, optFns ...func(*s3.Options))) *MockMetricsManager_PutBucketMetricsConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketMetricsConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketMetricsConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockMetricsManager_PutBucketMetricsConfiguration_Call) Return(putBucketMetricsConfigurationOutput *s3.PutBucketMetricsConfigurationOutput, err error) *MockMetricsManager_PutBucketMetricsConfiguration_Call {
	_c.Call.Return(putBucketMetricsConfigurationOutput, err)
	return _c
}

func (_c *MockMetricsManager_PutBucketMetricsConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketMetricsConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketMetricsConfigurationOutput, error)) *MockMetricsManager_PutBucketMetricsConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockAnalyticsManager creates a new instance of MockAnalyticsManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAnalyticsManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAnalyticsManager {
	mock := &MockAnalyticsManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockAnalyticsManager is an autogenerated mock type for the AnalyticsManager type
type MockAnalyticsManager struct {
	mock.Mock
}

type MockAnalyticsManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAnalyticsManager) EXPECT() *MockAnalyticsManager_Expecter {
	return &MockAnalyticsManager_Expecter{mock: &_m.Mock}
}

// DeleteBucketAnalyticsConfiguration provides a mock function for the type MockAnalyticsManager
func (_mock *MockAnalyticsManager) DeleteBucketAnalyticsConfiguration(ctx context.Context, params *s3.DeleteBucketAnalyticsConfigurationInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketAnalyticsConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketAnalyticsConfiguration")
	}

	var r0 *s3.DeleteBucketAnalyticsConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketAnalyticsConfigurationInput, ...func(*s3.Options)) (*s3.DeleteBucketAnalyticsConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketAnalyticsConfigurationInput, ...func(*s3.Options)) *s3.DeleteBucketAnalyticsConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketAnalyticsConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketAnalyticsConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAnalyticsManager_DeleteBucketAnalyticsConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketAnalyticsConfiguration'
type MockAnalyticsManager_DeleteBucketAnalyticsConfiguration_Call struct {
	*mock.Call
}

// DeleteBucketAnalyticsConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketAnalyticsConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockAnalyticsManager_Expecter) DeleteBucketAnalyticsConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockAnalyticsManager_DeleteBucketAnalyticsConfiguration_Call {
	return &MockAnalyticsManager_DeleteBucketAnalyticsConfiguration_Call{Call: _e.mock.On("DeleteBucketAnalyticsConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockAnalyticsManager_DeleteBucketAnalyticsConfiguration_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketAnalyticsConfigurationInput, optFns ...func(*s3.Options))) *MockAnalyticsManager_DeleteBucketAnalyticsConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketAnalyticsConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketAnalyticsConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockAnalyticsManager_DeleteBucketAnalyticsConfiguration_Call) Return(deleteBucketAnalyticsConfigurationOutput *s3.DeleteBucketAnalyticsConfigurationOutput, err error) *MockAnalyticsManager_DeleteBucketAnalyticsConfiguration_Call {
	_c.Call.Return(deleteBucketAnalyticsConfigurationOutput, err)
	return _c
}

func (_c *MockAnalyticsManager_DeleteBucketAnalyticsConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketAnalyticsConfigurationInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketAnalyticsConfigurationOutput, error)) *MockAnalyticsManager_DeleteBucketAnalyticsConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketAnalyticsConfiguration provides a mock function for the type MockAnalyticsManager
func (_mock *MockAnalyticsManager) GetBucketAnalyticsConfiguration(ctx context.Context, params *s3.GetBucketAnalyticsConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketAnalyticsConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketAnalyticsConfiguration")
	}

	var r0 *s3.GetBucketAnalyticsConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketAnalyticsConfigurationInput, ...func(*s3.Options)) (*s3.GetBucketAnalyticsConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketAnalyticsConfigurationInput, ...func(*s3.Options)) *s3.GetBucketAnalyticsConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketAnalyticsConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketAnalyticsConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAnalyticsManager_GetBucketAnalyticsConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketAnalyticsConfiguration'
type MockAnalyticsManager_GetBucketAnalyticsConfiguration_Call struct {
	*mock.Call
}

// GetBucketAnalyticsConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketAnalyticsConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockAnalyticsManager_Expecter) GetBucketAnalyticsConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockAnalyticsManager_GetBucketAnalyticsConfiguration_Call {
	return &MockAnalyticsManager_GetBucketAnalyticsConfiguration_Call{Call: _e.mock.On("GetBucketAnalyticsConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockAnalyticsManager_GetBucketAnalyticsConfiguration_Call) Run(run func(ctx context.Context, params *s3.GetBucketAnalyticsConfigurationInput, optFns ...func(*s3.Options))) *MockAnalyticsManager_GetBucketAnalyticsConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketAnalyticsConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketAnalyticsConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockAnalyticsManager_GetBucketAnalyticsConfiguration_Call) Return(getBucketAnalyticsConfigurationOutput *s3.GetBucketAnalyticsConfigurationOutput, err error) *MockAnalyticsManager_GetBucketAnalyticsConfiguration_Call {
	_c.Call.Return(getBucketAnalyticsConfigurationOutput, err)
	return _c
}

func (_c *MockAnalyticsManager_GetBucketAnalyticsConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketAnalyticsConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketAnalyticsConfigurationOutput, error)) *MockAnalyticsManager_GetBucketAnalyticsConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketAnalyticsConfiguration provides a mock function for the type MockAnalyticsManager
func (_mock *MockAnalyticsManager) PutBucketAnalyticsConfiguration(ctx context.Context, params *s3.PutBucketAnalyticsConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketAnalyticsConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketAnalyticsConfiguration")
	}

	var r0 *s3.PutBucketAnalyticsConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketAnalyticsConfigurationInput, ...func(*s3.Options)) (*s3.PutBucketAnalyticsConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketAnalyticsConfigurationInput, ...func(*s3.Options)) *s3.PutBucketAnalyticsConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketAnalyticsConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketAnalyticsConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAnalyticsManager_PutBucketAnalyticsConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketAnalyticsConfiguration'
type MockAnalyticsManager_PutBucketAnalyticsConfiguration_Call struct {
	*mock.Call
}

// PutBucketAnalyticsConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketAnalyticsConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockAnalyticsManager_Expecter) PutBucketAnalyticsConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockAnalyticsManager_PutBucketAnalyticsConfiguration_Call {
	return &MockAnalyticsManager_PutBucketAnalyticsConfiguration_Call{Call: _e.mock.On("PutBucketAnalyticsConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockAnalyticsManager_PutBucketAnalyticsConfiguration_Call) Run(run func(ctx context.Context, params *s3.PutBucketAnalyticsConfigurationInput, optFns ...func(*s3.Options))) *MockAnalyticsManager_PutBucketAnalyticsConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketAnalyticsConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketAnalyticsConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockAnalyticsManager_PutBucketAnalyticsConfiguration_Call) Return(putBucketAnalyticsConfigurationOutput *s3.PutBucketAnalyticsConfigurationOutput, err error) *MockAnalyticsManager_PutBucketAnalyticsConfiguration_Call {
	_c.Call.Return(putBucketAnalyticsConfigurationOutput, err)
	return _c
}

func (_c *MockAnalyticsManager_PutBucketAnalyticsConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketAnalyticsConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketAnalyticsConfigurationOutput, error)) *MockAnalyticsManager_PutBucketAnalyticsConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockInventoryManager creates a new instance of MockInventoryManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockInventoryManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockInventoryManager {
	mock := &MockInventoryManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockInventoryManager is an autogenerated mock type for the InventoryManager type
type MockInventoryManager struct {
	mock.Mock
}

type MockInventoryManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockInventoryManager) EXPECT() *MockInventoryManager_Expecter {
	return &MockInventoryManager_Expecter{mock: &_m.Mock}
}

// DeleteBucketInventoryConfiguration provides a mock function for the type MockInventoryManager
func (_mock *MockInventoryManager) DeleteBucketInventoryConfiguration(ctx context.Context, params *s3.DeleteBucketInventoryConfigurationInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketInventoryConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketInventoryConfiguration")
	}

	var r0 *s3.DeleteBucketInventoryConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketInventoryConfigurationInput, ...func(*s3.Options)) (*s3.DeleteBucketInventoryConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketInventoryConfigurationInput, ...func(*s3.Options)) *s3.DeleteBucketInventoryConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketInventoryConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketInventoryConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockInventoryManager_DeleteBucketInventoryConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketInventoryConfiguration'
type MockInventoryManager_DeleteBucketInventoryConfiguration_Call struct {
	*mock.Call
}

// DeleteBucketInventoryConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketInventoryConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockInventoryManager_Expecter) DeleteBucketInventoryConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockInventoryManager_DeleteBucketInventoryConfiguration_Call {
	return &MockInventoryManager_DeleteBucketInventoryConfiguration_Call{Call: _e.mock.On("DeleteBucketInventoryConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockInventoryManager_DeleteBucketInventoryConfiguration_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketInventoryConfigurationInput, optFns ...func(*s3.Options))) *MockInventoryManager_DeleteBucketInventoryConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketInventoryConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketInventoryConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockInventoryManager_DeleteBucketInventoryConfiguration_Call) Return(deleteBucketInventoryConfigurationOutput *s3.DeleteBucketInventoryConfigurationOutput, err error) *MockInventoryManager_DeleteBucketInventoryConfiguration_Call {
	_c.Call.Return(deleteBucketInventoryConfigurationOutput, err)
	return _c
}

func (_c *MockInventoryManager_DeleteBucketInventoryConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketInventoryConfigurationInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketInventoryConfigurationOutput, error)) *MockInventoryManager_DeleteBucketInventoryConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketInventoryConfiguration provides a mock function for the type MockInventoryManager
func (_mock *MockInventoryManager) GetBucketInventoryConfiguration(ctx context.Context, params *s3.GetBucketInventoryConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketInventoryConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketInventoryConfiguration")
	}

	var r0 *s3.GetBucketInventoryConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketInventoryConfigurationInput, ...func(*s3.Options)) (*s3.GetBucketInventoryConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketInventoryConfigurationInput, ...func(*s3.Options)) *s3.GetBucketInventoryConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketInventoryConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketInventoryConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockInventoryManager_GetBucketInventoryConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketInventoryConfiguration'
type MockInventoryManager_GetBucketInventoryConfiguration_Call struct {
	*mock.Call
}

// GetBucketInventoryConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketInventoryConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockInventoryManager_Expecter) GetBucketInventoryConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockInventoryManager_GetBucketInventoryConfiguration_Call {
	return &MockInventoryManager_GetBucketInventoryConfiguration_Call{Call: _e.mock.On("GetBucketInventoryConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockInventoryManager_GetBucketInventoryConfiguration_Call) Run(run func(ctx context.Context, params *s3.GetBucketInventoryConfigurationInput, optFns ...func(*s3.Options))) *MockInventoryManager_GetBucketInventoryConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketInventoryConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketInventoryConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockInventoryManager_GetBucketInventoryConfiguration_Call) Return(getBucketInventoryConfigurationOutput *s3.GetBucketInventoryConfigurationOutput, err error) *MockInventoryManager_GetBucketInventoryConfiguration_Call {
	_c.Call.Return(getBucketInventoryConfigurationOutput, err)
	return _c
}

func (_c *MockInventoryManager_GetBucketInventoryConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketInventoryConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketInventoryConfigurationOutput, error)) *MockInventoryManager_GetBucketInventoryConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketInventoryConfiguration provides a mock function for the type MockInventoryManager
func (_mock *MockInventoryManager) PutBucketInventoryConfiguration(ctx context.Context, params *s3.PutBucketInventoryConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketInventoryConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketInventoryConfiguration")
	}

	var r0 *s3.PutBucketInventoryConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketInventoryConfigurationInput, ...func(*s3.Options)) (*s3.PutBucketInventoryConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketInventoryConfigurationInput, ...func(*s3.Options)) *s3.PutBucketInventoryConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketInventoryConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketInventoryConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockInventoryManager_PutBucketInventoryConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketInventoryConfiguration'
type MockInventoryManager_PutBucketInventoryConfiguration_Call struct {
	*mock.Call
}

// PutBucketInventoryConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketInventoryConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockInventoryManager_Expecter) PutBucketInventoryConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockInventoryManager_PutBucketInventoryConfiguration_Call {
	return &MockInventoryManager_PutBucketInventoryConfiguration_Call{Call: _e.mock.On("PutBucketInventoryConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockInventoryManager_PutBucketInventoryConfiguration_Call) Run(run func(ctx context.Context, params *s3.PutBucketInventoryConfigurationInput, optFns ...func(*s3.Options))) *MockInventoryManager_PutBucketInventoryConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketInventoryConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketInventoryConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockInventoryManager_PutBucketInventoryConfiguration_Call) Return(putBucketInventoryConfigurationOutput *s3.PutBucketInventoryConfigurationOutput, err error) *MockInventoryManager_PutBucketInventoryConfiguration_Call {
	_c.Call.Return(putBucketInventoryConfigurationOutput, err)
	return _c
}

func (_c *MockInventoryManager_PutBucketInventoryConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketInventoryConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketInventoryConfigurationOutput, error)) *MockInventoryManager_PutBucketInventoryConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockIntelligentTieringManager creates a new instance of MockIntelligentTieringManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockIntelligentTieringManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockIntelligentTieringManager {
	mock := &MockIntelligentTieringManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockIntelligentTieringManager is an autogenerated mock type for the IntelligentTieringManager type
type MockIntelligentTieringManager struct {
	mock.Mock
}

type MockIntelligentTieringManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockIntelligentTieringManager) EXPECT() *MockIntelligentTieringManager_Expecter {
	return &MockIntelligentTieringManager_Expecter{mock: &_m.Mock}
}

// DeleteBucketIntelligentTieringConfiguration provides a mock function for the type MockIntelligentTieringManager
func (_mock *MockIntelligentTieringManager) DeleteBucketIntelligentTieringConfiguration(ctx context.Context, params *s3.DeleteBucketIntelligentTieringConfigurationInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketIntelligentTieringConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketIntelligentTieringConfiguration")
	}

	var r0 *s3.DeleteBucketIntelligentTieringConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketIntelligentTieringConfigurationInput, ...func(*s3.Options)) (*s3.DeleteBucketIntelligentTieringConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketIntelligentTieringConfigurationInput, ...func(*s3.Options)) *s3.DeleteBucketIntelligentTieringConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketIntelligentTieringConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketIntelligentTieringConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIntelligentTieringManager_DeleteBucketIntelligentTieringConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketIntelligentTieringConfiguration'
type MockIntelligentTieringManager_DeleteBucketIntelligentTieringConfiguration_Call struct {
	*mock.Call
}

// DeleteBucketIntelligentTieringConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketIntelligentTieringConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockIntelligentTieringManager_Expecter) DeleteBucketIntelligentTieringConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockIntelligentTieringManager_DeleteBucketIntelligentTieringConfiguration_Call {
	return &MockIntelligentTieringManager_DeleteBucketIntelligentTieringConfiguration_Call{Call: _e.mock.On("DeleteBucketIntelligentTieringConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockIntelligentTieringManager_DeleteBucketIntelligentTieringConfiguration_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketIntelligentTieringConfigurationInput, optFns ...func(*s3.Options))) *MockIntelligentTieringManager_DeleteBucketIntelligentTieringConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketIntelligentTieringConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketIntelligentTieringConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockIntelligentTieringManager_DeleteBucketIntelligentTieringConfiguration_Call) Return(deleteBucketIntelligentTieringConfigurationOutput *s3.DeleteBucketIntelligentTieringConfigurationOutput, err error) *MockIntelligentTieringManager_DeleteBucketIntelligentTieringConfiguration_Call {
	_c.Call.Return(deleteBucketIntelligentTieringConfigurationOutput, err)
	return _c
}

func (_c *MockIntelligentTieringManager_DeleteBucketIntelligentTieringConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketIntelligentTieringConfigurationInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketIntelligentTieringConfigurationOutput, error)) *MockIntelligentTieringManager_DeleteBucketIntelligentTieringConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketIntelligentTieringConfiguration provides a mock function for the type MockIntelligentTieringManager
func (_mock *MockIntelligentTieringManager) GetBucketIntelligentTieringConfiguration(ctx context.Context, params *s3.GetBucketIntelligentTieringConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketIntelligentTieringConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketIntelligentTieringConfiguration")
	}

	var r0 *s3.GetBucketIntelligentTieringConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketIntelligentTieringConfigurationInput, ...func(*s3.Options)) (*s3.GetBucketIntelligentTieringConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketIntelligentTieringConfigurationInput, ...func(*s3.Options)) *s3.GetBucketIntelligentTieringConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketIntelligentTieringConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketIntelligentTieringConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIntelligentTieringManager_GetBucketIntelligentTieringConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketIntelligentTieringConfiguration'
type MockIntelligentTieringManager_GetBucketIntelligentTieringConfiguration_Call struct {
	*mock.Call
}

// GetBucketIntelligentTieringConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketIntelligentTieringConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockIntelligentTieringManager_Expecter) GetBucketIntelligentTieringConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockIntelligentTieringManager_GetBucketIntelligentTieringConfiguration_Call {
	return &MockIntelligentTieringManager_GetBucketIntelligentTieringConfiguration_Call{Call: _e.mock.On("GetBucketIntelligentTieringConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockIntelligentTieringManager_GetBucketIntelligentTieringConfiguration_Call) Run(run func(ctx context.Context, params *s3.GetBucketIntelligentTieringConfigurationInput, optFns ...func(*s3.Options))) *MockIntelligentTieringManager_GetBucketIntelligentTieringConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketIntelligentTieringConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketIntelligentTieringConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockIntelligentTieringManager_GetBucketIntelligentTieringConfiguration_Call) Return(getBucketIntelligentTieringConfigurationOutput *s3.GetBucketIntelligentTieringConfigurationOutput, err error) *MockIntelligentTieringManager_GetBucketIntelligentTieringConfiguration_Call {
	_c.Call.Return(getBucketIntelligentTieringConfigurationOutput, err)
	return _c
}

func (_c *MockIntelligentTieringManager_GetBucketIntelligentTieringConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketIntelligentTieringConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketIntelligentTieringConfigurationOutput, error)) *MockIntelligentTieringManager_GetBucketIntelligentTieringConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketIntelligentTieringConfiguration provides a mock function for the type MockIntelligentTieringManager
func (_mock *MockIntelligentTieringManager) PutBucketIntelligentTieringConfiguration(ctx context.Context, params *s3.PutBucketIntelligentTieringConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketIntelligentTieringConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketIntelligentTieringConfiguration")
	}

	var r0 *s3.PutBucketIntelligentTieringConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketIntelligentTieringConfigurationInput, ...func(*s3.Options)) (*s3.PutBucketIntelligentTieringConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketIntelligentTieringConfigurationInput, ...func(*s3.Options)) *s3.PutBucketIntelligentTieringConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketIntelligentTieringConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketIntelligentTieringConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIntelligentTieringManager_PutBucketIntelligentTieringConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketIntelligentTieringConfiguration'
type MockIntelligentTieringManager_PutBucketIntelligentTieringConfiguration_Call struct {
	*mock.Call
}

// PutBucketIntelligentTieringConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketIntelligentTieringConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockIntelligentTieringManager_Expecter) PutBucketIntelligentTieringConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockIntelligentTieringManager_PutBucketIntelligentTieringConfiguration_Call {
	return &MockIntelligentTieringManager_PutBucketIntelligentTieringConfiguration_Call{Call: _e.mock.On("PutBucketIntelligentTieringConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockIntelligentTieringManager_PutBucketIntelligentTieringConfiguration_Call) Run(run func(ctx context.Context, params *s3.PutBucketIntelligentTieringConfigurationInput, optFns ...func(*s3.Options))) *MockIntelligentTieringManager_PutBucketIntelligentTieringConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketIntelligentTieringConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketIntelligentTieringConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockIntelligentTieringManager_PutBucketIntelligentTieringConfiguration_Call) Return(putBucketIntelligentTieringConfigurationOutput *s3.PutBucketIntelligentTieringConfigurationOutput, err error) *MockIntelligentTieringManager_PutBucketIntelligentTieringConfiguration_Call {
	_c.Call.Return(putBucketIntelligentTieringConfigurationOutput, err)
	return _c
}

func (_c *MockIntelligentTieringManager_PutBucketIntelligentTieringConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketIntelligentTieringConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketIntelligentTieringConfigurationOutput, error)) *MockIntelligentTieringManager_PutBucketIntelligentTieringConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockOwnershipManager creates a new instance of MockOwnershipManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockOwnershipManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockOwnershipManager {
	mock := &MockOwnershipManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockOwnershipManager is an autogenerated mock type for the OwnershipManager type
type MockOwnershipManager struct {
	mock.Mock
}

type MockOwnershipManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockOwnershipManager) EXPECT() *MockOwnershipManager_Expecter {
	return &MockOwnershipManager_Expecter{mock: &_m.Mock}
}

// DeleteBucketOwnershipControls provides a mock function for the type MockOwnershipManager
func (_mock *MockOwnershipManager) DeleteBucketOwnershipControls(ctx context.Context, params *s3.DeleteBucketOwnershipControlsInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketOwnershipControlsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketOwnershipControls")
	}

	var r0 *s3.DeleteBucketOwnershipControlsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketOwnershipControlsInput, ...func(*s3.Options)) (*s3.DeleteBucketOwnershipControlsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketOwnershipControlsInput, ...func(*s3.Options)) *s3.DeleteBucketOwnershipControlsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketOwnershipControlsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketOwnershipControlsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOwnershipManager_DeleteBucketOwnershipControls_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketOwnershipControls'
type MockOwnershipManager_DeleteBucketOwnershipControls_Call struct {
	*mock.Call
}

// DeleteBucketOwnershipControls is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketOwnershipControlsInput
//   - optFns ...func(*s3.Options)
func (_e *MockOwnershipManager_Expecter) DeleteBucketOwnershipControls(ctx interface{}, params interface{}, optFns ...interface{}) *MockOwnershipManager_DeleteBucketOwnershipControls_Call {
	return &MockOwnershipManager_DeleteBucketOwnershipControls_Call{Call: _e.mock.On("DeleteBucketOwnershipControls",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockOwnershipManager_DeleteBucketOwnershipControls_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketOwnershipControlsInput, optFns ...func(*s3.Options))) *MockOwnershipManager_DeleteBucketOwnershipControls_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketOwnershipControlsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketOwnershipControlsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOwnershipManager_DeleteBucketOwnershipControls_Call) Return(deleteBucketOwnershipControlsOutput *s3.DeleteBucketOwnershipControlsOutput, err error) *MockOwnershipManager_DeleteBucketOwnershipControls_Call {
	_c.Call.Return(deleteBucketOwnershipControlsOutput, err)
	return _c
}

func (_c *MockOwnershipManager_DeleteBucketOwnershipControls_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketOwnershipControlsInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketOwnershipControlsOutput, error)) *MockOwnershipManager_DeleteBucketOwnershipControls_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketOwnershipControls provides a mock function for the type MockOwnershipManager
func (_mock *MockOwnershipManager) GetBucketOwnershipControls(ctx context.Context, params *s3.GetBucketOwnershipControlsInput, optFns ...func(*s3.Options)) (*s3.GetBucketOwnershipControlsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketOwnershipControls")
	}

	var r0 *s3.GetBucketOwnershipControlsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketOwnershipControlsInput, ...func(*s3.Options)) (*s3.GetBucketOwnershipControlsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketOwnershipControlsInput, ...func(*s3.Options)) *s3.GetBucketOwnershipControlsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketOwnershipControlsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketOwnershipControlsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOwnershipManager_GetBucketOwnershipControls_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketOwnershipControls'
type MockOwnershipManager_GetBucketOwnershipControls_Call struct {
	*mock.Call
}

// GetBucketOwnershipControls is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketOwnershipControlsInput
//   - optFns ...func(*s3.Options)
func (_e *MockOwnershipManager_Expecter) GetBucketOwnershipControls(ctx interface{}, params interface{}, optFns ...interface{}) *MockOwnershipManager_GetBucketOwnershipControls_Call {
	return &MockOwnershipManager_GetBucketOwnershipControls_Call{Call: _e.mock.On("GetBucketOwnershipControls",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockOwnershipManager_GetBucketOwnershipControls_Call) Run(run func(ctx context.Context, params *s3.GetBucketOwnershipControlsInput, optFns ...func(*s3.Options))) *MockOwnershipManager_GetBucketOwnershipControls_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketOwnershipControlsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketOwnershipControlsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOwnershipManager_GetBucketOwnershipControls_Call) Return(getBucketOwnershipControlsOutput *s3.GetBucketOwnershipControlsOutput, err error) *MockOwnershipManager_GetBucketOwnershipControls_Call {
	_c.Call.Return(getBucketOwnershipControlsOutput, err)
	return _c
}

func (_c *MockOwnershipManager_GetBucketOwnershipControls_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketOwnershipControlsInput, optFns ...func(*s3.Options)) (*s3.GetBucketOwnershipControlsOutput, error)) *MockOwnershipManager_GetBucketOwnershipControls_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketOwnershipControls provides a mock function for the type MockOwnershipManager
func (_mock *MockOwnershipManager) PutBucketOwnershipControls(ctx context.Context, params *s3.PutBucketOwnershipControlsInput, optFns ...func(*s3.Options)) (*s3.PutBucketOwnershipControlsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketOwnershipControls")
	}

	var r0 *s3.PutBucketOwnershipControlsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketOwnershipControlsInput, ...func(*s3.Options)) (*s3.PutBucketOwnershipControlsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketOwnershipControlsInput, ...func(*s3.Options)) *s3.PutBucketOwnershipControlsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketOwnershipControlsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketOwnershipControlsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOwnershipManager_PutBucketOwnershipControls_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketOwnershipControls'
type MockOwnershipManager_PutBucketOwnershipControls_Call struct {
	*mock.Call
}

// PutBucketOwnershipControls is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketOwnershipControlsInput
//   - optFns ...func(*s3.Options)
func (_e *MockOwnershipManager_Expecter) PutBucketOwnershipControls(ctx interface{}, params interface{}, optFns ...interface{}) *MockOwnershipManager_PutBucketOwnershipControls_Call {
	return &MockOwnershipManager_PutBucketOwnershipControls_Call{Call: _e.mock.On("PutBucketOwnershipControls",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockOwnershipManager_PutBucketOwnershipControls_Call) Run(run func(ctx context.Context, params *s3.PutBucketOwnershipControlsInput, optFns ...func(*s3.Options))) *MockOwnershipManager_PutBucketOwnershipControls_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketOwnershipControlsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketOwnershipControlsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockOwnershipManager_PutBucketOwnershipControls_Call) Return(putBucketOwnershipControlsOutput *s3.PutBucketOwnershipControlsOutput, err error) *MockOwnershipManager_PutBucketOwnershipControls_Call {
	_c.Call.Return(putBucketOwnershipControlsOutput, err)
	return _c
}

func (_c *MockOwnershipManager_PutBucketOwnershipControls_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketOwnershipControlsInput, optFns ...func(*s3.Options)) (*s3.PutBucketOwnershipControlsOutput, error)) *MockOwnershipManager_PutBucketOwnershipControls_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockRequestPaymentManager creates a new instance of MockRequestPaymentManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRequestPaymentManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockRequestPaymentManager {
	mock := &MockRequestPaymentManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockRequestPaymentManager is an autogenerated mock type for the RequestPaymentManager type
type MockRequestPaymentManager struct {
	mock.Mock
}

type MockRequestPaymentManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRequestPaymentManager) EXPECT() *MockRequestPaymentManager_Expecter {
	return &MockRequestPaymentManager_Expecter{mock: &_m.Mock}
}

// GetBucketRequestPayment provides a mock function for the type MockRequestPaymentManager
func (_mock *MockRequestPaymentManager) GetBucketRequestPayment(ctx context.Context, params *s3.GetBucketRequestPaymentInput, optFns ...func(*s3.Options)) (*s3.GetBucketRequestPaymentOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketRequestPayment")
	}

	var r0 *s3.GetBucketRequestPaymentOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketRequestPaymentInput, ...func(*s3.Options)) (*s3.GetBucketRequestPaymentOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketRequestPaymentInput, ...func(*s3.Options)) *s3.GetBucketRequestPaymentOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketRequestPaymentOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketRequestPaymentInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRequestPaymentManager_GetBucketRequestPayment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketRequestPayment'
type MockRequestPaymentManager_GetBucketRequestPayment_Call struct {
	*mock.Call
}

// GetBucketRequestPayment is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketRequestPaymentInput
//   - optFns ...func(*s3.Options)
func (_e *MockRequestPaymentManager_Expecter) GetBucketRequestPayment(ctx interface{}, params interface{}, optFns ...interface{}) *MockRequestPaymentManager_GetBucketRequestPayment_Call {
	return &MockRequestPaymentManager_GetBucketRequestPayment_Call{Call: _e.mock.On("GetBucketRequestPayment",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockRequestPaymentManager_GetBucketRequestPayment_Call) Run(run func(ctx context.Context, params *s3.GetBucketRequestPaymentInput, optFns ...func(*s3.Options))) *MockRequestPaymentManager_GetBucketRequestPayment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketRequestPaymentInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketRequestPaymentInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockRequestPaymentManager_GetBucketRequestPayment_Call) Return(getBucketRequestPaymentOutput *s3.GetBucketRequestPaymentOutput, err error) *MockRequestPaymentManager_GetBucketRequestPayment_Call {
	_c.Call.Return(getBucketRequestPaymentOutput, err)
	return _c
}

func (_c *MockRequestPaymentManager_GetBucketRequestPayment_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketRequestPaymentInput, optFns ...func(*s3.Options)) (*s3.GetBucketRequestPaymentOutput, error)) *MockRequestPaymentManager_GetBucketRequestPayment_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketRequestPayment provides a mock function for the type MockRequestPaymentManager
func (_mock *MockRequestPaymentManager) PutBucketRequestPayment(ctx context.Context, params *s3.PutBucketRequestPaymentInput, optFns ...func(*s3.Options)) (*s3.PutBucketRequestPaymentOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketRequestPayment")
	}

	var r0 *s3.PutBucketRequestPaymentOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketRequestPaymentInput, ...func(*s3.Options)) (*s3.PutBucketRequestPaymentOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketRequestPaymentInput, ...func(*s3.Options)) *s3.PutBucketRequestPaymentOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketRequestPaymentOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketRequestPaymentInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRequestPaymentManager_PutBucketRequestPayment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketRequestPayment'
type MockRequestPaymentManager_PutBucketRequestPayment_Call struct {
	*mock.Call
}

// PutBucketRequestPayment is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketRequestPaymentInput
//   - optFns ...func(*s3.Options)
func (_e *MockRequestPaymentManager_Expecter) PutBucketRequestPayment(ctx interface{}, params interface{}, optFns ...interface{}) *MockRequestPaymentManager_PutBucketRequestPayment_Call {
	return &MockRequestPaymentManager_PutBucketRequestPayment_Call{Call: _e.mock.On("PutBucketRequestPayment",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockRequestPaymentManager_PutBucketRequestPayment_Call) Run(run func(ctx context.Context, params *s3.PutBucketRequestPaymentInput, optFns ...func(*s3.Options))) *MockRequestPaymentManager_PutBucketRequestPayment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketRequestPaymentInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketRequestPaymentInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockRequestPaymentManager_PutBucketRequestPayment_Call) Return(putBucketRequestPaymentOutput *s3.PutBucketRequestPaymentOutput, err error) *MockRequestPaymentManager_PutBucketRequestPayment_Call {
	_c.Call.Return(putBucketRequestPaymentOutput, err)
	return _c
}

func (_c *MockRequestPaymentManager_PutBucketRequestPayment_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketRequestPaymentInput, optFns ...func(*s3.Options)) (*s3.PutBucketRequestPaymentOutput, error)) *MockRequestPaymentManager_PutBucketRequestPayment_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockLocator creates a new instance of MockLocator. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLocator(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockLocator {
	mock := &MockLocator{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockLocator is an autogenerated mock type for the Locator type
type MockLocator struct {
	mock.Mock
}

type MockLocator_Expecter struct {
	mock *mock.Mock
}

func (_m *MockLocator) EXPECT() *MockLocator_Expecter {
	return &MockLocator_Expecter{mock: &_m.Mock}
}

// GetBucketLocation provides a mock function for the type MockLocator
func (_mock *MockLocator) GetBucketLocation(ctx context.Context, params *s3.GetBucketLocationInput, optFns ...func(*s3.Options)) (*s3.GetBucketLocationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketLocation")
	}

	var r0 *s3.GetBucketLocationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketLocationInput, ...func(*s3.Options)) (*s3.GetBucketLocationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketLocationInput, ...func(*s3.Options)) *s3.GetBucketLocationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketLocationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketLocationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLocator_GetBucketLocation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketLocation'
type MockLocator_GetBucketLocation_Call struct {
	*mock.Call
}

// GetBucketLocation is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketLocationInput
//   - optFns ...func(*s3.Options)
func (_e *MockLocator_Expecter) GetBucketLocation(ctx interface{}, params interface{}, optFns ...interface{}) *MockLocator_GetBucketLocation_Call {
	return &MockLocator_GetBucketLocation_Call{Call: _e.mock.On("GetBucketLocation",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockLocator_GetBucketLocation_Call) Run(run func(ctx context.Context, params *s3.GetBucketLocationInput, optFns ...func(*s3.Options))) *MockLocator_GetBucketLocation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketLocationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketLocationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockLocator_GetBucketLocation_Call) Return(getBucketLocationOutput *s3.GetBucketLocationOutput, err error) *MockLocator_GetBucketLocation_Call {
	_c.Call.Return(getBucketLocationOutput, err)
	return _c
}

func (_c *MockLocator_GetBucketLocation_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketLocationInput, optFns ...func(*s3.Options)) (*s3.GetBucketLocationOutput, error)) *MockLocator_GetBucketLocation_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockObjectLockManager creates a new instance of MockObjectLockManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockObjectLockManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockObjectLockManager {
	mock := &MockObjectLockManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockObjectLockManager is an autogenerated mock type for the ObjectLockManager type
type MockObjectLockManager struct {
	mock.Mock
}

type MockObjectLockManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockObjectLockManager) EXPECT() *MockObjectLockManager_Expecter {
	return &MockObjectLockManager_Expecter{mock: &_m.Mock}
}

// GetObjectLockConfiguration provides a mock function for the type MockObjectLockManager
func (_mock *MockObjectLockManager) GetObjectLockConfiguration(ctx context.Context, params *s3.GetObjectLockConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetObjectLockConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetObjectLockConfiguration")
	}

	var r0 *s3.GetObjectLockConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectLockConfigurationInput, ...func(*s3.Options)) (*s3.GetObjectLockConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectLockConfigurationInput, ...func(*s3.Options)) *s3.GetObjectLockConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetObjectLockConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetObjectLockConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockObjectLockManager_GetObjectLockConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetObjectLockConfiguration'
type MockObjectLockManager_GetObjectLockConfiguration_Call struct {
	*mock.Call
}

// GetObjectLockConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetObjectLockConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockObjectLockManager_Expecter) GetObjectLockConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockObjectLockManager_GetObjectLockConfiguration_Call {
	return &MockObjectLockManager_GetObjectLockConfiguration_Call{Call: _e.mock.On("GetObjectLockConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockObjectLockManager_GetObjectLockConfiguration_Call) Run(run func(ctx context.Context, params *s3.GetObjectLockConfigurationInput, optFns ...func(*s3.Options))) *MockObjectLockManager_GetObjectLockConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetObjectLockConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetObjectLockConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockObjectLockManager_GetObjectLockConfiguration_Call) Return(getObjectLockConfigurationOutput *s3.GetObjectLockConfigurationOutput, err error) *MockObjectLockManager_GetObjectLockConfiguration_Call {
	_c.Call.Return(getObjectLockConfigurationOutput, err)
	return _c
}

func (_c *MockObjectLockManager_GetObjectLockConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetObjectLockConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetObjectLockConfigurationOutput, error)) *MockObjectLockManager_GetObjectLockConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// PutObjectLockConfiguration provides a mock function for the type MockObjectLockManager
func (_mock *MockObjectLockManager) PutObjectLockConfiguration(ctx context.Context, params *s3.PutObjectLockConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutObjectLockConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutObjectLockConfiguration")
	}

	var r0 *s3.PutObjectLockConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectLockConfigurationInput, ...func(*s3.Options)) (*s3.PutObjectLockConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectLockConfigurationInput, ...func(*s3.Options)) *s3.PutObjectLockConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutObjectLockConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutObjectLockConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockObjectLockManager_PutObjectLockConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutObjectLockConfiguration'
type MockObjectLockManager_PutObjectLockConfiguration_Call struct {
	*mock.Call
}

// PutObjectLockConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutObjectLockConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockObjectLockManager_Expecter) PutObjectLockConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockObjectLockManager_PutObjectLockConfiguration_Call {
	return &MockObjectLockManager_PutObjectLockConfiguration_Call{Call: _e.mock.On("PutObjectLockConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockObjectLockManager_PutObjectLockConfiguration_Call) Run(run func(ctx context.Context, params *s3.PutObjectLockConfigurationInput, optFns ...func(*s3.Options))) *MockObjectLockManager_PutObjectLockConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutObjectLockConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutObjectLockConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockObjectLockManager_PutObjectLockConfiguration_Call) Return(putObjectLockConfigurationOutput *s3.PutObjectLockConfigurationOutput, err error) *MockObjectLockManager_PutObjectLockConfiguration_Call {
	_c.Call.Return(putObjectLockConfigurationOutput, err)
	return _c
}

func (_c *MockObjectLockManager_PutObjectLockConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutObjectLockConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutObjectLockConfigurationOutput, error)) *MockObjectLockManager_PutObjectLockConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockLegalHoldManager creates a new instance of MockLegalHoldManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLegalHoldManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockLegalHoldManager {
	mock := &MockLegalHoldManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockLegalHoldManager is an autogenerated mock type for the LegalHoldManager type
type MockLegalHoldManager struct {
	mock.Mock
}

type MockLegalHoldManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockLegalHoldManager) EXPECT() *MockLegalHoldManager_Expecter {
	return &MockLegalHoldManager_Expecter{mock: &_m.Mock}
}

// GetObjectLegalHold provides a mock function for the type MockLegalHoldManager
func (_mock *MockLegalHoldManager) GetObjectLegalHold(ctx context.Context, params *s3.GetObjectLegalHoldInput, optFns ...func(*s3.Options)) (*s3.GetObjectLegalHoldOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetObjectLegalHold")
	}

	var r0 *s3.GetObjectLegalHoldOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectLegalHoldInput, ...func(*s3.Options)) (*s3.GetObjectLegalHoldOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectLegalHoldInput, ...func(*s3.Options)) *s3.GetObjectLegalHoldOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetObjectLegalHoldOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetObjectLegalHoldInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLegalHoldManager_GetObjectLegalHold_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetObjectLegalHold'
type MockLegalHoldManager_GetObjectLegalHold_Call struct {
	*mock.Call
}

// GetObjectLegalHold is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetObjectLegalHoldInput
//   - optFns ...func(*s3.Options)
func (_e *MockLegalHoldManager_Expecter) GetObjectLegalHold(ctx interface{}, params interface{}, optFns ...interface{}) *MockLegalHoldManager_GetObjectLegalHold_Call {
	return &MockLegalHoldManager_GetObjectLegalHold_Call{Call: _e.mock.On("GetObjectLegalHold",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockLegalHoldManager_GetObjectLegalHold_Call) Run(run func(ctx context.Context, params *s3.GetObjectLegalHoldInput, optFns ...func(*s3.Options))) *MockLegalHoldManager_GetObjectLegalHold_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetObjectLegalHoldInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetObjectLegalHoldInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockLegalHoldManager_GetObjectLegalHold_Call) Return(getObjectLegalHoldOutput *s3.GetObjectLegalHoldOutput, err error) *MockLegalHoldManager_GetObjectLegalHold_Call {
	_c.Call.Return(getObjectLegalHoldOutput, err)
	return _c
}

func (_c *MockLegalHoldManager_GetObjectLegalHold_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetObjectLegalHoldInput, optFns ...func(*s3.Options)) (*s3.GetObjectLegalHoldOutput, error)) *MockLegalHoldManager_GetObjectLegalHold_Call {
	_c.Call.Return(run)
	return _c
}

// PutObjectLegalHold provides a mock function for the type MockLegalHoldManager
func (_mock *MockLegalHoldManager) PutObjectLegalHold(ctx context.Context, params *s3.PutObjectLegalHoldInput, optFns ...func(*s3.Options)) (*s3.PutObjectLegalHoldOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutObjectLegalHold")
	}

	var r0 *s3.PutObjectLegalHoldOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectLegalHoldInput, ...func(*s3.Options)) (*s3.PutObjectLegalHoldOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectLegalHoldInput, ...func(*s3.Options)) *s3.PutObjectLegalHoldOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutObjectLegalHoldOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutObjectLegalHoldInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLegalHoldManager_PutObjectLegalHold_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutObjectLegalHold'
type MockLegalHoldManager_PutObjectLegalHold_Call struct {
	*mock.Call
}

// PutObjectLegalHold is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutObjectLegalHoldInput
//   - optFns ...func(*s3.Options)
func (_e *MockLegalHoldManager_Expecter) PutObjectLegalHold(ctx interface{}, params interface{}, optFns ...interface{}) *MockLegalHoldManager_PutObjectLegalHold_Call {
	return &MockLegalHoldManager_PutObjectLegalHold_Call{Call: _e.mock.On("PutObjectLegalHold",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockLegalHoldManager_PutObjectLegalHold_Call) Run(run func(ctx context.Context, params *s3.PutObjectLegalHoldInput, optFns ...func(*s3.Options))) *MockLegalHoldManager_PutObjectLegalHold_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutObjectLegalHoldInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutObjectLegalHoldInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockLegalHoldManager_PutObjectLegalHold_Call) Return(putObjectLegalHoldOutput *s3.PutObjectLegalHoldOutput, err error) *MockLegalHoldManager_PutObjectLegalHold_Call {
	_c.Call.Return(putObjectLegalHoldOutput, err)
	return _c
}

func (_c *MockLegalHoldManager_PutObjectLegalHold_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutObjectLegalHoldInput, optFns ...func(*s3.Options)) (*s3.PutObjectLegalHoldOutput, error)) *MockLegalHoldManager_PutObjectLegalHold_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockRetentionManager creates a new instance of MockRetentionManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRetentionManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockRetentionManager {
	mock := &MockRetentionManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockRetentionManager is an autogenerated mock type for the RetentionManager type
type MockRetentionManager struct {
	mock.Mock
}

type MockRetentionManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRetentionManager) EXPECT() *MockRetentionManager_Expecter {
	return &MockRetentionManager_Expecter{mock: &_m.Mock}
}

// GetObjectRetention provides a mock function for the type MockRetentionManager
func (_mock *MockRetentionManager) GetObjectRetention(ctx context.Context, params *s3.GetObjectRetentionInput, optFns ...func(*s3.Options)) (*s3.GetObjectRetentionOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetObjectRetention")
	}

	var r0 *s3.GetObjectRetentionOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectRetentionInput, ...func(*s3.Options)) (*s3.GetObjectRetentionOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectRetentionInput, ...func(*s3.Options)) *s3.GetObjectRetentionOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetObjectRetentionOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetObjectRetentionInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRetentionManager_GetObjectRetention_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetObjectRetention'
type MockRetentionManager_GetObjectRetention_Call struct {
	*mock.Call
}

// GetObjectRetention is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetObjectRetentionInput
//   - optFns ...func(*s3.Options)
func (_e *MockRetentionManager_Expecter) GetObjectRetention(ctx interface{}, params interface{}, optFns ...interface{}) *MockRetentionManager_GetObjectRetention_Call {
	return &MockRetentionManager_GetObjectRetention_Call{Call: _e.mock.On("GetObjectRetention",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockRetentionManager_GetObjectRetention_Call) Run(run func(ctx context.Context, params *s3.GetObjectRetentionInput, optFns ...func(*s3.Options))) *MockRetentionManager_GetObjectRetention_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetObjectRetentionInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetObjectRetentionInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockRetentionManager_GetObjectRetention_Call) Return(getObjectRetentionOutput *s3.GetObjectRetentionOutput, err error) *MockRetentionManager_GetObjectRetention_Call {
	_c.Call.Return(getObjectRetentionOutput, err)
	return _c
}

func (_c *MockRetentionManager_GetObjectRetention_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetObjectRetentionInput, optFns ...func(*s3.Options)) (*s3.GetObjectRetentionOutput, error)) *MockRetentionManager_GetObjectRetention_Call {
	_c.Call.Return(run)
	return _c
}

// PutObjectRetention provides a mock function for the type MockRetentionManager
func (_mock *MockRetentionManager) PutObjectRetention(ctx context.Context, params *s3.PutObjectRetentionInput, optFns ...func(*s3.Options)) (*s3.PutObjectRetentionOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutObjectRetention")
	}

	var r0 *s3.PutObjectRetentionOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectRetentionInput, ...func(*s3.Options)) (*s3.PutObjectRetentionOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectRetentionInput, ...func(*s3.Options)) *s3.PutObjectRetentionOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutObjectRetentionOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutObjectRetentionInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRetentionManager_PutObjectRetention_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutObjectRetention'
type MockRetentionManager_PutObjectRetention_Call struct {
	*mock.Call
}

// PutObjectRetention is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutObjectRetentionInput
//   - optFns ...func(*s3.Options)
func (_e *MockRetentionManager_Expecter) PutObjectRetention(ctx interface{}, params interface{}, optFns ...interface{}) *MockRetentionManager_PutObjectRetention_Call {
	return &MockRetentionManager_PutObjectRetention_Call{Call: _e.mock.On("PutObjectRetention",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockRetentionManager_PutObjectRetention_Call) Run(run func(ctx context.Context, params *s3.PutObjectRetentionInput, optFns ...func(*s3.Options))) *MockRetentionManager_PutObjectRetention_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutObjectRetentionInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutObjectRetentionInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockRetentionManager_PutObjectRetention_Call) Return(putObjectRetentionOutput *s3.PutObjectRetentionOutput, err error) *MockRetentionManager_PutObjectRetention_Call {
	_c.Call.Return(putObjectRetentionOutput, err)
	return _c
}

func (_c *MockRetentionManager_PutObjectRetention_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutObjectRetentionInput, optFns ...func(*s3.Options)) (*s3.PutObjectRetentionOutput, error)) *MockRetentionManager_PutObjectRetention_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockRestorer creates a new instance of MockRestorer. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRestorer(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockRestorer {
	mock := &MockRestorer{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockRestorer is an autogenerated mock type for the Restorer type
type MockRestorer struct {
	mock.Mock
}

type MockRestorer_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRestorer) EXPECT() *MockRestorer_Expecter {
	return &MockRestorer_Expecter{mock: &_m.Mock}
}

// RestoreObject provides a mock function for the type MockRestorer
func (_mock *MockRestorer) RestoreObject(ctx context.Context, params *s3.RestoreObjectInput, optFns ...func(*s3.Options)) (*s3.RestoreObjectOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for RestoreObject")
	}

	var r0 *s3.RestoreObjectOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.RestoreObjectInput, ...func(*s3.Options)) (*s3.RestoreObjectOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.RestoreObjectInput, ...func(*s3.Options)) *s3.RestoreObjectOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.RestoreObjectOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.RestoreObjectInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRestorer_RestoreObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestoreObject'
type MockRestorer_RestoreObject_Call struct {
	*mock.Call
}

// RestoreObject is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.RestoreObjectInput
//   - optFns ...func(*s3.Options)
func (_e *MockRestorer_Expecter) RestoreObject(ctx interface{}, params interface{}, optFns ...interface{}) *MockRestorer_RestoreObject_Call {
	return &MockRestorer_RestoreObject_Call{Call: _e.mock.On("RestoreObject",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockRestorer_RestoreObject_Call) Run(run func(ctx context.Context, params *s3.RestoreObjectInput, optFns ...func(*s3.Options))) *MockRestorer_RestoreObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.RestoreObjectInput
		if args[1] != nil {
			arg1 = args[1].(*s3.RestoreObjectInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockRestorer_RestoreObject_Call) Return(restoreObjectOutput *s3.RestoreObjectOutput, err error) *MockRestorer_RestoreObject_Call {
	_c.Call.Return(restoreObjectOutput, err)
	return _c
}

func (_c *MockRestorer_RestoreObject_Call) RunAndReturn(run func(ctx context.Context, params *s3.RestoreObjectInput, optFns ...func(*s3.Options)) (*s3.RestoreObjectOutput, error)) *MockRestorer_RestoreObject_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSelector creates a new instance of MockSelector. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSelector(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSelector {
	mock := &MockSelector{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSelector is an autogenerated mock type for the Selector type
type MockSelector struct {
	mock.Mock
}

type MockSelector_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSelector) EXPECT() *MockSelector_Expecter {
	return &MockSelector_Expecter{mock: &_m.Mock}
}

// SelectObjectContent provides a mock function for the type MockSelector
func (_mock *MockSelector) SelectObjectContent(ctx context.Context, params *s3.SelectObjectContentInput, optFns ...func(*s3.Options)) (*s3.SelectObjectContentOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for SelectObjectContent")
	}

	var r0 *s3.SelectObjectContentOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.SelectObjectContentInput, ...func(*s3.Options)) (*s3.SelectObjectContentOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.SelectObjectContentInput, ...func(*s3.Options)) *s3.SelectObjectContentOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.SelectObjectContentOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.SelectObjectContentInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSelector_SelectObjectContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelectObjectContent'
type MockSelector_SelectObjectContent_Call struct {
	*mock.Call
}

// SelectObjectContent is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.SelectObjectContentInput
//   - optFns ...func(*s3.Options)
func (_e *MockSelector_Expecter) SelectObjectContent(ctx interface{}, params interface{}, optFns ...interface{}) *MockSelector_SelectObjectContent_Call {
	return &MockSelector_SelectObjectContent_Call{Call: _e.mock.On("SelectObjectContent",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockSelector_SelectObjectContent_Call) Run(run func(ctx context.Context, params *s3.SelectObjectContentInput, optFns ...func(*s3.Options))) *MockSelector_SelectObjectContent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.SelectObjectContentInput
		if args[1] != nil {
			arg1 = args[1].(*s3.SelectObjectContentInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockSelector_SelectObjectContent_Call) Return(selectObjectContentOutput *s3.SelectObjectContentOutput, err error) *MockSelector_SelectObjectContent_Call {
	_c.Call.Return(selectObjectContentOutput, err)
	return _c
}

func (_c *MockSelector_SelectObjectContent_Call) RunAndReturn(run func(ctx context.Context, params *s3.SelectObjectContentInput, optFns ...func(*s3.Options)) (*s3.SelectObjectContentOutput, error)) *MockSelector_SelectObjectContent_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockObjectAttributesGetter creates a new instance of MockObjectAttributesGetter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockObjectAttributesGetter(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockObjectAttributesGetter {
	mock := &MockObjectAttributesGetter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockObjectAttributesGetter is an autogenerated mock type for the ObjectAttributesGetter type
type MockObjectAttributesGetter struct {
	mock.Mock
}

type MockObjectAttributesGetter_Expecter struct {
	mock *mock.Mock
}

func (_m *MockObjectAttributesGetter) EXPECT() *MockObjectAttributesGetter_Expecter {
	return &MockObjectAttributesGetter_Expecter{mock: &_m.Mock}
}

// GetObjectAttributes provides a mock function for the type MockObjectAttributesGetter
func (_mock *MockObjectAttributesGetter) GetObjectAttributes(ctx context.Context, params *s3.GetObjectAttributesInput, optFns ...func(*s3.Options)) (*s3.GetObjectAttributesOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetObjectAttributes")
	}

	var r0 *s3.GetObjectAttributesOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectAttributesInput, ...func(*s3.Options)) (*s3.GetObjectAttributesOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectAttributesInput, ...func(*s3.Options)) *s3.GetObjectAttributesOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetObjectAttributesOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetObjectAttributesInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockObjectAttributesGetter_GetObjectAttributes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetObjectAttributes'
type MockObjectAttributesGetter_GetObjectAttributes_Call struct {
	*mock.Call
}

// GetObjectAttributes is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetObjectAttributesInput
//   - optFns ...func(*s3.Options)
func (_e *MockObjectAttributesGetter_Expecter) GetObjectAttributes(ctx interface{}, params interface{}, optFns ...interface{}) *MockObjectAttributesGetter_GetObjectAttributes_Call {
	return &MockObjectAttributesGetter_GetObjectAttributes_Call{Call: _e.mock.On("GetObjectAttributes",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockObjectAttributesGetter_GetObjectAttributes_Call) Run(run func(ctx context.Context, params *s3.GetObjectAttributesInput, optFns ...func(*s3.Options))) *MockObjectAttributesGetter_GetObjectAttributes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetObjectAttributesInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetObjectAttributesInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockObjectAttributesGetter_GetObjectAttributes_Call) Return(getObjectAttributesOutput *s3.GetObjectAttributesOutput, err error) *MockObjectAttributesGetter_GetObjectAttributes_Call {
	_c.Call.Return(getObjectAttributesOutput, err)
	return _c
}

func (_c *MockObjectAttributesGetter_GetObjectAttributes_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetObjectAttributesInput, optFns ...func(*s3.Options)) (*s3.GetObjectAttributesOutput, error)) *MockObjectAttributesGetter_GetObjectAttributes_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockTorrentGetter creates a new instance of MockTorrentGetter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTorrentGetter(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTorrentGetter {
	mock := &MockTorrentGetter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockTorrentGetter is an autogenerated mock type for the TorrentGetter type
type MockTorrentGetter struct {
	mock.Mock
}

type MockTorrentGetter_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTorrentGetter) EXPECT() *MockTorrentGetter_Expecter {
	return &MockTorrentGetter_Expecter{mock: &_m.Mock}
}

// GetObjectTorrent provides a mock function for the type MockTorrentGetter
func (_mock *MockTorrentGetter) GetObjectTorrent(ctx context.Context, params *s3.GetObjectTorrentInput, optFns ...func(*s3.Options)) (*s3.GetObjectTorrentOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetObjectTorrent")
	}

	var r0 *s3.GetObjectTorrentOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectTorrentInput, ...func(*s3.Options)) (*s3.GetObjectTorrentOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectTorrentInput, ...func(*s3.Options)) *s3.GetObjectTorrentOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetObjectTorrentOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetObjectTorrentInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTorrentGetter_GetObjectTorrent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetObjectTorrent'
type MockTorrentGetter_GetObjectTorrent_Call struct {
	*mock.Call
}

// GetObjectTorrent is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetObjectTorrentInput
//   - optFns ...func(*s3.Options)
func (_e *MockTorrentGetter_Expecter) GetObjectTorrent(ctx interface{}, params interface{}, optFns ...interface{}) *MockTorrentGetter_GetObjectTorrent_Call {
	return &MockTorrentGetter_GetObjectTorrent_Call{Call: _e.mock.On("GetObjectTorrent",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockTorrentGetter_GetObjectTorrent_Call) Run(run func(ctx context.Context, params *s3.GetObjectTorrentInput, optFns ...func(*s3.Options))) *MockTorrentGetter_GetObjectTorrent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetObjectTorrentInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetObjectTorrentInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockTorrentGetter_GetObjectTorrent_Call) Return(getObjectTorrentOutput *s3.GetObjectTorrentOutput, err error) *MockTorrentGetter_GetObjectTorrent_Call {
	_c.Call.Return(getObjectTorrentOutput, err)
	return _c
}

func (_c *MockTorrentGetter_GetObjectTorrent_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetObjectTorrentInput, optFns ...func(*s3.Options)) (*s3.GetObjectTorrentOutput, error)) *MockTorrentGetter_GetObjectTorrent_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockObjectLambdaWriter creates a new instance of MockObjectLambdaWriter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockObjectLambdaWriter(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockObjectLambdaWriter {
	mock := &MockObjectLambdaWriter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockObjectLambdaWriter is an autogenerated mock type for the ObjectLambdaWriter type
type MockObjectLambdaWriter struct {
	mock.Mock
}

type MockObjectLambdaWriter_Expecter struct {
	mock *mock.Mock
}

func (_m *MockObjectLambdaWriter) EXPECT() *MockObjectLambdaWriter_Expecter {
	return &MockObjectLambdaWriter_Expecter{mock: &_m.Mock}
}

// WriteGetObjectResponse provides a mock function for the type MockObjectLambdaWriter
func (_mock *MockObjectLambdaWriter) WriteGetObjectResponse(ctx context.Context, params *s3.WriteGetObjectResponseInput, optFns ...func(*s3.Options)) (*s3.WriteGetObjectResponseOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for WriteGetObjectResponse")
	}

	var r0 *s3.WriteGetObjectResponseOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.WriteGetObjectResponseInput, ...func(*s3.Options)) (*s3.WriteGetObjectResponseOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.WriteGetObjectResponseInput, ...func(*s3.Options)) *s3.WriteGetObjectResponseOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.WriteGetObjectResponseOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.WriteGetObjectResponseInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockObjectLambdaWriter_WriteGetObjectResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteGetObjectResponse'
type MockObjectLambdaWriter_WriteGetObjectResponse_Call struct {
	*mock.Call
}

// WriteGetObjectResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.WriteGetObjectResponseInput
//   - optFns ...func(*s3.Options)
func (_e *MockObjectLambdaWriter_Expecter) WriteGetObjectResponse(ctx interface{}, params interface{}, optFns ...interface{}) *MockObjectLambdaWriter_WriteGetObjectResponse_Call {
	return &MockObjectLambdaWriter_WriteGetObjectResponse_Call{Call: _e.mock.On("WriteGetObjectResponse",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockObjectLambdaWriter_WriteGetObjectResponse_Call) Run(run func(ctx context.Context, params *s3.WriteGetObjectResponseInput, optFns ...func(*s3.Options))) *MockObjectLambdaWriter_WriteGetObjectResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.WriteGetObjectResponseInput
		if args[1] != nil {
			arg1 = args[1].(*s3.WriteGetObjectResponseInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockObjectLambdaWriter_WriteGetObjectResponse_Call) Return(writeGetObjectResponseOutput *s3.WriteGetObjectResponseOutput, err error) *MockObjectLambdaWriter_WriteGetObjectResponse_Call {
	_c.Call.Return(writeGetObjectResponseOutput, err)
	return _c
}

func (_c *MockObjectLambdaWriter_WriteGetObjectResponse_Call) RunAndReturn(run func(ctx context.Context, params *s3.WriteGetObjectResponseInput, optFns ...func(*s3.Options)) (*s3.WriteGetObjectResponseOutput, error)) *MockObjectLambdaWriter_WriteGetObjectResponse_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockBucketManager creates a new instance of MockBucketManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockBucketManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockBucketManager {
	mock := &MockBucketManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockBucketManager is an autogenerated mock type for the BucketManager type
type MockBucketManager struct {
	mock.Mock
}

type MockBucketManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockBucketManager) EXPECT() *MockBucketManager_Expecter {
	return &MockBucketManager_Expecter{mock: &_m.Mock}
}

// CreateBucket provides a mock function for the type MockBucketManager
func (_mock *MockBucketManager) CreateBucket(ctx context.Context, params *s3.CreateBucketInput, optFns ...func(*s3.Options)) (*s3.CreateBucketOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for CreateBucket")
	}

	var r0 *s3.CreateBucketOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.CreateBucketInput, ...func(*s3.Options)) (*s3.CreateBucketOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.CreateBucketInput, ...func(*s3.Options)) *s3.CreateBucketOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.CreateBucketOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.CreateBucketInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBucketManager_CreateBucket_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBucket'
type MockBucketManager_CreateBucket_Call struct {
	*mock.Call
}

// CreateBucket is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.CreateBucketInput
//   - optFns ...func(*s3.Options)
func (_e *MockBucketManager_Expecter) CreateBucket(ctx interface{}, params interface{}, optFns ...interface{}) *MockBucketManager_CreateBucket_Call {
	return &MockBucketManager_CreateBucket_Call{Call: _e.mock.On("CreateBucket",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockBucketManager_CreateBucket_Call) Run(run func(ctx context.Context, params *s3.CreateBucketInput, optFns ...func(*s3.Options))) *MockBucketManager_CreateBucket_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.CreateBucketInput
		if args[1] != nil {
			arg1 = args[1].(*s3.CreateBucketInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockBucketManager_CreateBucket_Call) Return(createBucketOutput *s3.CreateBucketOutput, err error) *MockBucketManager_CreateBucket_Call {
	_c.Call.Return(createBucketOutput, err)
	return _c
}

func (_c *MockBucketManager_CreateBucket_Call) RunAndReturn(run func(ctx context.Context, params *s3.CreateBucketInput, optFns ...func(*s3.Options)) (*s3.CreateBucketOutput, error)) *MockBucketManager_CreateBucket_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBucket provides a mock function for the type MockBucketManager
func (_mock *MockBucketManager) DeleteBucket(ctx context.Context, params *s3.DeleteBucketInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucket")
	}

	var r0 *s3.DeleteBucketOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketInput, ...func(*s3.Options)) (*s3.DeleteBucketOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketInput, ...func(*s3.Options)) *s3.DeleteBucketOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBucketManager_DeleteBucket_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucket'
type MockBucketManager_DeleteBucket_Call struct {
	*mock.Call
}

// DeleteBucket is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketInput
//   - optFns ...func(*s3.Options)
func (_e *MockBucketManager_Expecter) DeleteBucket(ctx interface{}, params interface{}, optFns ...interface{}) *MockBucketManager_DeleteBucket_Call {
	return &MockBucketManager_DeleteBucket_Call{Call: _e.mock.On("DeleteBucket",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockBucketManager_DeleteBucket_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketInput, optFns ...func(*s3.Options))) *MockBucketManager_DeleteBucket_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockBucketManager_DeleteBucket_Call) Return(deleteBucketOutput *s3.DeleteBucketOutput, err error) *MockBucketManager_DeleteBucket_Call {
	_c.Call.Return(deleteBucketOutput, err)
	return _c
}

func (_c *MockBucketManager_DeleteBucket_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketOutput, error)) *MockBucketManager_DeleteBucket_Call {
	_c.Call.Return(run)
	return _c
}

// HeadBucket provides a mock function for the type MockBucketManager
func (_mock *MockBucketManager) HeadBucket(ctx context.Context, params *s3.HeadBucketInput, optFns ...func(*s3.Options)) (*s3.HeadBucketOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for HeadBucket")
	}

	var r0 *s3.HeadBucketOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.HeadBucketInput, ...func(*s3.Options)) (*s3.HeadBucketOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.HeadBucketInput, ...func(*s3.Options)) *s3.HeadBucketOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.HeadBucketOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.HeadBucketInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBucketManager_HeadBucket_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HeadBucket'
type MockBucketManager_HeadBucket_Call struct {
	*mock.Call
}

// HeadBucket is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.HeadBucketInput
//   - optFns ...func(*s3.Options)
func (_e *MockBucketManager_Expecter) HeadBucket(ctx interface{}, params interface{}, optFns ...interface{}) *MockBucketManager_HeadBucket_Call {
	return &MockBucketManager_HeadBucket_Call{Call: _e.mock.On("HeadBucket",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockBucketManager_HeadBucket_Call) Run(run func(ctx context.Context, params *s3.HeadBucketInput, optFns ...func(*s3.Options))) *MockBucketManager_HeadBucket_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.HeadBucketInput
		if args[1] != nil {
			arg1 = args[1].(*s3.HeadBucketInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockBucketManager_HeadBucket_Call) Return(headBucketOutput *s3.HeadBucketOutput, err error) *MockBucketManager_HeadBucket_Call {
	_c.Call.Return(headBucketOutput, err)
	return _c
}

func (_c *MockBucketManager_HeadBucket_Call) RunAndReturn(run func(ctx context.Context, params *s3.HeadBucketInput, optFns ...func(*s3.Options)) (*s3.HeadBucketOutput, error)) *MockBucketManager_HeadBucket_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockObjectManager creates a new instance of MockObjectManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockObjectManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockObjectManager {
	mock := &MockObjectManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockObjectManager is an autogenerated mock type for the ObjectManager type
type MockObjectManager struct {
	mock.Mock
}

type MockObjectManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockObjectManager) EXPECT() *MockObjectManager_Expecter {
	return &MockObjectManager_Expecter{mock: &_m.Mock}
}

// CopyObject provides a mock function for the type MockObjectManager
func (_mock *MockObjectManager) CopyObject(ctx context.Context, params *s3.CopyObjectInput, optFns ...func(*s3.Options)) (*s3.CopyObjectOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for CopyObject")
	}

	var r0 *s3.CopyObjectOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.CopyObjectInput, ...func(*s3.Options)) (*s3.CopyObjectOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.CopyObjectInput, ...func(*s3.Options)) *s3.CopyObjectOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.CopyObjectOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.CopyObjectInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockObjectManager_CopyObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyObject'
type MockObjectManager_CopyObject_Call struct {
	*mock.Call
}

// CopyObject is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.CopyObjectInput
//   - optFns ...func(*s3.Options)
func (_e *MockObjectManager_Expecter) CopyObject(ctx interface{}, params interface{}, optFns ...interface{}) *MockObjectManager_CopyObject_Call {
	return &MockObjectManager_CopyObject_Call{Call: _e.mock.On("CopyObject",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockObjectManager_CopyObject_Call) Run(run func(ctx context.Context, params *s3.CopyObjectInput, optFns ...func(*s3.Options))) *MockObjectManager_CopyObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.CopyObjectInput
		if args[1] != nil {
			arg1 = args[1].(*s3.CopyObjectInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockObjectManager_CopyObject_Call) Return(copyObjectOutput *s3.CopyObjectOutput, err error) *MockObjectManager_CopyObject_Call {
	_c.Call.Return(copyObjectOutput, err)
	return _c
}

func (_c *MockObjectManager_CopyObject_Call) RunAndReturn(run func(ctx context.Context, params *s3.CopyObjectInput, optFns ...func(*s3.Options)) (*s3.CopyObjectOutput, error)) *MockObjectManager_CopyObject_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteObject provides a mock function for the type MockObjectManager
func (_mock *MockObjectManager) DeleteObject(ctx context.Context, params *s3.DeleteObjectInput, optFns ...func(*s3.Options)) (*s3.DeleteObjectOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteObject")
	}

	var r0 *s3.DeleteObjectOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteObjectInput, ...func(*s3.Options)) (*s3.DeleteObjectOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteObjectInput, ...func(*s3.Options)) *s3.DeleteObjectOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteObjectOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteObjectInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockObjectManager_DeleteObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteObject'
type MockObjectManager_DeleteObject_Call struct {
	*mock.Call
}

// DeleteObject is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteObjectInput
//   - optFns ...func(*s3.Options)
func (_e *MockObjectManager_Expecter) DeleteObject(ctx interface{}, params interface{}, optFns ...interface{}) *MockObjectManager_DeleteObject_Call {
	return &MockObjectManager_DeleteObject_Call{Call: _e.mock.On("DeleteObject",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockObjectManager_DeleteObject_Call) Run(run func(ctx context.Context, params *s3.DeleteObjectInput, optFns ...func(*s3.Options))) *MockObjectManager_DeleteObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteObjectInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteObjectInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockObjectManager_DeleteObject_Call) Return(deleteObjectOutput *s3.DeleteObjectOutput, err error) *MockObjectManager_DeleteObject_Call {
	_c.Call.Return(deleteObjectOutput, err)
	return _c
}

func (_c *MockObjectManager_DeleteObject_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteObjectInput, optFns ...func(*s3.Options)) (*s3.DeleteObjectOutput, error)) *MockObjectManager_DeleteObject_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteObjects provides a mock function for the type MockObjectManager
func (_mock *MockObjectManager) DeleteObjects(ctx context.Context, params *s3.DeleteObjectsInput, optFns ...func(*s3.Options)) (*s3.DeleteObjectsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteObjects")
	}

	var r0 *s3.DeleteObjectsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteObjectsInput, ...func(*s3.Options)) (*s3.DeleteObjectsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteObjectsInput, ...func(*s3.Options)) *s3.DeleteObjectsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteObjectsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteObjectsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockObjectManager_DeleteObjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteObjects'
type MockObjectManager_DeleteObjects_Call struct {
	*mock.Call
}

// DeleteObjects is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteObjectsInput
//   - optFns ...func(*s3.Options)
func (_e *MockObjectManager_Expecter) DeleteObjects(ctx interface{}, params interface{}, optFns ...interface{}) *MockObjectManager_DeleteObjects_Call {
	return &MockObjectManager_DeleteObjects_Call{Call: _e.mock.On("DeleteObjects",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockObjectManager_DeleteObjects_Call) Run(run func(ctx context.Context, params *s3.DeleteObjectsInput, optFns ...func(*s3.Options))) *MockObjectManager_DeleteObjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteObjectsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteObjectsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockObjectManager_DeleteObjects_Call) Return(deleteObjectsOutput *s3.DeleteObjectsOutput, err error) *MockObjectManager_DeleteObjects_Call {
	_c.Call.Return(deleteObjectsOutput, err)
	return _c
}

func (_c *MockObjectManager_DeleteObjects_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteObjectsInput, optFns ...func(*s3.Options)) (*s3.DeleteObjectsOutput, error)) *MockObjectManager_DeleteObjects_Call {
	_c.Call.Return(run)
	return _c
}

// GetObject provides a mock function for the type MockObjectManager
func (_mock *MockObjectManager) GetObject(ctx context.Context, params *s3.GetObjectInput, optFns ...func(*s3.Options)) (*s3.GetObjectOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetObject")
	}

	var r0 *s3.GetObjectOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectInput, ...func(*s3.Options)) (*s3.GetObjectOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectInput, ...func(*s3.Options)) *s3.GetObjectOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetObjectOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetObjectInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockObjectManager_GetObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetObject'
type MockObjectManager_GetObject_Call struct {
	*mock.Call
}

// GetObject is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetObjectInput
//   - optFns ...func(*s3.Options)
func (_e *MockObjectManager_Expecter) GetObject(ctx interface{}, params interface{}, optFns ...interface{}) *MockObjectManager_GetObject_Call {
	return &MockObjectManager_GetObject_Call{Call: _e.mock.On("GetObject",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockObjectManager_GetObject_Call) Run(run func(ctx context.Context, params *s3.GetObjectInput, optFns ...func(*s3.Options))) *MockObjectManager_GetObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetObjectInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetObjectInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockObjectManager_GetObject_Call) Return(getObjectOutput *s3.GetObjectOutput, err error) *MockObjectManager_GetObject_Call {
	_c.Call.Return(getObjectOutput, err)
	return _c
}

func (_c *MockObjectManager_GetObject_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetObjectInput, optFns ...func(*s3.Options)) (*s3.GetObjectOutput, error)) *MockObjectManager_GetObject_Call {
	_c.Call.Return(run)
	return _c
}

// HeadObject provides a mock function for the type MockObjectManager
func (_mock *MockObjectManager) HeadObject(ctx context.Context, params *s3.HeadObjectInput, optFns ...func(*s3.Options)) (*s3.HeadObjectOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for HeadObject")
	}

	var r0 *s3.HeadObjectOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.HeadObjectInput, ...func(*s3.Options)) (*s3.HeadObjectOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.HeadObjectInput, ...func(*s3.Options)) *s3.HeadObjectOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.HeadObjectOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.HeadObjectInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockObjectManager_HeadObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HeadObject'
type MockObjectManager_HeadObject_Call struct {
	*mock.Call
}

// HeadObject is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.HeadObjectInput
//   - optFns ...func(*s3.Options)
func (_e *MockObjectManager_Expecter) HeadObject(ctx interface{}, params interface{}, optFns ...interface{}) *MockObjectManager_HeadObject_Call {
	return &MockObjectManager_HeadObject_Call{Call: _e.mock.On("HeadObject",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockObjectManager_HeadObject_Call) Run(run func(ctx context.Context, params *s3.HeadObjectInput, optFns ...func(*s3.Options))) *MockObjectManager_HeadObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.HeadObjectInput
		if args[1] != nil {
			arg1 = args[1].(*s3.HeadObjectInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockObjectManager_HeadObject_Call) Return(headObjectOutput *s3.HeadObjectOutput, err error) *MockObjectManager_HeadObject_Call {
	_c.Call.Return(headObjectOutput, err)
	return _c
}

func (_c *MockObjectManager_HeadObject_Call) RunAndReturn(run func(ctx context.Context, params *s3.HeadObjectInput, optFns ...func(*s3.Options)) (*s3.HeadObjectOutput, error)) *MockObjectManager_HeadObject_Call {
	_c.Call.Return(run)
	return _c
}

// PutObject provides a mock function for the type MockObjectManager
func (_mock *MockObjectManager) PutObject(ctx context.Context, params *s3.PutObjectInput, optFns ...func(*s3.Options)) (*s3.PutObjectOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutObject")
	}

	var r0 *s3.PutObjectOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectInput, ...func(*s3.Options)) (*s3.PutObjectOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectInput, ...func(*s3.Options)) *s3.PutObjectOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutObjectOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutObjectInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockObjectManager_PutObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutObject'
type MockObjectManager_PutObject_Call struct {
	*mock.Call
}

// PutObject is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutObjectInput
//   - optFns ...func(*s3.Options)
func (_e *MockObjectManager_Expecter) PutObject(ctx interface{}, params interface{}, optFns ...interface{}) *MockObjectManager_PutObject_Call {
	return &MockObjectManager_PutObject_Call{Call: _e.mock.On("PutObject",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockObjectManager_PutObject_Call) Run(run func(ctx context.Context, params *s3.PutObjectInput, optFns ...func(*s3.Options))) *MockObjectManager_PutObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutObjectInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutObjectInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockObjectManager_PutObject_Call) Return(putObjectOutput *s3.PutObjectOutput, err error) *MockObjectManager_PutObject_Call {
	_c.Call.Return(putObjectOutput, err)
	return _c
}

func (_c *MockObjectManager_PutObject_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutObjectInput, optFns ...func(*s3.Options)) (*s3.PutObjectOutput, error)) *MockObjectManager_PutObject_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockListingManager creates a new instance of MockListingManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockListingManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockListingManager {
	mock := &MockListingManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockListingManager is an autogenerated mock type for the ListingManager type
type MockListingManager struct {
	mock.Mock
}

type MockListingManager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockListingManager) EXPECT() *MockListingManager_Expecter {
	return &MockListingManager_Expecter{mock: &_m.Mock}
}

// ListBuckets provides a mock function for the type MockListingManager
func (_mock *MockListingManager) ListBuckets(ctx context.Context, params *s3.ListBucketsInput, optFns ...func(*s3.Options)) (*s3.ListBucketsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListBuckets")
	}

	var r0 *s3.ListBucketsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListBucketsInput, ...func(*s3.Options)) (*s3.ListBucketsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListBucketsInput, ...func(*s3.Options)) *s3.ListBucketsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.ListBucketsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.ListBucketsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockListingManager_ListBuckets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBuckets'
type MockListingManager_ListBuckets_Call struct {
	*mock.Call
}

// ListBuckets is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.ListBucketsInput
//   - optFns ...func(*s3.Options)
func (_e *MockListingManager_Expecter) ListBuckets(ctx interface{}, params interface{}, optFns ...interface{}) *MockListingManager_ListBuckets_Call {
	return &MockListingManager_ListBuckets_Call{Call: _e.mock.On("ListBuckets",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockListingManager_ListBuckets_Call) Run(run func(ctx context.Context, params *s3.ListBucketsInput, optFns ...func(*s3.Options))) *MockListingManager_ListBuckets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.ListBucketsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.ListBucketsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockListingManager_ListBuckets_Call) Return(listBucketsOutput *s3.ListBucketsOutput, err error) *MockListingManager_ListBuckets_Call {
	_c.Call.Return(listBucketsOutput, err)
	return _c
}

func (_c *MockListingManager_ListBuckets_Call) RunAndReturn(run func(ctx context.Context, params *s3.ListBucketsInput, optFns ...func(*s3.Options)) (*s3.ListBucketsOutput, error)) *MockListingManager_ListBuckets_Call {
	_c.Call.Return(run)
	return _c
}

// ListObjectsV2 provides a mock function for the type MockListingManager
func (_mock *MockListingManager) ListObjectsV2(ctx context.Context, params *s3.ListObjectsV2Input, optFns ...func(*s3.Options)) (*s3.ListObjectsV2Output, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListObjectsV2")
	}

	var r0 *s3.ListObjectsV2Output
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListObjectsV2Input, ...func(*s3.Options)) (*s3.ListObjectsV2Output, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListObjectsV2Input, ...func(*s3.Options)) *s3.ListObjectsV2Output); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.ListObjectsV2Output)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.ListObjectsV2Input, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockListingManager_ListObjectsV2_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListObjectsV2'
type MockListingManager_ListObjectsV2_Call struct {
	*mock.Call
}

// ListObjectsV2 is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.ListObjectsV2Input
//   - optFns ...func(*s3.Options)
func (_e *MockListingManager_Expecter) ListObjectsV2(ctx interface{}, params interface{}, optFns ...interface{}) *MockListingManager_ListObjectsV2_Call {
	return &MockListingManager_ListObjectsV2_Call{Call: _e.mock.On("ListObjectsV2",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockListingManager_ListObjectsV2_Call) Run(run func(ctx context.Context, params *s3.ListObjectsV2Input, optFns ...func(*s3.Options))) *MockListingManager_ListObjectsV2_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.ListObjectsV2Input
		if args[1] != nil {
			arg1 = args[1].(*s3.ListObjectsV2Input)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockListingManager_ListObjectsV2_Call) Return(listObjectsV2Output *s3.ListObjectsV2Output, err error) *MockListingManager_ListObjectsV2_Call {
	_c.Call.Return(listObjectsV2Output, err)
	return _c
}

func (_c *MockListingManager_ListObjectsV2_Call) RunAndReturn(run func(ctx context.Context, params *s3.ListObjectsV2Input, optFns ...func(*s3.Options)) (*s3.ListObjectsV2Output, error)) *MockListingManager_ListObjectsV2_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockS3Manager creates a new instance of MockS3Manager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockS3Manager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockS3Manager {
	mock := &MockS3Manager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockS3Manager is an autogenerated mock type for the S3Manager type
type MockS3Manager struct {
	mock.Mock
}

type MockS3Manager_Expecter struct {
	mock *mock.Mock
}

func (_m *MockS3Manager) EXPECT() *MockS3Manager_Expecter {
	return &MockS3Manager_Expecter{mock: &_m.Mock}
}

// AbortMultipartUpload provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) AbortMultipartUpload(ctx context.Context, params *s3.AbortMultipartUploadInput, optFns ...func(*s3.Options)) (*s3.AbortMultipartUploadOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for AbortMultipartUpload")
	}

	var r0 *s3.AbortMultipartUploadOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.AbortMultipartUploadInput, ...func(*s3.Options)) (*s3.AbortMultipartUploadOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.AbortMultipartUploadInput, ...func(*s3.Options)) *s3.AbortMultipartUploadOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.AbortMultipartUploadOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.AbortMultipartUploadInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_AbortMultipartUpload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AbortMultipartUpload'
type MockS3Manager_AbortMultipartUpload_Call struct {
	*mock.Call
}

// AbortMultipartUpload is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.AbortMultipartUploadInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) AbortMultipartUpload(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_AbortMultipartUpload_Call {
	return &MockS3Manager_AbortMultipartUpload_Call{Call: _e.mock.On("AbortMultipartUpload",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_AbortMultipartUpload_Call) Run(run func(ctx context.Context, params *s3.AbortMultipartUploadInput, optFns ...func(*s3.Options))) *MockS3Manager_AbortMultipartUpload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.AbortMultipartUploadInput
		if args[1] != nil {
			arg1 = args[1].(*s3.AbortMultipartUploadInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_AbortMultipartUpload_Call) Return(abortMultipartUploadOutput *s3.AbortMultipartUploadOutput, err error) *MockS3Manager_AbortMultipartUpload_Call {
	_c.Call.Return(abortMultipartUploadOutput, err)
	return _c
}

func (_c *MockS3Manager_AbortMultipartUpload_Call) RunAndReturn(run func(ctx context.Context, params *s3.AbortMultipartUploadInput, optFns ...func(*s3.Options)) (*s3.AbortMultipartUploadOutput, error)) *MockS3Manager_AbortMultipartUpload_Call {
	_c.Call.Return(run)
	return _c
}

// CompleteMultipartUpload provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) CompleteMultipartUpload(ctx context.Context, params *s3.CompleteMultipartUploadInput, optFns ...func(*s3.Options)) (*s3.CompleteMultipartUploadOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for CompleteMultipartUpload")
	}

	var r0 *s3.CompleteMultipartUploadOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.CompleteMultipartUploadInput, ...func(*s3.Options)) (*s3.CompleteMultipartUploadOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.CompleteMultipartUploadInput, ...func(*s3.Options)) *s3.CompleteMultipartUploadOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.CompleteMultipartUploadOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.CompleteMultipartUploadInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_CompleteMultipartUpload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompleteMultipartUpload'
type MockS3Manager_CompleteMultipartUpload_Call struct {
	*mock.Call
}

// CompleteMultipartUpload is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.CompleteMultipartUploadInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) CompleteMultipartUpload(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_CompleteMultipartUpload_Call {
	return &MockS3Manager_CompleteMultipartUpload_Call{Call: _e.mock.On("CompleteMultipartUpload",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_CompleteMultipartUpload_Call) Run(run func(ctx context.Context, params *s3.CompleteMultipartUploadInput, optFns ...func(*s3.Options))) *MockS3Manager_CompleteMultipartUpload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.CompleteMultipartUploadInput
		if args[1] != nil {
			arg1 = args[1].(*s3.CompleteMultipartUploadInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_CompleteMultipartUpload_Call) Return(completeMultipartUploadOutput *s3.CompleteMultipartUploadOutput, err error) *MockS3Manager_CompleteMultipartUpload_Call {
	_c.Call.Return(completeMultipartUploadOutput, err)
	return _c
}

func (_c *MockS3Manager_CompleteMultipartUpload_Call) RunAndReturn(run func(ctx context.Context, params *s3.CompleteMultipartUploadInput, optFns ...func(*s3.Options)) (*s3.CompleteMultipartUploadOutput, error)) *MockS3Manager_CompleteMultipartUpload_Call {
	_c.Call.Return(run)
	return _c
}

// CopyObject provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) CopyObject(ctx context.Context, params *s3.CopyObjectInput, optFns ...func(*s3.Options)) (*s3.CopyObjectOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for CopyObject")
	}

	var r0 *s3.CopyObjectOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.CopyObjectInput, ...func(*s3.Options)) (*s3.CopyObjectOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.CopyObjectInput, ...func(*s3.Options)) *s3.CopyObjectOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.CopyObjectOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.CopyObjectInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_CopyObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyObject'
type MockS3Manager_CopyObject_Call struct {
	*mock.Call
}

// CopyObject is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.CopyObjectInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) CopyObject(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_CopyObject_Call {
	return &MockS3Manager_CopyObject_Call{Call: _e.mock.On("CopyObject",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_CopyObject_Call) Run(run func(ctx context.Context, params *s3.CopyObjectInput, optFns ...func(*s3.Options))) *MockS3Manager_CopyObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.CopyObjectInput
		if args[1] != nil {
			arg1 = args[1].(*s3.CopyObjectInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_CopyObject_Call) Return(copyObjectOutput *s3.CopyObjectOutput, err error) *MockS3Manager_CopyObject_Call {
	_c.Call.Return(copyObjectOutput, err)
	return _c
}

func (_c *MockS3Manager_CopyObject_Call) RunAndReturn(run func(ctx context.Context, params *s3.CopyObjectInput, optFns ...func(*s3.Options)) (*s3.CopyObjectOutput, error)) *MockS3Manager_CopyObject_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBucket provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) CreateBucket(ctx context.Context, params *s3.CreateBucketInput, optFns ...func(*s3.Options)) (*s3.CreateBucketOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for CreateBucket")
	}

	var r0 *s3.CreateBucketOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.CreateBucketInput, ...func(*s3.Options)) (*s3.CreateBucketOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.CreateBucketInput, ...func(*s3.Options)) *s3.CreateBucketOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.CreateBucketOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.CreateBucketInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_CreateBucket_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBucket'
type MockS3Manager_CreateBucket_Call struct {
	*mock.Call
}

// CreateBucket is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.CreateBucketInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) CreateBucket(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_CreateBucket_Call {
	return &MockS3Manager_CreateBucket_Call{Call: _e.mock.On("CreateBucket",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_CreateBucket_Call) Run(run func(ctx context.Context, params *s3.CreateBucketInput, optFns ...func(*s3.Options))) *MockS3Manager_CreateBucket_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.CreateBucketInput
		if args[1] != nil {
			arg1 = args[1].(*s3.CreateBucketInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_CreateBucket_Call) Return(createBucketOutput *s3.CreateBucketOutput, err error) *MockS3Manager_CreateBucket_Call {
	_c.Call.Return(createBucketOutput, err)
	return _c
}

func (_c *MockS3Manager_CreateBucket_Call) RunAndReturn(run func(ctx context.Context, params *s3.CreateBucketInput, optFns ...func(*s3.Options)) (*s3.CreateBucketOutput, error)) *MockS3Manager_CreateBucket_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMultipartUpload provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) CreateMultipartUpload(ctx context.Context, params *s3.CreateMultipartUploadInput, optFns ...func(*s3.Options)) (*s3.CreateMultipartUploadOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for CreateMultipartUpload")
	}

	var r0 *s3.CreateMultipartUploadOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.CreateMultipartUploadInput, ...func(*s3.Options)) (*s3.CreateMultipartUploadOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.CreateMultipartUploadInput, ...func(*s3.Options)) *s3.CreateMultipartUploadOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.CreateMultipartUploadOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.CreateMultipartUploadInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_CreateMultipartUpload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMultipartUpload'
type MockS3Manager_CreateMultipartUpload_Call struct {
	*mock.Call
}

// CreateMultipartUpload is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.CreateMultipartUploadInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) CreateMultipartUpload(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_CreateMultipartUpload_Call {
	return &MockS3Manager_CreateMultipartUpload_Call{Call: _e.mock.On("CreateMultipartUpload",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_CreateMultipartUpload_Call) Run(run func(ctx context.Context, params *s3.CreateMultipartUploadInput, optFns ...func(*s3.Options))) *MockS3Manager_CreateMultipartUpload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.CreateMultipartUploadInput
		if args[1] != nil {
			arg1 = args[1].(*s3.CreateMultipartUploadInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_CreateMultipartUpload_Call) Return(createMultipartUploadOutput *s3.CreateMultipartUploadOutput, err error) *MockS3Manager_CreateMultipartUpload_Call {
	_c.Call.Return(createMultipartUploadOutput, err)
	return _c
}

func (_c *MockS3Manager_CreateMultipartUpload_Call) RunAndReturn(run func(ctx context.Context, params *s3.CreateMultipartUploadInput, optFns ...func(*s3.Options)) (*s3.CreateMultipartUploadOutput, error)) *MockS3Manager_CreateMultipartUpload_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBucket provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) DeleteBucket(ctx context.Context, params *s3.DeleteBucketInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucket")
	}

	var r0 *s3.DeleteBucketOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketInput, ...func(*s3.Options)) (*s3.DeleteBucketOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketInput, ...func(*s3.Options)) *s3.DeleteBucketOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_DeleteBucket_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucket'
type MockS3Manager_DeleteBucket_Call struct {
	*mock.Call
}

// DeleteBucket is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) DeleteBucket(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_DeleteBucket_Call {
	return &MockS3Manager_DeleteBucket_Call{Call: _e.mock.On("DeleteBucket",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_DeleteBucket_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketInput, optFns ...func(*s3.Options))) *MockS3Manager_DeleteBucket_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_DeleteBucket_Call) Return(deleteBucketOutput *s3.DeleteBucketOutput, err error) *MockS3Manager_DeleteBucket_Call {
	_c.Call.Return(deleteBucketOutput, err)
	return _c
}

func (_c *MockS3Manager_DeleteBucket_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketOutput, error)) *MockS3Manager_DeleteBucket_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBucketAnalyticsConfiguration provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) DeleteBucketAnalyticsConfiguration(ctx context.Context, params *s3.DeleteBucketAnalyticsConfigurationInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketAnalyticsConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketAnalyticsConfiguration")
	}

	var r0 *s3.DeleteBucketAnalyticsConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketAnalyticsConfigurationInput, ...func(*s3.Options)) (*s3.DeleteBucketAnalyticsConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketAnalyticsConfigurationInput, ...func(*s3.Options)) *s3.DeleteBucketAnalyticsConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketAnalyticsConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketAnalyticsConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_DeleteBucketAnalyticsConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketAnalyticsConfiguration'
type MockS3Manager_DeleteBucketAnalyticsConfiguration_Call struct {
	*mock.Call
}

// DeleteBucketAnalyticsConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketAnalyticsConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) DeleteBucketAnalyticsConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_DeleteBucketAnalyticsConfiguration_Call {
	return &MockS3Manager_DeleteBucketAnalyticsConfiguration_Call{Call: _e.mock.On("DeleteBucketAnalyticsConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_DeleteBucketAnalyticsConfiguration_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketAnalyticsConfigurationInput, optFns ...func(*s3.Options))) *MockS3Manager_DeleteBucketAnalyticsConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketAnalyticsConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketAnalyticsConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_DeleteBucketAnalyticsConfiguration_Call) Return(deleteBucketAnalyticsConfigurationOutput *s3.DeleteBucketAnalyticsConfigurationOutput, err error) *MockS3Manager_DeleteBucketAnalyticsConfiguration_Call {
	_c.Call.Return(deleteBucketAnalyticsConfigurationOutput, err)
	return _c
}

func (_c *MockS3Manager_DeleteBucketAnalyticsConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketAnalyticsConfigurationInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketAnalyticsConfigurationOutput, error)) *MockS3Manager_DeleteBucketAnalyticsConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBucketCors provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) DeleteBucketCors(ctx context.Context, params *s3.DeleteBucketCorsInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketCorsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketCors")
	}

	var r0 *s3.DeleteBucketCorsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketCorsInput, ...func(*s3.Options)) (*s3.DeleteBucketCorsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketCorsInput, ...func(*s3.Options)) *s3.DeleteBucketCorsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketCorsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketCorsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_DeleteBucketCors_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketCors'
type MockS3Manager_DeleteBucketCors_Call struct {
	*mock.Call
}

// DeleteBucketCors is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketCorsInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) DeleteBucketCors(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_DeleteBucketCors_Call {
	return &MockS3Manager_DeleteBucketCors_Call{Call: _e.mock.On("DeleteBucketCors",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_DeleteBucketCors_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketCorsInput, optFns ...func(*s3.Options))) *MockS3Manager_DeleteBucketCors_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketCorsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketCorsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_DeleteBucketCors_Call) Return(deleteBucketCorsOutput *s3.DeleteBucketCorsOutput, err error) *MockS3Manager_DeleteBucketCors_Call {
	_c.Call.Return(deleteBucketCorsOutput, err)
	return _c
}

func (_c *MockS3Manager_DeleteBucketCors_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketCorsInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketCorsOutput, error)) *MockS3Manager_DeleteBucketCors_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBucketEncryption provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) DeleteBucketEncryption(ctx context.Context, params *s3.DeleteBucketEncryptionInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketEncryptionOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketEncryption")
	}

	var r0 *s3.DeleteBucketEncryptionOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketEncryptionInput, ...func(*s3.Options)) (*s3.DeleteBucketEncryptionOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketEncryptionInput, ...func(*s3.Options)) *s3.DeleteBucketEncryptionOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketEncryptionOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketEncryptionInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_DeleteBucketEncryption_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketEncryption'
type MockS3Manager_DeleteBucketEncryption_Call struct {
	*mock.Call
}

// DeleteBucketEncryption is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketEncryptionInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) DeleteBucketEncryption(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_DeleteBucketEncryption_Call {
	return &MockS3Manager_DeleteBucketEncryption_Call{Call: _e.mock.On("DeleteBucketEncryption",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_DeleteBucketEncryption_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketEncryptionInput, optFns ...func(*s3.Options))) *MockS3Manager_DeleteBucketEncryption_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketEncryptionInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketEncryptionInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_DeleteBucketEncryption_Call) Return(deleteBucketEncryptionOutput *s3.DeleteBucketEncryptionOutput, err error) *MockS3Manager_DeleteBucketEncryption_Call {
	_c.Call.Return(deleteBucketEncryptionOutput, err)
	return _c
}

func (_c *MockS3Manager_DeleteBucketEncryption_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketEncryptionInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketEncryptionOutput, error)) *MockS3Manager_DeleteBucketEncryption_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBucketIntelligentTieringConfiguration provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) DeleteBucketIntelligentTieringConfiguration(ctx context.Context, params *s3.DeleteBucketIntelligentTieringConfigurationInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketIntelligentTieringConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketIntelligentTieringConfiguration")
	}

	var r0 *s3.DeleteBucketIntelligentTieringConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketIntelligentTieringConfigurationInput, ...func(*s3.Options)) (*s3.DeleteBucketIntelligentTieringConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketIntelligentTieringConfigurationInput, ...func(*s3.Options)) *s3.DeleteBucketIntelligentTieringConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketIntelligentTieringConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketIntelligentTieringConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_DeleteBucketIntelligentTieringConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketIntelligentTieringConfiguration'
type MockS3Manager_DeleteBucketIntelligentTieringConfiguration_Call struct {
	*mock.Call
}

// DeleteBucketIntelligentTieringConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketIntelligentTieringConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) DeleteBucketIntelligentTieringConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_DeleteBucketIntelligentTieringConfiguration_Call {
	return &MockS3Manager_DeleteBucketIntelligentTieringConfiguration_Call{Call: _e.mock.On("DeleteBucketIntelligentTieringConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_DeleteBucketIntelligentTieringConfiguration_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketIntelligentTieringConfigurationInput, optFns ...func(*s3.Options))) *MockS3Manager_DeleteBucketIntelligentTieringConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketIntelligentTieringConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketIntelligentTieringConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_DeleteBucketIntelligentTieringConfiguration_Call) Return(deleteBucketIntelligentTieringConfigurationOutput *s3.DeleteBucketIntelligentTieringConfigurationOutput, err error) *MockS3Manager_DeleteBucketIntelligentTieringConfiguration_Call {
	_c.Call.Return(deleteBucketIntelligentTieringConfigurationOutput, err)
	return _c
}

func (_c *MockS3Manager_DeleteBucketIntelligentTieringConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketIntelligentTieringConfigurationInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketIntelligentTieringConfigurationOutput, error)) *MockS3Manager_DeleteBucketIntelligentTieringConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBucketInventoryConfiguration provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) DeleteBucketInventoryConfiguration(ctx context.Context, params *s3.DeleteBucketInventoryConfigurationInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketInventoryConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketInventoryConfiguration")
	}

	var r0 *s3.DeleteBucketInventoryConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketInventoryConfigurationInput, ...func(*s3.Options)) (*s3.DeleteBucketInventoryConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketInventoryConfigurationInput, ...func(*s3.Options)) *s3.DeleteBucketInventoryConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketInventoryConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketInventoryConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_DeleteBucketInventoryConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketInventoryConfiguration'
type MockS3Manager_DeleteBucketInventoryConfiguration_Call struct {
	*mock.Call
}

// DeleteBucketInventoryConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketInventoryConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) DeleteBucketInventoryConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_DeleteBucketInventoryConfiguration_Call {
	return &MockS3Manager_DeleteBucketInventoryConfiguration_Call{Call: _e.mock.On("DeleteBucketInventoryConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_DeleteBucketInventoryConfiguration_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketInventoryConfigurationInput, optFns ...func(*s3.Options))) *MockS3Manager_DeleteBucketInventoryConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketInventoryConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketInventoryConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_DeleteBucketInventoryConfiguration_Call) Return(deleteBucketInventoryConfigurationOutput *s3.DeleteBucketInventoryConfigurationOutput, err error) *MockS3Manager_DeleteBucketInventoryConfiguration_Call {
	_c.Call.Return(deleteBucketInventoryConfigurationOutput, err)
	return _c
}

func (_c *MockS3Manager_DeleteBucketInventoryConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketInventoryConfigurationInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketInventoryConfigurationOutput, error)) *MockS3Manager_DeleteBucketInventoryConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBucketLifecycle provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) DeleteBucketLifecycle(ctx context.Context, params *s3.DeleteBucketLifecycleInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketLifecycleOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketLifecycle")
	}

	var r0 *s3.DeleteBucketLifecycleOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketLifecycleInput, ...func(*s3.Options)) (*s3.DeleteBucketLifecycleOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketLifecycleInput, ...func(*s3.Options)) *s3.DeleteBucketLifecycleOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketLifecycleOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketLifecycleInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_DeleteBucketLifecycle_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketLifecycle'
type MockS3Manager_DeleteBucketLifecycle_Call struct {
	*mock.Call
}

// DeleteBucketLifecycle is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketLifecycleInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) DeleteBucketLifecycle(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_DeleteBucketLifecycle_Call {
	return &MockS3Manager_DeleteBucketLifecycle_Call{Call: _e.mock.On("DeleteBucketLifecycle",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_DeleteBucketLifecycle_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketLifecycleInput, optFns ...func(*s3.Options))) *MockS3Manager_DeleteBucketLifecycle_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketLifecycleInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketLifecycleInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_DeleteBucketLifecycle_Call) Return(deleteBucketLifecycleOutput *s3.DeleteBucketLifecycleOutput, err error) *MockS3Manager_DeleteBucketLifecycle_Call {
	_c.Call.Return(deleteBucketLifecycleOutput, err)
	return _c
}

func (_c *MockS3Manager_DeleteBucketLifecycle_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketLifecycleInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketLifecycleOutput, error)) *MockS3Manager_DeleteBucketLifecycle_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBucketMetricsConfiguration provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) DeleteBucketMetricsConfiguration(ctx context.Context, params *s3.DeleteBucketMetricsConfigurationInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketMetricsConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketMetricsConfiguration")
	}

	var r0 *s3.DeleteBucketMetricsConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketMetricsConfigurationInput, ...func(*s3.Options)) (*s3.DeleteBucketMetricsConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketMetricsConfigurationInput, ...func(*s3.Options)) *s3.DeleteBucketMetricsConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketMetricsConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketMetricsConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_DeleteBucketMetricsConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketMetricsConfiguration'
type MockS3Manager_DeleteBucketMetricsConfiguration_Call struct {
	*mock.Call
}

// DeleteBucketMetricsConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketMetricsConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) DeleteBucketMetricsConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_DeleteBucketMetricsConfiguration_Call {
	return &MockS3Manager_DeleteBucketMetricsConfiguration_Call{Call: _e.mock.On("DeleteBucketMetricsConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_DeleteBucketMetricsConfiguration_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketMetricsConfigurationInput, optFns ...func(*s3.Options))) *MockS3Manager_DeleteBucketMetricsConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketMetricsConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketMetricsConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_DeleteBucketMetricsConfiguration_Call) Return(deleteBucketMetricsConfigurationOutput *s3.DeleteBucketMetricsConfigurationOutput, err error) *MockS3Manager_DeleteBucketMetricsConfiguration_Call {
	_c.Call.Return(deleteBucketMetricsConfigurationOutput, err)
	return _c
}

func (_c *MockS3Manager_DeleteBucketMetricsConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketMetricsConfigurationInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketMetricsConfigurationOutput, error)) *MockS3Manager_DeleteBucketMetricsConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBucketOwnershipControls provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) DeleteBucketOwnershipControls(ctx context.Context, params *s3.DeleteBucketOwnershipControlsInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketOwnershipControlsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketOwnershipControls")
	}

	var r0 *s3.DeleteBucketOwnershipControlsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketOwnershipControlsInput, ...func(*s3.Options)) (*s3.DeleteBucketOwnershipControlsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketOwnershipControlsInput, ...func(*s3.Options)) *s3.DeleteBucketOwnershipControlsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketOwnershipControlsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketOwnershipControlsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_DeleteBucketOwnershipControls_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketOwnershipControls'
type MockS3Manager_DeleteBucketOwnershipControls_Call struct {
	*mock.Call
}

// DeleteBucketOwnershipControls is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketOwnershipControlsInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) DeleteBucketOwnershipControls(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_DeleteBucketOwnershipControls_Call {
	return &MockS3Manager_DeleteBucketOwnershipControls_Call{Call: _e.mock.On("DeleteBucketOwnershipControls",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_DeleteBucketOwnershipControls_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketOwnershipControlsInput, optFns ...func(*s3.Options))) *MockS3Manager_DeleteBucketOwnershipControls_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketOwnershipControlsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketOwnershipControlsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_DeleteBucketOwnershipControls_Call) Return(deleteBucketOwnershipControlsOutput *s3.DeleteBucketOwnershipControlsOutput, err error) *MockS3Manager_DeleteBucketOwnershipControls_Call {
	_c.Call.Return(deleteBucketOwnershipControlsOutput, err)
	return _c
}

func (_c *MockS3Manager_DeleteBucketOwnershipControls_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketOwnershipControlsInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketOwnershipControlsOutput, error)) *MockS3Manager_DeleteBucketOwnershipControls_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBucketPolicy provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) DeleteBucketPolicy(ctx context.Context, params *s3.DeleteBucketPolicyInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketPolicyOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketPolicy")
	}

	var r0 *s3.DeleteBucketPolicyOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketPolicyInput, ...func(*s3.Options)) (*s3.DeleteBucketPolicyOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketPolicyInput, ...func(*s3.Options)) *s3.DeleteBucketPolicyOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketPolicyOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketPolicyInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_DeleteBucketPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketPolicy'
type MockS3Manager_DeleteBucketPolicy_Call struct {
	*mock.Call
}

// DeleteBucketPolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketPolicyInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) DeleteBucketPolicy(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_DeleteBucketPolicy_Call {
	return &MockS3Manager_DeleteBucketPolicy_Call{Call: _e.mock.On("DeleteBucketPolicy",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_DeleteBucketPolicy_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketPolicyInput, optFns ...func(*s3.Options))) *MockS3Manager_DeleteBucketPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketPolicyInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketPolicyInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_DeleteBucketPolicy_Call) Return(deleteBucketPolicyOutput *s3.DeleteBucketPolicyOutput, err error) *MockS3Manager_DeleteBucketPolicy_Call {
	_c.Call.Return(deleteBucketPolicyOutput, err)
	return _c
}

func (_c *MockS3Manager_DeleteBucketPolicy_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketPolicyInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketPolicyOutput, error)) *MockS3Manager_DeleteBucketPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBucketReplication provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) DeleteBucketReplication(ctx context.Context, params *s3.DeleteBucketReplicationInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketReplicationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketReplication")
	}

	var r0 *s3.DeleteBucketReplicationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketReplicationInput, ...func(*s3.Options)) (*s3.DeleteBucketReplicationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketReplicationInput, ...func(*s3.Options)) *s3.DeleteBucketReplicationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketReplicationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketReplicationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_DeleteBucketReplication_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketReplication'
type MockS3Manager_DeleteBucketReplication_Call struct {
	*mock.Call
}

// DeleteBucketReplication is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketReplicationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) DeleteBucketReplication(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_DeleteBucketReplication_Call {
	return &MockS3Manager_DeleteBucketReplication_Call{Call: _e.mock.On("DeleteBucketReplication",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_DeleteBucketReplication_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketReplicationInput, optFns ...func(*s3.Options))) *MockS3Manager_DeleteBucketReplication_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketReplicationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketReplicationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_DeleteBucketReplication_Call) Return(deleteBucketReplicationOutput *s3.DeleteBucketReplicationOutput, err error) *MockS3Manager_DeleteBucketReplication_Call {
	_c.Call.Return(deleteBucketReplicationOutput, err)
	return _c
}

func (_c *MockS3Manager_DeleteBucketReplication_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketReplicationInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketReplicationOutput, error)) *MockS3Manager_DeleteBucketReplication_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBucketTagging provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) DeleteBucketTagging(ctx context.Context, params *s3.DeleteBucketTaggingInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketTaggingOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketTagging")
	}

	var r0 *s3.DeleteBucketTaggingOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketTaggingInput, ...func(*s3.Options)) (*s3.DeleteBucketTaggingOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketTaggingInput, ...func(*s3.Options)) *s3.DeleteBucketTaggingOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketTaggingOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketTaggingInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_DeleteBucketTagging_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketTagging'
type MockS3Manager_DeleteBucketTagging_Call struct {
	*mock.Call
}

// DeleteBucketTagging is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketTaggingInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) DeleteBucketTagging(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_DeleteBucketTagging_Call {
	return &MockS3Manager_DeleteBucketTagging_Call{Call: _e.mock.On("DeleteBucketTagging",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_DeleteBucketTagging_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketTaggingInput, optFns ...func(*s3.Options))) *MockS3Manager_DeleteBucketTagging_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketTaggingInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketTaggingInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_DeleteBucketTagging_Call) Return(deleteBucketTaggingOutput *s3.DeleteBucketTaggingOutput, err error) *MockS3Manager_DeleteBucketTagging_Call {
	_c.Call.Return(deleteBucketTaggingOutput, err)
	return _c
}

func (_c *MockS3Manager_DeleteBucketTagging_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketTaggingInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketTaggingOutput, error)) *MockS3Manager_DeleteBucketTagging_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteBucketWebsite provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) DeleteBucketWebsite(ctx context.Context, params *s3.DeleteBucketWebsiteInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketWebsiteOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteBucketWebsite")
	}

	var r0 *s3.DeleteBucketWebsiteOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketWebsiteInput, ...func(*s3.Options)) (*s3.DeleteBucketWebsiteOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteBucketWebsiteInput, ...func(*s3.Options)) *s3.DeleteBucketWebsiteOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteBucketWebsiteOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteBucketWebsiteInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_DeleteBucketWebsite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteBucketWebsite'
type MockS3Manager_DeleteBucketWebsite_Call struct {
	*mock.Call
}

// DeleteBucketWebsite is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteBucketWebsiteInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) DeleteBucketWebsite(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_DeleteBucketWebsite_Call {
	return &MockS3Manager_DeleteBucketWebsite_Call{Call: _e.mock.On("DeleteBucketWebsite",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_DeleteBucketWebsite_Call) Run(run func(ctx context.Context, params *s3.DeleteBucketWebsiteInput, optFns ...func(*s3.Options))) *MockS3Manager_DeleteBucketWebsite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteBucketWebsiteInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteBucketWebsiteInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_DeleteBucketWebsite_Call) Return(deleteBucketWebsiteOutput *s3.DeleteBucketWebsiteOutput, err error) *MockS3Manager_DeleteBucketWebsite_Call {
	_c.Call.Return(deleteBucketWebsiteOutput, err)
	return _c
}

func (_c *MockS3Manager_DeleteBucketWebsite_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteBucketWebsiteInput, optFns ...func(*s3.Options)) (*s3.DeleteBucketWebsiteOutput, error)) *MockS3Manager_DeleteBucketWebsite_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteObject provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) DeleteObject(ctx context.Context, params *s3.DeleteObjectInput, optFns ...func(*s3.Options)) (*s3.DeleteObjectOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteObject")
	}

	var r0 *s3.DeleteObjectOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteObjectInput, ...func(*s3.Options)) (*s3.DeleteObjectOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteObjectInput, ...func(*s3.Options)) *s3.DeleteObjectOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteObjectOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteObjectInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_DeleteObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteObject'
type MockS3Manager_DeleteObject_Call struct {
	*mock.Call
}

// DeleteObject is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteObjectInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) DeleteObject(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_DeleteObject_Call {
	return &MockS3Manager_DeleteObject_Call{Call: _e.mock.On("DeleteObject",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_DeleteObject_Call) Run(run func(ctx context.Context, params *s3.DeleteObjectInput, optFns ...func(*s3.Options))) *MockS3Manager_DeleteObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteObjectInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteObjectInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_DeleteObject_Call) Return(deleteObjectOutput *s3.DeleteObjectOutput, err error) *MockS3Manager_DeleteObject_Call {
	_c.Call.Return(deleteObjectOutput, err)
	return _c
}

func (_c *MockS3Manager_DeleteObject_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteObjectInput, optFns ...func(*s3.Options)) (*s3.DeleteObjectOutput, error)) *MockS3Manager_DeleteObject_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteObjectTagging provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) DeleteObjectTagging(ctx context.Context, params *s3.DeleteObjectTaggingInput, optFns ...func(*s3.Options)) (*s3.DeleteObjectTaggingOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteObjectTagging")
	}

	var r0 *s3.DeleteObjectTaggingOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteObjectTaggingInput, ...func(*s3.Options)) (*s3.DeleteObjectTaggingOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteObjectTaggingInput, ...func(*s3.Options)) *s3.DeleteObjectTaggingOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteObjectTaggingOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteObjectTaggingInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_DeleteObjectTagging_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteObjectTagging'
type MockS3Manager_DeleteObjectTagging_Call struct {
	*mock.Call
}

// DeleteObjectTagging is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteObjectTaggingInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) DeleteObjectTagging(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_DeleteObjectTagging_Call {
	return &MockS3Manager_DeleteObjectTagging_Call{Call: _e.mock.On("DeleteObjectTagging",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_DeleteObjectTagging_Call) Run(run func(ctx context.Context, params *s3.DeleteObjectTaggingInput, optFns ...func(*s3.Options))) *MockS3Manager_DeleteObjectTagging_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteObjectTaggingInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteObjectTaggingInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_DeleteObjectTagging_Call) Return(deleteObjectTaggingOutput *s3.DeleteObjectTaggingOutput, err error) *MockS3Manager_DeleteObjectTagging_Call {
	_c.Call.Return(deleteObjectTaggingOutput, err)
	return _c
}

func (_c *MockS3Manager_DeleteObjectTagging_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteObjectTaggingInput, optFns ...func(*s3.Options)) (*s3.DeleteObjectTaggingOutput, error)) *MockS3Manager_DeleteObjectTagging_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteObjects provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) DeleteObjects(ctx context.Context, params *s3.DeleteObjectsInput, optFns ...func(*s3.Options)) (*s3.DeleteObjectsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteObjects")
	}

	var r0 *s3.DeleteObjectsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteObjectsInput, ...func(*s3.Options)) (*s3.DeleteObjectsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeleteObjectsInput, ...func(*s3.Options)) *s3.DeleteObjectsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeleteObjectsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeleteObjectsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_DeleteObjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteObjects'
type MockS3Manager_DeleteObjects_Call struct {
	*mock.Call
}

// DeleteObjects is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeleteObjectsInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) DeleteObjects(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_DeleteObjects_Call {
	return &MockS3Manager_DeleteObjects_Call{Call: _e.mock.On("DeleteObjects",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_DeleteObjects_Call) Run(run func(ctx context.Context, params *s3.DeleteObjectsInput, optFns ...func(*s3.Options))) *MockS3Manager_DeleteObjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeleteObjectsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeleteObjectsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_DeleteObjects_Call) Return(deleteObjectsOutput *s3.DeleteObjectsOutput, err error) *MockS3Manager_DeleteObjects_Call {
	_c.Call.Return(deleteObjectsOutput, err)
	return _c
}

func (_c *MockS3Manager_DeleteObjects_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeleteObjectsInput, optFns ...func(*s3.Options)) (*s3.DeleteObjectsOutput, error)) *MockS3Manager_DeleteObjects_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePublicAccessBlock provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) DeletePublicAccessBlock(ctx context.Context, params *s3.DeletePublicAccessBlockInput, optFns ...func(*s3.Options)) (*s3.DeletePublicAccessBlockOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeletePublicAccessBlock")
	}

	var r0 *s3.DeletePublicAccessBlockOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeletePublicAccessBlockInput, ...func(*s3.Options)) (*s3.DeletePublicAccessBlockOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.DeletePublicAccessBlockInput, ...func(*s3.Options)) *s3.DeletePublicAccessBlockOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.DeletePublicAccessBlockOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.DeletePublicAccessBlockInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_DeletePublicAccessBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePublicAccessBlock'
type MockS3Manager_DeletePublicAccessBlock_Call struct {
	*mock.Call
}

// DeletePublicAccessBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.DeletePublicAccessBlockInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) DeletePublicAccessBlock(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_DeletePublicAccessBlock_Call {
	return &MockS3Manager_DeletePublicAccessBlock_Call{Call: _e.mock.On("DeletePublicAccessBlock",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_DeletePublicAccessBlock_Call) Run(run func(ctx context.Context, params *s3.DeletePublicAccessBlockInput, optFns ...func(*s3.Options))) *MockS3Manager_DeletePublicAccessBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.DeletePublicAccessBlockInput
		if args[1] != nil {
			arg1 = args[1].(*s3.DeletePublicAccessBlockInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_DeletePublicAccessBlock_Call) Return(deletePublicAccessBlockOutput *s3.DeletePublicAccessBlockOutput, err error) *MockS3Manager_DeletePublicAccessBlock_Call {
	_c.Call.Return(deletePublicAccessBlockOutput, err)
	return _c
}

func (_c *MockS3Manager_DeletePublicAccessBlock_Call) RunAndReturn(run func(ctx context.Context, params *s3.DeletePublicAccessBlockInput, optFns ...func(*s3.Options)) (*s3.DeletePublicAccessBlockOutput, error)) *MockS3Manager_DeletePublicAccessBlock_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketAccelerateConfiguration provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetBucketAccelerateConfiguration(ctx context.Context, params *s3.GetBucketAccelerateConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketAccelerateConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketAccelerateConfiguration")
	}

	var r0 *s3.GetBucketAccelerateConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketAccelerateConfigurationInput, ...func(*s3.Options)) (*s3.GetBucketAccelerateConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketAccelerateConfigurationInput, ...func(*s3.Options)) *s3.GetBucketAccelerateConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketAccelerateConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketAccelerateConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetBucketAccelerateConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketAccelerateConfiguration'
type MockS3Manager_GetBucketAccelerateConfiguration_Call struct {
	*mock.Call
}

// GetBucketAccelerateConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketAccelerateConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetBucketAccelerateConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetBucketAccelerateConfiguration_Call {
	return &MockS3Manager_GetBucketAccelerateConfiguration_Call{Call: _e.mock.On("GetBucketAccelerateConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetBucketAccelerateConfiguration_Call) Run(run func(ctx context.Context, params *s3.GetBucketAccelerateConfigurationInput, optFns ...func(*s3.Options))) *MockS3Manager_GetBucketAccelerateConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketAccelerateConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketAccelerateConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetBucketAccelerateConfiguration_Call) Return(getBucketAccelerateConfigurationOutput *s3.GetBucketAccelerateConfigurationOutput, err error) *MockS3Manager_GetBucketAccelerateConfiguration_Call {
	_c.Call.Return(getBucketAccelerateConfigurationOutput, err)
	return _c
}

func (_c *MockS3Manager_GetBucketAccelerateConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketAccelerateConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketAccelerateConfigurationOutput, error)) *MockS3Manager_GetBucketAccelerateConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketAcl provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetBucketAcl(ctx context.Context, params *s3.GetBucketAclInput, optFns ...func(*s3.Options)) (*s3.GetBucketAclOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketAcl")
	}

	var r0 *s3.GetBucketAclOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketAclInput, ...func(*s3.Options)) (*s3.GetBucketAclOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketAclInput, ...func(*s3.Options)) *s3.GetBucketAclOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketAclOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketAclInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetBucketAcl_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketAcl'
type MockS3Manager_GetBucketAcl_Call struct {
	*mock.Call
}

// GetBucketAcl is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketAclInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetBucketAcl(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetBucketAcl_Call {
	return &MockS3Manager_GetBucketAcl_Call{Call: _e.mock.On("GetBucketAcl",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetBucketAcl_Call) Run(run func(ctx context.Context, params *s3.GetBucketAclInput, optFns ...func(*s3.Options))) *MockS3Manager_GetBucketAcl_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketAclInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketAclInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetBucketAcl_Call) Return(getBucketAclOutput *s3.GetBucketAclOutput, err error) *MockS3Manager_GetBucketAcl_Call {
	_c.Call.Return(getBucketAclOutput, err)
	return _c
}

func (_c *MockS3Manager_GetBucketAcl_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketAclInput, optFns ...func(*s3.Options)) (*s3.GetBucketAclOutput, error)) *MockS3Manager_GetBucketAcl_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketAnalyticsConfiguration provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetBucketAnalyticsConfiguration(ctx context.Context, params *s3.GetBucketAnalyticsConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketAnalyticsConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketAnalyticsConfiguration")
	}

	var r0 *s3.GetBucketAnalyticsConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketAnalyticsConfigurationInput, ...func(*s3.Options)) (*s3.GetBucketAnalyticsConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketAnalyticsConfigurationInput, ...func(*s3.Options)) *s3.GetBucketAnalyticsConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketAnalyticsConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketAnalyticsConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetBucketAnalyticsConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketAnalyticsConfiguration'
type MockS3Manager_GetBucketAnalyticsConfiguration_Call struct {
	*mock.Call
}

// GetBucketAnalyticsConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketAnalyticsConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetBucketAnalyticsConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetBucketAnalyticsConfiguration_Call {
	return &MockS3Manager_GetBucketAnalyticsConfiguration_Call{Call: _e.mock.On("GetBucketAnalyticsConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetBucketAnalyticsConfiguration_Call) Run(run func(ctx context.Context, params *s3.GetBucketAnalyticsConfigurationInput, optFns ...func(*s3.Options))) *MockS3Manager_GetBucketAnalyticsConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketAnalyticsConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketAnalyticsConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetBucketAnalyticsConfiguration_Call) Return(getBucketAnalyticsConfigurationOutput *s3.GetBucketAnalyticsConfigurationOutput, err error) *MockS3Manager_GetBucketAnalyticsConfiguration_Call {
	_c.Call.Return(getBucketAnalyticsConfigurationOutput, err)
	return _c
}

func (_c *MockS3Manager_GetBucketAnalyticsConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketAnalyticsConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketAnalyticsConfigurationOutput, error)) *MockS3Manager_GetBucketAnalyticsConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketCors provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetBucketCors(ctx context.Context, params *s3.GetBucketCorsInput, optFns ...func(*s3.Options)) (*s3.GetBucketCorsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketCors")
	}

	var r0 *s3.GetBucketCorsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketCorsInput, ...func(*s3.Options)) (*s3.GetBucketCorsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketCorsInput, ...func(*s3.Options)) *s3.GetBucketCorsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketCorsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketCorsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetBucketCors_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketCors'
type MockS3Manager_GetBucketCors_Call struct {
	*mock.Call
}

// GetBucketCors is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketCorsInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetBucketCors(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetBucketCors_Call {
	return &MockS3Manager_GetBucketCors_Call{Call: _e.mock.On("GetBucketCors",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetBucketCors_Call) Run(run func(ctx context.Context, params *s3.GetBucketCorsInput, optFns ...func(*s3.Options))) *MockS3Manager_GetBucketCors_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketCorsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketCorsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetBucketCors_Call) Return(getBucketCorsOutput *s3.GetBucketCorsOutput, err error) *MockS3Manager_GetBucketCors_Call {
	_c.Call.Return(getBucketCorsOutput, err)
	return _c
}

func (_c *MockS3Manager_GetBucketCors_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketCorsInput, optFns ...func(*s3.Options)) (*s3.GetBucketCorsOutput, error)) *MockS3Manager_GetBucketCors_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketEncryption provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetBucketEncryption(ctx context.Context, params *s3.GetBucketEncryptionInput, optFns ...func(*s3.Options)) (*s3.GetBucketEncryptionOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketEncryption")
	}

	var r0 *s3.GetBucketEncryptionOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketEncryptionInput, ...func(*s3.Options)) (*s3.GetBucketEncryptionOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketEncryptionInput, ...func(*s3.Options)) *s3.GetBucketEncryptionOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketEncryptionOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketEncryptionInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetBucketEncryption_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketEncryption'
type MockS3Manager_GetBucketEncryption_Call struct {
	*mock.Call
}

// GetBucketEncryption is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketEncryptionInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetBucketEncryption(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetBucketEncryption_Call {
	return &MockS3Manager_GetBucketEncryption_Call{Call: _e.mock.On("GetBucketEncryption",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetBucketEncryption_Call) Run(run func(ctx context.Context, params *s3.GetBucketEncryptionInput, optFns ...func(*s3.Options))) *MockS3Manager_GetBucketEncryption_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketEncryptionInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketEncryptionInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetBucketEncryption_Call) Return(getBucketEncryptionOutput *s3.GetBucketEncryptionOutput, err error) *MockS3Manager_GetBucketEncryption_Call {
	_c.Call.Return(getBucketEncryptionOutput, err)
	return _c
}

func (_c *MockS3Manager_GetBucketEncryption_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketEncryptionInput, optFns ...func(*s3.Options)) (*s3.GetBucketEncryptionOutput, error)) *MockS3Manager_GetBucketEncryption_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketIntelligentTieringConfiguration provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetBucketIntelligentTieringConfiguration(ctx context.Context, params *s3.GetBucketIntelligentTieringConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketIntelligentTieringConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketIntelligentTieringConfiguration")
	}

	var r0 *s3.GetBucketIntelligentTieringConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketIntelligentTieringConfigurationInput, ...func(*s3.Options)) (*s3.GetBucketIntelligentTieringConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketIntelligentTieringConfigurationInput, ...func(*s3.Options)) *s3.GetBucketIntelligentTieringConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketIntelligentTieringConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketIntelligentTieringConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetBucketIntelligentTieringConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketIntelligentTieringConfiguration'
type MockS3Manager_GetBucketIntelligentTieringConfiguration_Call struct {
	*mock.Call
}

// GetBucketIntelligentTieringConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketIntelligentTieringConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetBucketIntelligentTieringConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetBucketIntelligentTieringConfiguration_Call {
	return &MockS3Manager_GetBucketIntelligentTieringConfiguration_Call{Call: _e.mock.On("GetBucketIntelligentTieringConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetBucketIntelligentTieringConfiguration_Call) Run(run func(ctx context.Context, params *s3.GetBucketIntelligentTieringConfigurationInput, optFns ...func(*s3.Options))) *MockS3Manager_GetBucketIntelligentTieringConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketIntelligentTieringConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketIntelligentTieringConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetBucketIntelligentTieringConfiguration_Call) Return(getBucketIntelligentTieringConfigurationOutput *s3.GetBucketIntelligentTieringConfigurationOutput, err error) *MockS3Manager_GetBucketIntelligentTieringConfiguration_Call {
	_c.Call.Return(getBucketIntelligentTieringConfigurationOutput, err)
	return _c
}

func (_c *MockS3Manager_GetBucketIntelligentTieringConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketIntelligentTieringConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketIntelligentTieringConfigurationOutput, error)) *MockS3Manager_GetBucketIntelligentTieringConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketInventoryConfiguration provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetBucketInventoryConfiguration(ctx context.Context, params *s3.GetBucketInventoryConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketInventoryConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketInventoryConfiguration")
	}

	var r0 *s3.GetBucketInventoryConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketInventoryConfigurationInput, ...func(*s3.Options)) (*s3.GetBucketInventoryConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketInventoryConfigurationInput, ...func(*s3.Options)) *s3.GetBucketInventoryConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketInventoryConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketInventoryConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetBucketInventoryConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketInventoryConfiguration'
type MockS3Manager_GetBucketInventoryConfiguration_Call struct {
	*mock.Call
}

// GetBucketInventoryConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketInventoryConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetBucketInventoryConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetBucketInventoryConfiguration_Call {
	return &MockS3Manager_GetBucketInventoryConfiguration_Call{Call: _e.mock.On("GetBucketInventoryConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetBucketInventoryConfiguration_Call) Run(run func(ctx context.Context, params *s3.GetBucketInventoryConfigurationInput, optFns ...func(*s3.Options))) *MockS3Manager_GetBucketInventoryConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketInventoryConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketInventoryConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetBucketInventoryConfiguration_Call) Return(getBucketInventoryConfigurationOutput *s3.GetBucketInventoryConfigurationOutput, err error) *MockS3Manager_GetBucketInventoryConfiguration_Call {
	_c.Call.Return(getBucketInventoryConfigurationOutput, err)
	return _c
}

func (_c *MockS3Manager_GetBucketInventoryConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketInventoryConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketInventoryConfigurationOutput, error)) *MockS3Manager_GetBucketInventoryConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketLifecycleConfiguration provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetBucketLifecycleConfiguration(ctx context.Context, params *s3.GetBucketLifecycleConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketLifecycleConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketLifecycleConfiguration")
	}

	var r0 *s3.GetBucketLifecycleConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketLifecycleConfigurationInput, ...func(*s3.Options)) (*s3.GetBucketLifecycleConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketLifecycleConfigurationInput, ...func(*s3.Options)) *s3.GetBucketLifecycleConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketLifecycleConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketLifecycleConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetBucketLifecycleConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketLifecycleConfiguration'
type MockS3Manager_GetBucketLifecycleConfiguration_Call struct {
	*mock.Call
}

// GetBucketLifecycleConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketLifecycleConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetBucketLifecycleConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetBucketLifecycleConfiguration_Call {
	return &MockS3Manager_GetBucketLifecycleConfiguration_Call{Call: _e.mock.On("GetBucketLifecycleConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetBucketLifecycleConfiguration_Call) Run(run func(ctx context.Context, params *s3.GetBucketLifecycleConfigurationInput, optFns ...func(*s3.Options))) *MockS3Manager_GetBucketLifecycleConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketLifecycleConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketLifecycleConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetBucketLifecycleConfiguration_Call) Return(getBucketLifecycleConfigurationOutput *s3.GetBucketLifecycleConfigurationOutput, err error) *MockS3Manager_GetBucketLifecycleConfiguration_Call {
	_c.Call.Return(getBucketLifecycleConfigurationOutput, err)
	return _c
}

func (_c *MockS3Manager_GetBucketLifecycleConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketLifecycleConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketLifecycleConfigurationOutput, error)) *MockS3Manager_GetBucketLifecycleConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketLocation provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetBucketLocation(ctx context.Context, params *s3.GetBucketLocationInput, optFns ...func(*s3.Options)) (*s3.GetBucketLocationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketLocation")
	}

	var r0 *s3.GetBucketLocationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketLocationInput, ...func(*s3.Options)) (*s3.GetBucketLocationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketLocationInput, ...func(*s3.Options)) *s3.GetBucketLocationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketLocationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketLocationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetBucketLocation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketLocation'
type MockS3Manager_GetBucketLocation_Call struct {
	*mock.Call
}

// GetBucketLocation is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketLocationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetBucketLocation(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetBucketLocation_Call {
	return &MockS3Manager_GetBucketLocation_Call{Call: _e.mock.On("GetBucketLocation",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetBucketLocation_Call) Run(run func(ctx context.Context, params *s3.GetBucketLocationInput, optFns ...func(*s3.Options))) *MockS3Manager_GetBucketLocation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketLocationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketLocationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetBucketLocation_Call) Return(getBucketLocationOutput *s3.GetBucketLocationOutput, err error) *MockS3Manager_GetBucketLocation_Call {
	_c.Call.Return(getBucketLocationOutput, err)
	return _c
}

func (_c *MockS3Manager_GetBucketLocation_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketLocationInput, optFns ...func(*s3.Options)) (*s3.GetBucketLocationOutput, error)) *MockS3Manager_GetBucketLocation_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketLogging provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetBucketLogging(ctx context.Context, params *s3.GetBucketLoggingInput, optFns ...func(*s3.Options)) (*s3.GetBucketLoggingOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketLogging")
	}

	var r0 *s3.GetBucketLoggingOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketLoggingInput, ...func(*s3.Options)) (*s3.GetBucketLoggingOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketLoggingInput, ...func(*s3.Options)) *s3.GetBucketLoggingOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketLoggingOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketLoggingInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetBucketLogging_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketLogging'
type MockS3Manager_GetBucketLogging_Call struct {
	*mock.Call
}

// GetBucketLogging is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketLoggingInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetBucketLogging(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetBucketLogging_Call {
	return &MockS3Manager_GetBucketLogging_Call{Call: _e.mock.On("GetBucketLogging",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetBucketLogging_Call) Run(run func(ctx context.Context, params *s3.GetBucketLoggingInput, optFns ...func(*s3.Options))) *MockS3Manager_GetBucketLogging_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketLoggingInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketLoggingInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetBucketLogging_Call) Return(getBucketLoggingOutput *s3.GetBucketLoggingOutput, err error) *MockS3Manager_GetBucketLogging_Call {
	_c.Call.Return(getBucketLoggingOutput, err)
	return _c
}

func (_c *MockS3Manager_GetBucketLogging_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketLoggingInput, optFns ...func(*s3.Options)) (*s3.GetBucketLoggingOutput, error)) *MockS3Manager_GetBucketLogging_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketMetricsConfiguration provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetBucketMetricsConfiguration(ctx context.Context, params *s3.GetBucketMetricsConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketMetricsConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketMetricsConfiguration")
	}

	var r0 *s3.GetBucketMetricsConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketMetricsConfigurationInput, ...func(*s3.Options)) (*s3.GetBucketMetricsConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketMetricsConfigurationInput, ...func(*s3.Options)) *s3.GetBucketMetricsConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketMetricsConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketMetricsConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetBucketMetricsConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketMetricsConfiguration'
type MockS3Manager_GetBucketMetricsConfiguration_Call struct {
	*mock.Call
}

// GetBucketMetricsConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketMetricsConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetBucketMetricsConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetBucketMetricsConfiguration_Call {
	return &MockS3Manager_GetBucketMetricsConfiguration_Call{Call: _e.mock.On("GetBucketMetricsConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetBucketMetricsConfiguration_Call) Run(run func(ctx context.Context, params *s3.GetBucketMetricsConfigurationInput, optFns ...func(*s3.Options))) *MockS3Manager_GetBucketMetricsConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketMetricsConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketMetricsConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetBucketMetricsConfiguration_Call) Return(getBucketMetricsConfigurationOutput *s3.GetBucketMetricsConfigurationOutput, err error) *MockS3Manager_GetBucketMetricsConfiguration_Call {
	_c.Call.Return(getBucketMetricsConfigurationOutput, err)
	return _c
}

func (_c *MockS3Manager_GetBucketMetricsConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketMetricsConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketMetricsConfigurationOutput, error)) *MockS3Manager_GetBucketMetricsConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketNotificationConfiguration provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetBucketNotificationConfiguration(ctx context.Context, params *s3.GetBucketNotificationConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketNotificationConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketNotificationConfiguration")
	}

	var r0 *s3.GetBucketNotificationConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketNotificationConfigurationInput, ...func(*s3.Options)) (*s3.GetBucketNotificationConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketNotificationConfigurationInput, ...func(*s3.Options)) *s3.GetBucketNotificationConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketNotificationConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketNotificationConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetBucketNotificationConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketNotificationConfiguration'
type MockS3Manager_GetBucketNotificationConfiguration_Call struct {
	*mock.Call
}

// GetBucketNotificationConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketNotificationConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetBucketNotificationConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetBucketNotificationConfiguration_Call {
	return &MockS3Manager_GetBucketNotificationConfiguration_Call{Call: _e.mock.On("GetBucketNotificationConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetBucketNotificationConfiguration_Call) Run(run func(ctx context.Context, params *s3.GetBucketNotificationConfigurationInput, optFns ...func(*s3.Options))) *MockS3Manager_GetBucketNotificationConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketNotificationConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketNotificationConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetBucketNotificationConfiguration_Call) Return(getBucketNotificationConfigurationOutput *s3.GetBucketNotificationConfigurationOutput, err error) *MockS3Manager_GetBucketNotificationConfiguration_Call {
	_c.Call.Return(getBucketNotificationConfigurationOutput, err)
	return _c
}

func (_c *MockS3Manager_GetBucketNotificationConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketNotificationConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetBucketNotificationConfigurationOutput, error)) *MockS3Manager_GetBucketNotificationConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketOwnershipControls provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetBucketOwnershipControls(ctx context.Context, params *s3.GetBucketOwnershipControlsInput, optFns ...func(*s3.Options)) (*s3.GetBucketOwnershipControlsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketOwnershipControls")
	}

	var r0 *s3.GetBucketOwnershipControlsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketOwnershipControlsInput, ...func(*s3.Options)) (*s3.GetBucketOwnershipControlsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketOwnershipControlsInput, ...func(*s3.Options)) *s3.GetBucketOwnershipControlsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketOwnershipControlsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketOwnershipControlsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetBucketOwnershipControls_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketOwnershipControls'
type MockS3Manager_GetBucketOwnershipControls_Call struct {
	*mock.Call
}

// GetBucketOwnershipControls is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketOwnershipControlsInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetBucketOwnershipControls(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetBucketOwnershipControls_Call {
	return &MockS3Manager_GetBucketOwnershipControls_Call{Call: _e.mock.On("GetBucketOwnershipControls",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetBucketOwnershipControls_Call) Run(run func(ctx context.Context, params *s3.GetBucketOwnershipControlsInput, optFns ...func(*s3.Options))) *MockS3Manager_GetBucketOwnershipControls_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketOwnershipControlsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketOwnershipControlsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetBucketOwnershipControls_Call) Return(getBucketOwnershipControlsOutput *s3.GetBucketOwnershipControlsOutput, err error) *MockS3Manager_GetBucketOwnershipControls_Call {
	_c.Call.Return(getBucketOwnershipControlsOutput, err)
	return _c
}

func (_c *MockS3Manager_GetBucketOwnershipControls_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketOwnershipControlsInput, optFns ...func(*s3.Options)) (*s3.GetBucketOwnershipControlsOutput, error)) *MockS3Manager_GetBucketOwnershipControls_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketPolicy provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetBucketPolicy(ctx context.Context, params *s3.GetBucketPolicyInput, optFns ...func(*s3.Options)) (*s3.GetBucketPolicyOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketPolicy")
	}

	var r0 *s3.GetBucketPolicyOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketPolicyInput, ...func(*s3.Options)) (*s3.GetBucketPolicyOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketPolicyInput, ...func(*s3.Options)) *s3.GetBucketPolicyOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketPolicyOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketPolicyInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetBucketPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketPolicy'
type MockS3Manager_GetBucketPolicy_Call struct {
	*mock.Call
}

// GetBucketPolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketPolicyInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetBucketPolicy(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetBucketPolicy_Call {
	return &MockS3Manager_GetBucketPolicy_Call{Call: _e.mock.On("GetBucketPolicy",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetBucketPolicy_Call) Run(run func(ctx context.Context, params *s3.GetBucketPolicyInput, optFns ...func(*s3.Options))) *MockS3Manager_GetBucketPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketPolicyInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketPolicyInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetBucketPolicy_Call) Return(getBucketPolicyOutput *s3.GetBucketPolicyOutput, err error) *MockS3Manager_GetBucketPolicy_Call {
	_c.Call.Return(getBucketPolicyOutput, err)
	return _c
}

func (_c *MockS3Manager_GetBucketPolicy_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketPolicyInput, optFns ...func(*s3.Options)) (*s3.GetBucketPolicyOutput, error)) *MockS3Manager_GetBucketPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketPolicyStatus provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetBucketPolicyStatus(ctx context.Context, params *s3.GetBucketPolicyStatusInput, optFns ...func(*s3.Options)) (*s3.GetBucketPolicyStatusOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketPolicyStatus")
	}

	var r0 *s3.GetBucketPolicyStatusOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketPolicyStatusInput, ...func(*s3.Options)) (*s3.GetBucketPolicyStatusOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketPolicyStatusInput, ...func(*s3.Options)) *s3.GetBucketPolicyStatusOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketPolicyStatusOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketPolicyStatusInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetBucketPolicyStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketPolicyStatus'
type MockS3Manager_GetBucketPolicyStatus_Call struct {
	*mock.Call
}

// GetBucketPolicyStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketPolicyStatusInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetBucketPolicyStatus(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetBucketPolicyStatus_Call {
	return &MockS3Manager_GetBucketPolicyStatus_Call{Call: _e.mock.On("GetBucketPolicyStatus",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetBucketPolicyStatus_Call) Run(run func(ctx context.Context, params *s3.GetBucketPolicyStatusInput, optFns ...func(*s3.Options))) *MockS3Manager_GetBucketPolicyStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketPolicyStatusInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketPolicyStatusInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetBucketPolicyStatus_Call) Return(getBucketPolicyStatusOutput *s3.GetBucketPolicyStatusOutput, err error) *MockS3Manager_GetBucketPolicyStatus_Call {
	_c.Call.Return(getBucketPolicyStatusOutput, err)
	return _c
}

func (_c *MockS3Manager_GetBucketPolicyStatus_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketPolicyStatusInput, optFns ...func(*s3.Options)) (*s3.GetBucketPolicyStatusOutput, error)) *MockS3Manager_GetBucketPolicyStatus_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketReplication provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetBucketReplication(ctx context.Context, params *s3.GetBucketReplicationInput, optFns ...func(*s3.Options)) (*s3.GetBucketReplicationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketReplication")
	}

	var r0 *s3.GetBucketReplicationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketReplicationInput, ...func(*s3.Options)) (*s3.GetBucketReplicationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketReplicationInput, ...func(*s3.Options)) *s3.GetBucketReplicationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketReplicationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketReplicationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetBucketReplication_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketReplication'
type MockS3Manager_GetBucketReplication_Call struct {
	*mock.Call
}

// GetBucketReplication is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketReplicationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetBucketReplication(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetBucketReplication_Call {
	return &MockS3Manager_GetBucketReplication_Call{Call: _e.mock.On("GetBucketReplication",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetBucketReplication_Call) Run(run func(ctx context.Context, params *s3.GetBucketReplicationInput, optFns ...func(*s3.Options))) *MockS3Manager_GetBucketReplication_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketReplicationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketReplicationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetBucketReplication_Call) Return(getBucketReplicationOutput *s3.GetBucketReplicationOutput, err error) *MockS3Manager_GetBucketReplication_Call {
	_c.Call.Return(getBucketReplicationOutput, err)
	return _c
}

func (_c *MockS3Manager_GetBucketReplication_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketReplicationInput, optFns ...func(*s3.Options)) (*s3.GetBucketReplicationOutput, error)) *MockS3Manager_GetBucketReplication_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketRequestPayment provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetBucketRequestPayment(ctx context.Context, params *s3.GetBucketRequestPaymentInput, optFns ...func(*s3.Options)) (*s3.GetBucketRequestPaymentOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketRequestPayment")
	}

	var r0 *s3.GetBucketRequestPaymentOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketRequestPaymentInput, ...func(*s3.Options)) (*s3.GetBucketRequestPaymentOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketRequestPaymentInput, ...func(*s3.Options)) *s3.GetBucketRequestPaymentOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketRequestPaymentOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketRequestPaymentInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetBucketRequestPayment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketRequestPayment'
type MockS3Manager_GetBucketRequestPayment_Call struct {
	*mock.Call
}

// GetBucketRequestPayment is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketRequestPaymentInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetBucketRequestPayment(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetBucketRequestPayment_Call {
	return &MockS3Manager_GetBucketRequestPayment_Call{Call: _e.mock.On("GetBucketRequestPayment",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetBucketRequestPayment_Call) Run(run func(ctx context.Context, params *s3.GetBucketRequestPaymentInput, optFns ...func(*s3.Options))) *MockS3Manager_GetBucketRequestPayment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketRequestPaymentInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketRequestPaymentInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetBucketRequestPayment_Call) Return(getBucketRequestPaymentOutput *s3.GetBucketRequestPaymentOutput, err error) *MockS3Manager_GetBucketRequestPayment_Call {
	_c.Call.Return(getBucketRequestPaymentOutput, err)
	return _c
}

func (_c *MockS3Manager_GetBucketRequestPayment_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketRequestPaymentInput, optFns ...func(*s3.Options)) (*s3.GetBucketRequestPaymentOutput, error)) *MockS3Manager_GetBucketRequestPayment_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketTagging provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetBucketTagging(ctx context.Context, params *s3.GetBucketTaggingInput, optFns ...func(*s3.Options)) (*s3.GetBucketTaggingOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketTagging")
	}

	var r0 *s3.GetBucketTaggingOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketTaggingInput, ...func(*s3.Options)) (*s3.GetBucketTaggingOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketTaggingInput, ...func(*s3.Options)) *s3.GetBucketTaggingOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketTaggingOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketTaggingInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetBucketTagging_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketTagging'
type MockS3Manager_GetBucketTagging_Call struct {
	*mock.Call
}

// GetBucketTagging is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketTaggingInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetBucketTagging(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetBucketTagging_Call {
	return &MockS3Manager_GetBucketTagging_Call{Call: _e.mock.On("GetBucketTagging",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetBucketTagging_Call) Run(run func(ctx context.Context, params *s3.GetBucketTaggingInput, optFns ...func(*s3.Options))) *MockS3Manager_GetBucketTagging_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketTaggingInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketTaggingInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetBucketTagging_Call) Return(getBucketTaggingOutput *s3.GetBucketTaggingOutput, err error) *MockS3Manager_GetBucketTagging_Call {
	_c.Call.Return(getBucketTaggingOutput, err)
	return _c
}

func (_c *MockS3Manager_GetBucketTagging_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketTaggingInput, optFns ...func(*s3.Options)) (*s3.GetBucketTaggingOutput, error)) *MockS3Manager_GetBucketTagging_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketVersioning provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetBucketVersioning(ctx context.Context, params *s3.GetBucketVersioningInput, optFns ...func(*s3.Options)) (*s3.GetBucketVersioningOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketVersioning")
	}

	var r0 *s3.GetBucketVersioningOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketVersioningInput, ...func(*s3.Options)) (*s3.GetBucketVersioningOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketVersioningInput, ...func(*s3.Options)) *s3.GetBucketVersioningOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketVersioningOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketVersioningInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetBucketVersioning_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketVersioning'
type MockS3Manager_GetBucketVersioning_Call struct {
	*mock.Call
}

// GetBucketVersioning is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketVersioningInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetBucketVersioning(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetBucketVersioning_Call {
	return &MockS3Manager_GetBucketVersioning_Call{Call: _e.mock.On("GetBucketVersioning",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetBucketVersioning_Call) Run(run func(ctx context.Context, params *s3.GetBucketVersioningInput, optFns ...func(*s3.Options))) *MockS3Manager_GetBucketVersioning_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketVersioningInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketVersioningInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetBucketVersioning_Call) Return(getBucketVersioningOutput *s3.GetBucketVersioningOutput, err error) *MockS3Manager_GetBucketVersioning_Call {
	_c.Call.Return(getBucketVersioningOutput, err)
	return _c
}

func (_c *MockS3Manager_GetBucketVersioning_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketVersioningInput, optFns ...func(*s3.Options)) (*s3.GetBucketVersioningOutput, error)) *MockS3Manager_GetBucketVersioning_Call {
	_c.Call.Return(run)
	return _c
}

// GetBucketWebsite provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetBucketWebsite(ctx context.Context, params *s3.GetBucketWebsiteInput, optFns ...func(*s3.Options)) (*s3.GetBucketWebsiteOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetBucketWebsite")
	}

	var r0 *s3.GetBucketWebsiteOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketWebsiteInput, ...func(*s3.Options)) (*s3.GetBucketWebsiteOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetBucketWebsiteInput, ...func(*s3.Options)) *s3.GetBucketWebsiteOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetBucketWebsiteOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetBucketWebsiteInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetBucketWebsite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBucketWebsite'
type MockS3Manager_GetBucketWebsite_Call struct {
	*mock.Call
}

// GetBucketWebsite is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetBucketWebsiteInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetBucketWebsite(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetBucketWebsite_Call {
	return &MockS3Manager_GetBucketWebsite_Call{Call: _e.mock.On("GetBucketWebsite",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetBucketWebsite_Call) Run(run func(ctx context.Context, params *s3.GetBucketWebsiteInput, optFns ...func(*s3.Options))) *MockS3Manager_GetBucketWebsite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetBucketWebsiteInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetBucketWebsiteInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetBucketWebsite_Call) Return(getBucketWebsiteOutput *s3.GetBucketWebsiteOutput, err error) *MockS3Manager_GetBucketWebsite_Call {
	_c.Call.Return(getBucketWebsiteOutput, err)
	return _c
}

func (_c *MockS3Manager_GetBucketWebsite_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetBucketWebsiteInput, optFns ...func(*s3.Options)) (*s3.GetBucketWebsiteOutput, error)) *MockS3Manager_GetBucketWebsite_Call {
	_c.Call.Return(run)
	return _c
}

// GetObject provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetObject(ctx context.Context, params *s3.GetObjectInput, optFns ...func(*s3.Options)) (*s3.GetObjectOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetObject")
	}

	var r0 *s3.GetObjectOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectInput, ...func(*s3.Options)) (*s3.GetObjectOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectInput, ...func(*s3.Options)) *s3.GetObjectOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetObjectOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetObjectInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetObject'
type MockS3Manager_GetObject_Call struct {
	*mock.Call
}

// GetObject is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetObjectInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetObject(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetObject_Call {
	return &MockS3Manager_GetObject_Call{Call: _e.mock.On("GetObject",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetObject_Call) Run(run func(ctx context.Context, params *s3.GetObjectInput, optFns ...func(*s3.Options))) *MockS3Manager_GetObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetObjectInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetObjectInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetObject_Call) Return(getObjectOutput *s3.GetObjectOutput, err error) *MockS3Manager_GetObject_Call {
	_c.Call.Return(getObjectOutput, err)
	return _c
}

func (_c *MockS3Manager_GetObject_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetObjectInput, optFns ...func(*s3.Options)) (*s3.GetObjectOutput, error)) *MockS3Manager_GetObject_Call {
	_c.Call.Return(run)
	return _c
}

// GetObjectAcl provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetObjectAcl(ctx context.Context, params *s3.GetObjectAclInput, optFns ...func(*s3.Options)) (*s3.GetObjectAclOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetObjectAcl")
	}

	var r0 *s3.GetObjectAclOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectAclInput, ...func(*s3.Options)) (*s3.GetObjectAclOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectAclInput, ...func(*s3.Options)) *s3.GetObjectAclOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetObjectAclOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetObjectAclInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetObjectAcl_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetObjectAcl'
type MockS3Manager_GetObjectAcl_Call struct {
	*mock.Call
}

// GetObjectAcl is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetObjectAclInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetObjectAcl(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetObjectAcl_Call {
	return &MockS3Manager_GetObjectAcl_Call{Call: _e.mock.On("GetObjectAcl",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetObjectAcl_Call) Run(run func(ctx context.Context, params *s3.GetObjectAclInput, optFns ...func(*s3.Options))) *MockS3Manager_GetObjectAcl_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetObjectAclInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetObjectAclInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetObjectAcl_Call) Return(getObjectAclOutput *s3.GetObjectAclOutput, err error) *MockS3Manager_GetObjectAcl_Call {
	_c.Call.Return(getObjectAclOutput, err)
	return _c
}

func (_c *MockS3Manager_GetObjectAcl_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetObjectAclInput, optFns ...func(*s3.Options)) (*s3.GetObjectAclOutput, error)) *MockS3Manager_GetObjectAcl_Call {
	_c.Call.Return(run)
	return _c
}

// GetObjectAttributes provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetObjectAttributes(ctx context.Context, params *s3.GetObjectAttributesInput, optFns ...func(*s3.Options)) (*s3.GetObjectAttributesOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetObjectAttributes")
	}

	var r0 *s3.GetObjectAttributesOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectAttributesInput, ...func(*s3.Options)) (*s3.GetObjectAttributesOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectAttributesInput, ...func(*s3.Options)) *s3.GetObjectAttributesOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetObjectAttributesOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetObjectAttributesInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetObjectAttributes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetObjectAttributes'
type MockS3Manager_GetObjectAttributes_Call struct {
	*mock.Call
}

// GetObjectAttributes is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetObjectAttributesInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetObjectAttributes(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetObjectAttributes_Call {
	return &MockS3Manager_GetObjectAttributes_Call{Call: _e.mock.On("GetObjectAttributes",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetObjectAttributes_Call) Run(run func(ctx context.Context, params *s3.GetObjectAttributesInput, optFns ...func(*s3.Options))) *MockS3Manager_GetObjectAttributes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetObjectAttributesInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetObjectAttributesInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetObjectAttributes_Call) Return(getObjectAttributesOutput *s3.GetObjectAttributesOutput, err error) *MockS3Manager_GetObjectAttributes_Call {
	_c.Call.Return(getObjectAttributesOutput, err)
	return _c
}

func (_c *MockS3Manager_GetObjectAttributes_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetObjectAttributesInput, optFns ...func(*s3.Options)) (*s3.GetObjectAttributesOutput, error)) *MockS3Manager_GetObjectAttributes_Call {
	_c.Call.Return(run)
	return _c
}

// GetObjectLegalHold provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetObjectLegalHold(ctx context.Context, params *s3.GetObjectLegalHoldInput, optFns ...func(*s3.Options)) (*s3.GetObjectLegalHoldOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetObjectLegalHold")
	}

	var r0 *s3.GetObjectLegalHoldOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectLegalHoldInput, ...func(*s3.Options)) (*s3.GetObjectLegalHoldOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectLegalHoldInput, ...func(*s3.Options)) *s3.GetObjectLegalHoldOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetObjectLegalHoldOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetObjectLegalHoldInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetObjectLegalHold_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetObjectLegalHold'
type MockS3Manager_GetObjectLegalHold_Call struct {
	*mock.Call
}

// GetObjectLegalHold is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetObjectLegalHoldInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetObjectLegalHold(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetObjectLegalHold_Call {
	return &MockS3Manager_GetObjectLegalHold_Call{Call: _e.mock.On("GetObjectLegalHold",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetObjectLegalHold_Call) Run(run func(ctx context.Context, params *s3.GetObjectLegalHoldInput, optFns ...func(*s3.Options))) *MockS3Manager_GetObjectLegalHold_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetObjectLegalHoldInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetObjectLegalHoldInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetObjectLegalHold_Call) Return(getObjectLegalHoldOutput *s3.GetObjectLegalHoldOutput, err error) *MockS3Manager_GetObjectLegalHold_Call {
	_c.Call.Return(getObjectLegalHoldOutput, err)
	return _c
}

func (_c *MockS3Manager_GetObjectLegalHold_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetObjectLegalHoldInput, optFns ...func(*s3.Options)) (*s3.GetObjectLegalHoldOutput, error)) *MockS3Manager_GetObjectLegalHold_Call {
	_c.Call.Return(run)
	return _c
}

// GetObjectLockConfiguration provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetObjectLockConfiguration(ctx context.Context, params *s3.GetObjectLockConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetObjectLockConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetObjectLockConfiguration")
	}

	var r0 *s3.GetObjectLockConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectLockConfigurationInput, ...func(*s3.Options)) (*s3.GetObjectLockConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectLockConfigurationInput, ...func(*s3.Options)) *s3.GetObjectLockConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetObjectLockConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetObjectLockConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetObjectLockConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetObjectLockConfiguration'
type MockS3Manager_GetObjectLockConfiguration_Call struct {
	*mock.Call
}

// GetObjectLockConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetObjectLockConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetObjectLockConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetObjectLockConfiguration_Call {
	return &MockS3Manager_GetObjectLockConfiguration_Call{Call: _e.mock.On("GetObjectLockConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetObjectLockConfiguration_Call) Run(run func(ctx context.Context, params *s3.GetObjectLockConfigurationInput, optFns ...func(*s3.Options))) *MockS3Manager_GetObjectLockConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetObjectLockConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetObjectLockConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetObjectLockConfiguration_Call) Return(getObjectLockConfigurationOutput *s3.GetObjectLockConfigurationOutput, err error) *MockS3Manager_GetObjectLockConfiguration_Call {
	_c.Call.Return(getObjectLockConfigurationOutput, err)
	return _c
}

func (_c *MockS3Manager_GetObjectLockConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetObjectLockConfigurationInput, optFns ...func(*s3.Options)) (*s3.GetObjectLockConfigurationOutput, error)) *MockS3Manager_GetObjectLockConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// GetObjectRetention provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetObjectRetention(ctx context.Context, params *s3.GetObjectRetentionInput, optFns ...func(*s3.Options)) (*s3.GetObjectRetentionOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetObjectRetention")
	}

	var r0 *s3.GetObjectRetentionOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectRetentionInput, ...func(*s3.Options)) (*s3.GetObjectRetentionOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectRetentionInput, ...func(*s3.Options)) *s3.GetObjectRetentionOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetObjectRetentionOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetObjectRetentionInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetObjectRetention_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetObjectRetention'
type MockS3Manager_GetObjectRetention_Call struct {
	*mock.Call
}

// GetObjectRetention is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetObjectRetentionInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetObjectRetention(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetObjectRetention_Call {
	return &MockS3Manager_GetObjectRetention_Call{Call: _e.mock.On("GetObjectRetention",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetObjectRetention_Call) Run(run func(ctx context.Context, params *s3.GetObjectRetentionInput, optFns ...func(*s3.Options))) *MockS3Manager_GetObjectRetention_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetObjectRetentionInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetObjectRetentionInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetObjectRetention_Call) Return(getObjectRetentionOutput *s3.GetObjectRetentionOutput, err error) *MockS3Manager_GetObjectRetention_Call {
	_c.Call.Return(getObjectRetentionOutput, err)
	return _c
}

func (_c *MockS3Manager_GetObjectRetention_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetObjectRetentionInput, optFns ...func(*s3.Options)) (*s3.GetObjectRetentionOutput, error)) *MockS3Manager_GetObjectRetention_Call {
	_c.Call.Return(run)
	return _c
}

// GetObjectTagging provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetObjectTagging(ctx context.Context, params *s3.GetObjectTaggingInput, optFns ...func(*s3.Options)) (*s3.GetObjectTaggingOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetObjectTagging")
	}

	var r0 *s3.GetObjectTaggingOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectTaggingInput, ...func(*s3.Options)) (*s3.GetObjectTaggingOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectTaggingInput, ...func(*s3.Options)) *s3.GetObjectTaggingOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetObjectTaggingOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetObjectTaggingInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetObjectTagging_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetObjectTagging'
type MockS3Manager_GetObjectTagging_Call struct {
	*mock.Call
}

// GetObjectTagging is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetObjectTaggingInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetObjectTagging(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetObjectTagging_Call {
	return &MockS3Manager_GetObjectTagging_Call{Call: _e.mock.On("GetObjectTagging",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetObjectTagging_Call) Run(run func(ctx context.Context, params *s3.GetObjectTaggingInput, optFns ...func(*s3.Options))) *MockS3Manager_GetObjectTagging_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetObjectTaggingInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetObjectTaggingInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetObjectTagging_Call) Return(getObjectTaggingOutput *s3.GetObjectTaggingOutput, err error) *MockS3Manager_GetObjectTagging_Call {
	_c.Call.Return(getObjectTaggingOutput, err)
	return _c
}

func (_c *MockS3Manager_GetObjectTagging_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetObjectTaggingInput, optFns ...func(*s3.Options)) (*s3.GetObjectTaggingOutput, error)) *MockS3Manager_GetObjectTagging_Call {
	_c.Call.Return(run)
	return _c
}

// GetObjectTorrent provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetObjectTorrent(ctx context.Context, params *s3.GetObjectTorrentInput, optFns ...func(*s3.Options)) (*s3.GetObjectTorrentOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetObjectTorrent")
	}

	var r0 *s3.GetObjectTorrentOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectTorrentInput, ...func(*s3.Options)) (*s3.GetObjectTorrentOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectTorrentInput, ...func(*s3.Options)) *s3.GetObjectTorrentOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetObjectTorrentOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetObjectTorrentInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetObjectTorrent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetObjectTorrent'
type MockS3Manager_GetObjectTorrent_Call struct {
	*mock.Call
}

// GetObjectTorrent is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetObjectTorrentInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetObjectTorrent(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetObjectTorrent_Call {
	return &MockS3Manager_GetObjectTorrent_Call{Call: _e.mock.On("GetObjectTorrent",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetObjectTorrent_Call) Run(run func(ctx context.Context, params *s3.GetObjectTorrentInput, optFns ...func(*s3.Options))) *MockS3Manager_GetObjectTorrent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetObjectTorrentInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetObjectTorrentInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetObjectTorrent_Call) Return(getObjectTorrentOutput *s3.GetObjectTorrentOutput, err error) *MockS3Manager_GetObjectTorrent_Call {
	_c.Call.Return(getObjectTorrentOutput, err)
	return _c
}

func (_c *MockS3Manager_GetObjectTorrent_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetObjectTorrentInput, optFns ...func(*s3.Options)) (*s3.GetObjectTorrentOutput, error)) *MockS3Manager_GetObjectTorrent_Call {
	_c.Call.Return(run)
	return _c
}

// GetPublicAccessBlock provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) GetPublicAccessBlock(ctx context.Context, params *s3.GetPublicAccessBlockInput, optFns ...func(*s3.Options)) (*s3.GetPublicAccessBlockOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for GetPublicAccessBlock")
	}

	var r0 *s3.GetPublicAccessBlockOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetPublicAccessBlockInput, ...func(*s3.Options)) (*s3.GetPublicAccessBlockOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetPublicAccessBlockInput, ...func(*s3.Options)) *s3.GetPublicAccessBlockOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.GetPublicAccessBlockOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetPublicAccessBlockInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_GetPublicAccessBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPublicAccessBlock'
type MockS3Manager_GetPublicAccessBlock_Call struct {
	*mock.Call
}

// GetPublicAccessBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetPublicAccessBlockInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) GetPublicAccessBlock(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_GetPublicAccessBlock_Call {
	return &MockS3Manager_GetPublicAccessBlock_Call{Call: _e.mock.On("GetPublicAccessBlock",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_GetPublicAccessBlock_Call) Run(run func(ctx context.Context, params *s3.GetPublicAccessBlockInput, optFns ...func(*s3.Options))) *MockS3Manager_GetPublicAccessBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetPublicAccessBlockInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetPublicAccessBlockInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_GetPublicAccessBlock_Call) Return(getPublicAccessBlockOutput *s3.GetPublicAccessBlockOutput, err error) *MockS3Manager_GetPublicAccessBlock_Call {
	_c.Call.Return(getPublicAccessBlockOutput, err)
	return _c
}

func (_c *MockS3Manager_GetPublicAccessBlock_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetPublicAccessBlockInput, optFns ...func(*s3.Options)) (*s3.GetPublicAccessBlockOutput, error)) *MockS3Manager_GetPublicAccessBlock_Call {
	_c.Call.Return(run)
	return _c
}

// HeadBucket provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) HeadBucket(ctx context.Context, params *s3.HeadBucketInput, optFns ...func(*s3.Options)) (*s3.HeadBucketOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for HeadBucket")
	}

	var r0 *s3.HeadBucketOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.HeadBucketInput, ...func(*s3.Options)) (*s3.HeadBucketOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.HeadBucketInput, ...func(*s3.Options)) *s3.HeadBucketOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.HeadBucketOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.HeadBucketInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_HeadBucket_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HeadBucket'
type MockS3Manager_HeadBucket_Call struct {
	*mock.Call
}

// HeadBucket is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.HeadBucketInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) HeadBucket(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_HeadBucket_Call {
	return &MockS3Manager_HeadBucket_Call{Call: _e.mock.On("HeadBucket",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_HeadBucket_Call) Run(run func(ctx context.Context, params *s3.HeadBucketInput, optFns ...func(*s3.Options))) *MockS3Manager_HeadBucket_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.HeadBucketInput
		if args[1] != nil {
			arg1 = args[1].(*s3.HeadBucketInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_HeadBucket_Call) Return(headBucketOutput *s3.HeadBucketOutput, err error) *MockS3Manager_HeadBucket_Call {
	_c.Call.Return(headBucketOutput, err)
	return _c
}

func (_c *MockS3Manager_HeadBucket_Call) RunAndReturn(run func(ctx context.Context, params *s3.HeadBucketInput, optFns ...func(*s3.Options)) (*s3.HeadBucketOutput, error)) *MockS3Manager_HeadBucket_Call {
	_c.Call.Return(run)
	return _c
}

// HeadObject provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) HeadObject(ctx context.Context, params *s3.HeadObjectInput, optFns ...func(*s3.Options)) (*s3.HeadObjectOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for HeadObject")
	}

	var r0 *s3.HeadObjectOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.HeadObjectInput, ...func(*s3.Options)) (*s3.HeadObjectOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.HeadObjectInput, ...func(*s3.Options)) *s3.HeadObjectOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.HeadObjectOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.HeadObjectInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_HeadObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HeadObject'
type MockS3Manager_HeadObject_Call struct {
	*mock.Call
}

// HeadObject is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.HeadObjectInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) HeadObject(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_HeadObject_Call {
	return &MockS3Manager_HeadObject_Call{Call: _e.mock.On("HeadObject",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_HeadObject_Call) Run(run func(ctx context.Context, params *s3.HeadObjectInput, optFns ...func(*s3.Options))) *MockS3Manager_HeadObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.HeadObjectInput
		if args[1] != nil {
			arg1 = args[1].(*s3.HeadObjectInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_HeadObject_Call) Return(headObjectOutput *s3.HeadObjectOutput, err error) *MockS3Manager_HeadObject_Call {
	_c.Call.Return(headObjectOutput, err)
	return _c
}

func (_c *MockS3Manager_HeadObject_Call) RunAndReturn(run func(ctx context.Context, params *s3.HeadObjectInput, optFns ...func(*s3.Options)) (*s3.HeadObjectOutput, error)) *MockS3Manager_HeadObject_Call {
	_c.Call.Return(run)
	return _c
}

// ListBuckets provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) ListBuckets(ctx context.Context, params *s3.ListBucketsInput, optFns ...func(*s3.Options)) (*s3.ListBucketsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListBuckets")
	}

	var r0 *s3.ListBucketsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListBucketsInput, ...func(*s3.Options)) (*s3.ListBucketsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListBucketsInput, ...func(*s3.Options)) *s3.ListBucketsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.ListBucketsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.ListBucketsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_ListBuckets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBuckets'
type MockS3Manager_ListBuckets_Call struct {
	*mock.Call
}

// ListBuckets is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.ListBucketsInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) ListBuckets(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_ListBuckets_Call {
	return &MockS3Manager_ListBuckets_Call{Call: _e.mock.On("ListBuckets",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_ListBuckets_Call) Run(run func(ctx context.Context, params *s3.ListBucketsInput, optFns ...func(*s3.Options))) *MockS3Manager_ListBuckets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.ListBucketsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.ListBucketsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_ListBuckets_Call) Return(listBucketsOutput *s3.ListBucketsOutput, err error) *MockS3Manager_ListBuckets_Call {
	_c.Call.Return(listBucketsOutput, err)
	return _c
}

func (_c *MockS3Manager_ListBuckets_Call) RunAndReturn(run func(ctx context.Context, params *s3.ListBucketsInput, optFns ...func(*s3.Options)) (*s3.ListBucketsOutput, error)) *MockS3Manager_ListBuckets_Call {
	_c.Call.Return(run)
	return _c
}

// ListMultipartUploads provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) ListMultipartUploads(ctx context.Context, params *s3.ListMultipartUploadsInput, optFns ...func(*s3.Options)) (*s3.ListMultipartUploadsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListMultipartUploads")
	}

	var r0 *s3.ListMultipartUploadsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListMultipartUploadsInput, ...func(*s3.Options)) (*s3.ListMultipartUploadsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListMultipartUploadsInput, ...func(*s3.Options)) *s3.ListMultipartUploadsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.ListMultipartUploadsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.ListMultipartUploadsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_ListMultipartUploads_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMultipartUploads'
type MockS3Manager_ListMultipartUploads_Call struct {
	*mock.Call
}

// ListMultipartUploads is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.ListMultipartUploadsInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) ListMultipartUploads(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_ListMultipartUploads_Call {
	return &MockS3Manager_ListMultipartUploads_Call{Call: _e.mock.On("ListMultipartUploads",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_ListMultipartUploads_Call) Run(run func(ctx context.Context, params *s3.ListMultipartUploadsInput, optFns ...func(*s3.Options))) *MockS3Manager_ListMultipartUploads_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.ListMultipartUploadsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.ListMultipartUploadsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_ListMultipartUploads_Call) Return(listMultipartUploadsOutput *s3.ListMultipartUploadsOutput, err error) *MockS3Manager_ListMultipartUploads_Call {
	_c.Call.Return(listMultipartUploadsOutput, err)
	return _c
}

func (_c *MockS3Manager_ListMultipartUploads_Call) RunAndReturn(run func(ctx context.Context, params *s3.ListMultipartUploadsInput, optFns ...func(*s3.Options)) (*s3.ListMultipartUploadsOutput, error)) *MockS3Manager_ListMultipartUploads_Call {
	_c.Call.Return(run)
	return _c
}

// ListObjectVersions provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) ListObjectVersions(ctx context.Context, params *s3.ListObjectVersionsInput, optFns ...func(*s3.Options)) (*s3.ListObjectVersionsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListObjectVersions")
	}

	var r0 *s3.ListObjectVersionsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListObjectVersionsInput, ...func(*s3.Options)) (*s3.ListObjectVersionsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListObjectVersionsInput, ...func(*s3.Options)) *s3.ListObjectVersionsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.ListObjectVersionsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.ListObjectVersionsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_ListObjectVersions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListObjectVersions'
type MockS3Manager_ListObjectVersions_Call struct {
	*mock.Call
}

// ListObjectVersions is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.ListObjectVersionsInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) ListObjectVersions(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_ListObjectVersions_Call {
	return &MockS3Manager_ListObjectVersions_Call{Call: _e.mock.On("ListObjectVersions",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_ListObjectVersions_Call) Run(run func(ctx context.Context, params *s3.ListObjectVersionsInput, optFns ...func(*s3.Options))) *MockS3Manager_ListObjectVersions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.ListObjectVersionsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.ListObjectVersionsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_ListObjectVersions_Call) Return(listObjectVersionsOutput *s3.ListObjectVersionsOutput, err error) *MockS3Manager_ListObjectVersions_Call {
	_c.Call.Return(listObjectVersionsOutput, err)
	return _c
}

func (_c *MockS3Manager_ListObjectVersions_Call) RunAndReturn(run func(ctx context.Context, params *s3.ListObjectVersionsInput, optFns ...func(*s3.Options)) (*s3.ListObjectVersionsOutput, error)) *MockS3Manager_ListObjectVersions_Call {
	_c.Call.Return(run)
	return _c
}

// ListObjectsV2 provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) ListObjectsV2(ctx context.Context, params *s3.ListObjectsV2Input, optFns ...func(*s3.Options)) (*s3.ListObjectsV2Output, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListObjectsV2")
	}

	var r0 *s3.ListObjectsV2Output
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListObjectsV2Input, ...func(*s3.Options)) (*s3.ListObjectsV2Output, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListObjectsV2Input, ...func(*s3.Options)) *s3.ListObjectsV2Output); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.ListObjectsV2Output)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.ListObjectsV2Input, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_ListObjectsV2_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListObjectsV2'
type MockS3Manager_ListObjectsV2_Call struct {
	*mock.Call
}

// ListObjectsV2 is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.ListObjectsV2Input
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) ListObjectsV2(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_ListObjectsV2_Call {
	return &MockS3Manager_ListObjectsV2_Call{Call: _e.mock.On("ListObjectsV2",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_ListObjectsV2_Call) Run(run func(ctx context.Context, params *s3.ListObjectsV2Input, optFns ...func(*s3.Options))) *MockS3Manager_ListObjectsV2_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.ListObjectsV2Input
		if args[1] != nil {
			arg1 = args[1].(*s3.ListObjectsV2Input)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_ListObjectsV2_Call) Return(listObjectsV2Output *s3.ListObjectsV2Output, err error) *MockS3Manager_ListObjectsV2_Call {
	_c.Call.Return(listObjectsV2Output, err)
	return _c
}

func (_c *MockS3Manager_ListObjectsV2_Call) RunAndReturn(run func(ctx context.Context, params *s3.ListObjectsV2Input, optFns ...func(*s3.Options)) (*s3.ListObjectsV2Output, error)) *MockS3Manager_ListObjectsV2_Call {
	_c.Call.Return(run)
	return _c
}

// ListParts provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) ListParts(ctx context.Context, params *s3.ListPartsInput, optFns ...func(*s3.Options)) (*s3.ListPartsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListParts")
	}

	var r0 *s3.ListPartsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListPartsInput, ...func(*s3.Options)) (*s3.ListPartsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.ListPartsInput, ...func(*s3.Options)) *s3.ListPartsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.ListPartsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.ListPartsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_ListParts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListParts'
type MockS3Manager_ListParts_Call struct {
	*mock.Call
}

// ListParts is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.ListPartsInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) ListParts(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_ListParts_Call {
	return &MockS3Manager_ListParts_Call{Call: _e.mock.On("ListParts",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_ListParts_Call) Run(run func(ctx context.Context, params *s3.ListPartsInput, optFns ...func(*s3.Options))) *MockS3Manager_ListParts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.ListPartsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.ListPartsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_ListParts_Call) Return(listPartsOutput *s3.ListPartsOutput, err error) *MockS3Manager_ListParts_Call {
	_c.Call.Return(listPartsOutput, err)
	return _c
}

func (_c *MockS3Manager_ListParts_Call) RunAndReturn(run func(ctx context.Context, params *s3.ListPartsInput, optFns ...func(*s3.Options)) (*s3.ListPartsOutput, error)) *MockS3Manager_ListParts_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketAccelerateConfiguration provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutBucketAccelerateConfiguration(ctx context.Context, params *s3.PutBucketAccelerateConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketAccelerateConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketAccelerateConfiguration")
	}

	var r0 *s3.PutBucketAccelerateConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketAccelerateConfigurationInput, ...func(*s3.Options)) (*s3.PutBucketAccelerateConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketAccelerateConfigurationInput, ...func(*s3.Options)) *s3.PutBucketAccelerateConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketAccelerateConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketAccelerateConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutBucketAccelerateConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketAccelerateConfiguration'
type MockS3Manager_PutBucketAccelerateConfiguration_Call struct {
	*mock.Call
}

// PutBucketAccelerateConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketAccelerateConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutBucketAccelerateConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutBucketAccelerateConfiguration_Call {
	return &MockS3Manager_PutBucketAccelerateConfiguration_Call{Call: _e.mock.On("PutBucketAccelerateConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutBucketAccelerateConfiguration_Call) Run(run func(ctx context.Context, params *s3.PutBucketAccelerateConfigurationInput, optFns ...func(*s3.Options))) *MockS3Manager_PutBucketAccelerateConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketAccelerateConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketAccelerateConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutBucketAccelerateConfiguration_Call) Return(putBucketAccelerateConfigurationOutput *s3.PutBucketAccelerateConfigurationOutput, err error) *MockS3Manager_PutBucketAccelerateConfiguration_Call {
	_c.Call.Return(putBucketAccelerateConfigurationOutput, err)
	return _c
}

func (_c *MockS3Manager_PutBucketAccelerateConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketAccelerateConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketAccelerateConfigurationOutput, error)) *MockS3Manager_PutBucketAccelerateConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketAcl provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutBucketAcl(ctx context.Context, params *s3.PutBucketAclInput, optFns ...func(*s3.Options)) (*s3.PutBucketAclOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketAcl")
	}

	var r0 *s3.PutBucketAclOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketAclInput, ...func(*s3.Options)) (*s3.PutBucketAclOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketAclInput, ...func(*s3.Options)) *s3.PutBucketAclOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketAclOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketAclInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutBucketAcl_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketAcl'
type MockS3Manager_PutBucketAcl_Call struct {
	*mock.Call
}

// PutBucketAcl is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketAclInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutBucketAcl(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutBucketAcl_Call {
	return &MockS3Manager_PutBucketAcl_Call{Call: _e.mock.On("PutBucketAcl",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutBucketAcl_Call) Run(run func(ctx context.Context, params *s3.PutBucketAclInput, optFns ...func(*s3.Options))) *MockS3Manager_PutBucketAcl_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketAclInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketAclInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutBucketAcl_Call) Return(putBucketAclOutput *s3.PutBucketAclOutput, err error) *MockS3Manager_PutBucketAcl_Call {
	_c.Call.Return(putBucketAclOutput, err)
	return _c
}

func (_c *MockS3Manager_PutBucketAcl_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketAclInput, optFns ...func(*s3.Options)) (*s3.PutBucketAclOutput, error)) *MockS3Manager_PutBucketAcl_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketAnalyticsConfiguration provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutBucketAnalyticsConfiguration(ctx context.Context, params *s3.PutBucketAnalyticsConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketAnalyticsConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketAnalyticsConfiguration")
	}

	var r0 *s3.PutBucketAnalyticsConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketAnalyticsConfigurationInput, ...func(*s3.Options)) (*s3.PutBucketAnalyticsConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketAnalyticsConfigurationInput, ...func(*s3.Options)) *s3.PutBucketAnalyticsConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketAnalyticsConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketAnalyticsConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutBucketAnalyticsConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketAnalyticsConfiguration'
type MockS3Manager_PutBucketAnalyticsConfiguration_Call struct {
	*mock.Call
}

// PutBucketAnalyticsConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketAnalyticsConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutBucketAnalyticsConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutBucketAnalyticsConfiguration_Call {
	return &MockS3Manager_PutBucketAnalyticsConfiguration_Call{Call: _e.mock.On("PutBucketAnalyticsConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutBucketAnalyticsConfiguration_Call) Run(run func(ctx context.Context, params *s3.PutBucketAnalyticsConfigurationInput, optFns ...func(*s3.Options))) *MockS3Manager_PutBucketAnalyticsConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketAnalyticsConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketAnalyticsConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutBucketAnalyticsConfiguration_Call) Return(putBucketAnalyticsConfigurationOutput *s3.PutBucketAnalyticsConfigurationOutput, err error) *MockS3Manager_PutBucketAnalyticsConfiguration_Call {
	_c.Call.Return(putBucketAnalyticsConfigurationOutput, err)
	return _c
}

func (_c *MockS3Manager_PutBucketAnalyticsConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketAnalyticsConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketAnalyticsConfigurationOutput, error)) *MockS3Manager_PutBucketAnalyticsConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketCors provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutBucketCors(ctx context.Context, params *s3.PutBucketCorsInput, optFns ...func(*s3.Options)) (*s3.PutBucketCorsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketCors")
	}

	var r0 *s3.PutBucketCorsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketCorsInput, ...func(*s3.Options)) (*s3.PutBucketCorsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketCorsInput, ...func(*s3.Options)) *s3.PutBucketCorsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketCorsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketCorsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutBucketCors_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketCors'
type MockS3Manager_PutBucketCors_Call struct {
	*mock.Call
}

// PutBucketCors is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketCorsInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutBucketCors(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutBucketCors_Call {
	return &MockS3Manager_PutBucketCors_Call{Call: _e.mock.On("PutBucketCors",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutBucketCors_Call) Run(run func(ctx context.Context, params *s3.PutBucketCorsInput, optFns ...func(*s3.Options))) *MockS3Manager_PutBucketCors_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketCorsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketCorsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutBucketCors_Call) Return(putBucketCorsOutput *s3.PutBucketCorsOutput, err error) *MockS3Manager_PutBucketCors_Call {
	_c.Call.Return(putBucketCorsOutput, err)
	return _c
}

func (_c *MockS3Manager_PutBucketCors_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketCorsInput, optFns ...func(*s3.Options)) (*s3.PutBucketCorsOutput, error)) *MockS3Manager_PutBucketCors_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketEncryption provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutBucketEncryption(ctx context.Context, params *s3.PutBucketEncryptionInput, optFns ...func(*s3.Options)) (*s3.PutBucketEncryptionOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketEncryption")
	}

	var r0 *s3.PutBucketEncryptionOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketEncryptionInput, ...func(*s3.Options)) (*s3.PutBucketEncryptionOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketEncryptionInput, ...func(*s3.Options)) *s3.PutBucketEncryptionOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketEncryptionOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketEncryptionInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutBucketEncryption_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketEncryption'
type MockS3Manager_PutBucketEncryption_Call struct {
	*mock.Call
}

// PutBucketEncryption is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketEncryptionInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutBucketEncryption(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutBucketEncryption_Call {
	return &MockS3Manager_PutBucketEncryption_Call{Call: _e.mock.On("PutBucketEncryption",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutBucketEncryption_Call) Run(run func(ctx context.Context, params *s3.PutBucketEncryptionInput, optFns ...func(*s3.Options))) *MockS3Manager_PutBucketEncryption_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketEncryptionInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketEncryptionInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutBucketEncryption_Call) Return(putBucketEncryptionOutput *s3.PutBucketEncryptionOutput, err error) *MockS3Manager_PutBucketEncryption_Call {
	_c.Call.Return(putBucketEncryptionOutput, err)
	return _c
}

func (_c *MockS3Manager_PutBucketEncryption_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketEncryptionInput, optFns ...func(*s3.Options)) (*s3.PutBucketEncryptionOutput, error)) *MockS3Manager_PutBucketEncryption_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketIntelligentTieringConfiguration provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutBucketIntelligentTieringConfiguration(ctx context.Context, params *s3.PutBucketIntelligentTieringConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketIntelligentTieringConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketIntelligentTieringConfiguration")
	}

	var r0 *s3.PutBucketIntelligentTieringConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketIntelligentTieringConfigurationInput, ...func(*s3.Options)) (*s3.PutBucketIntelligentTieringConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketIntelligentTieringConfigurationInput, ...func(*s3.Options)) *s3.PutBucketIntelligentTieringConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketIntelligentTieringConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketIntelligentTieringConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutBucketIntelligentTieringConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketIntelligentTieringConfiguration'
type MockS3Manager_PutBucketIntelligentTieringConfiguration_Call struct {
	*mock.Call
}

// PutBucketIntelligentTieringConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketIntelligentTieringConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutBucketIntelligentTieringConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutBucketIntelligentTieringConfiguration_Call {
	return &MockS3Manager_PutBucketIntelligentTieringConfiguration_Call{Call: _e.mock.On("PutBucketIntelligentTieringConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutBucketIntelligentTieringConfiguration_Call) Run(run func(ctx context.Context, params *s3.PutBucketIntelligentTieringConfigurationInput, optFns ...func(*s3.Options))) *MockS3Manager_PutBucketIntelligentTieringConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketIntelligentTieringConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketIntelligentTieringConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutBucketIntelligentTieringConfiguration_Call) Return(putBucketIntelligentTieringConfigurationOutput *s3.PutBucketIntelligentTieringConfigurationOutput, err error) *MockS3Manager_PutBucketIntelligentTieringConfiguration_Call {
	_c.Call.Return(putBucketIntelligentTieringConfigurationOutput, err)
	return _c
}

func (_c *MockS3Manager_PutBucketIntelligentTieringConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketIntelligentTieringConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketIntelligentTieringConfigurationOutput, error)) *MockS3Manager_PutBucketIntelligentTieringConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketInventoryConfiguration provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutBucketInventoryConfiguration(ctx context.Context, params *s3.PutBucketInventoryConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketInventoryConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketInventoryConfiguration")
	}

	var r0 *s3.PutBucketInventoryConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketInventoryConfigurationInput, ...func(*s3.Options)) (*s3.PutBucketInventoryConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketInventoryConfigurationInput, ...func(*s3.Options)) *s3.PutBucketInventoryConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketInventoryConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketInventoryConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutBucketInventoryConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketInventoryConfiguration'
type MockS3Manager_PutBucketInventoryConfiguration_Call struct {
	*mock.Call
}

// PutBucketInventoryConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketInventoryConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutBucketInventoryConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutBucketInventoryConfiguration_Call {
	return &MockS3Manager_PutBucketInventoryConfiguration_Call{Call: _e.mock.On("PutBucketInventoryConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutBucketInventoryConfiguration_Call) Run(run func(ctx context.Context, params *s3.PutBucketInventoryConfigurationInput, optFns ...func(*s3.Options))) *MockS3Manager_PutBucketInventoryConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketInventoryConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketInventoryConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutBucketInventoryConfiguration_Call) Return(putBucketInventoryConfigurationOutput *s3.PutBucketInventoryConfigurationOutput, err error) *MockS3Manager_PutBucketInventoryConfiguration_Call {
	_c.Call.Return(putBucketInventoryConfigurationOutput, err)
	return _c
}

func (_c *MockS3Manager_PutBucketInventoryConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketInventoryConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketInventoryConfigurationOutput, error)) *MockS3Manager_PutBucketInventoryConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketLifecycleConfiguration provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutBucketLifecycleConfiguration(ctx context.Context, params *s3.PutBucketLifecycleConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketLifecycleConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketLifecycleConfiguration")
	}

	var r0 *s3.PutBucketLifecycleConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketLifecycleConfigurationInput, ...func(*s3.Options)) (*s3.PutBucketLifecycleConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketLifecycleConfigurationInput, ...func(*s3.Options)) *s3.PutBucketLifecycleConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketLifecycleConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketLifecycleConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutBucketLifecycleConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketLifecycleConfiguration'
type MockS3Manager_PutBucketLifecycleConfiguration_Call struct {
	*mock.Call
}

// PutBucketLifecycleConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketLifecycleConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutBucketLifecycleConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutBucketLifecycleConfiguration_Call {
	return &MockS3Manager_PutBucketLifecycleConfiguration_Call{Call: _e.mock.On("PutBucketLifecycleConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutBucketLifecycleConfiguration_Call) Run(run func(ctx context.Context, params *s3.PutBucketLifecycleConfigurationInput, optFns ...func(*s3.Options))) *MockS3Manager_PutBucketLifecycleConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketLifecycleConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketLifecycleConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutBucketLifecycleConfiguration_Call) Return(putBucketLifecycleConfigurationOutput *s3.PutBucketLifecycleConfigurationOutput, err error) *MockS3Manager_PutBucketLifecycleConfiguration_Call {
	_c.Call.Return(putBucketLifecycleConfigurationOutput, err)
	return _c
}

func (_c *MockS3Manager_PutBucketLifecycleConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketLifecycleConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketLifecycleConfigurationOutput, error)) *MockS3Manager_PutBucketLifecycleConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketLogging provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutBucketLogging(ctx context.Context, params *s3.PutBucketLoggingInput, optFns ...func(*s3.Options)) (*s3.PutBucketLoggingOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketLogging")
	}

	var r0 *s3.PutBucketLoggingOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketLoggingInput, ...func(*s3.Options)) (*s3.PutBucketLoggingOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketLoggingInput, ...func(*s3.Options)) *s3.PutBucketLoggingOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketLoggingOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketLoggingInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutBucketLogging_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketLogging'
type MockS3Manager_PutBucketLogging_Call struct {
	*mock.Call
}

// PutBucketLogging is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketLoggingInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutBucketLogging(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutBucketLogging_Call {
	return &MockS3Manager_PutBucketLogging_Call{Call: _e.mock.On("PutBucketLogging",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutBucketLogging_Call) Run(run func(ctx context.Context, params *s3.PutBucketLoggingInput, optFns ...func(*s3.Options))) *MockS3Manager_PutBucketLogging_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketLoggingInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketLoggingInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutBucketLogging_Call) Return(putBucketLoggingOutput *s3.PutBucketLoggingOutput, err error) *MockS3Manager_PutBucketLogging_Call {
	_c.Call.Return(putBucketLoggingOutput, err)
	return _c
}

func (_c *MockS3Manager_PutBucketLogging_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketLoggingInput, optFns ...func(*s3.Options)) (*s3.PutBucketLoggingOutput, error)) *MockS3Manager_PutBucketLogging_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketMetricsConfiguration provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutBucketMetricsConfiguration(ctx context.Context, params *s3.PutBucketMetricsConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketMetricsConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketMetricsConfiguration")
	}

	var r0 *s3.PutBucketMetricsConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketMetricsConfigurationInput, ...func(*s3.Options)) (*s3.PutBucketMetricsConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketMetricsConfigurationInput, ...func(*s3.Options)) *s3.PutBucketMetricsConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketMetricsConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketMetricsConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutBucketMetricsConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketMetricsConfiguration'
type MockS3Manager_PutBucketMetricsConfiguration_Call struct {
	*mock.Call
}

// PutBucketMetricsConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketMetricsConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutBucketMetricsConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutBucketMetricsConfiguration_Call {
	return &MockS3Manager_PutBucketMetricsConfiguration_Call{Call: _e.mock.On("PutBucketMetricsConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutBucketMetricsConfiguration_Call) Run(run func(ctx context.Context, params *s3.PutBucketMetricsConfigurationInput, optFns ...func(*s3.Options))) *MockS3Manager_PutBucketMetricsConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketMetricsConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketMetricsConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutBucketMetricsConfiguration_Call) Return(putBucketMetricsConfigurationOutput *s3.PutBucketMetricsConfigurationOutput, err error) *MockS3Manager_PutBucketMetricsConfiguration_Call {
	_c.Call.Return(putBucketMetricsConfigurationOutput, err)
	return _c
}

func (_c *MockS3Manager_PutBucketMetricsConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketMetricsConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketMetricsConfigurationOutput, error)) *MockS3Manager_PutBucketMetricsConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketNotificationConfiguration provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutBucketNotificationConfiguration(ctx context.Context, params *s3.PutBucketNotificationConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketNotificationConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketNotificationConfiguration")
	}

	var r0 *s3.PutBucketNotificationConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketNotificationConfigurationInput, ...func(*s3.Options)) (*s3.PutBucketNotificationConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketNotificationConfigurationInput, ...func(*s3.Options)) *s3.PutBucketNotificationConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketNotificationConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketNotificationConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutBucketNotificationConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketNotificationConfiguration'
type MockS3Manager_PutBucketNotificationConfiguration_Call struct {
	*mock.Call
}

// PutBucketNotificationConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketNotificationConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutBucketNotificationConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutBucketNotificationConfiguration_Call {
	return &MockS3Manager_PutBucketNotificationConfiguration_Call{Call: _e.mock.On("PutBucketNotificationConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutBucketNotificationConfiguration_Call) Run(run func(ctx context.Context, params *s3.PutBucketNotificationConfigurationInput, optFns ...func(*s3.Options))) *MockS3Manager_PutBucketNotificationConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketNotificationConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketNotificationConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutBucketNotificationConfiguration_Call) Return(putBucketNotificationConfigurationOutput *s3.PutBucketNotificationConfigurationOutput, err error) *MockS3Manager_PutBucketNotificationConfiguration_Call {
	_c.Call.Return(putBucketNotificationConfigurationOutput, err)
	return _c
}

func (_c *MockS3Manager_PutBucketNotificationConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketNotificationConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutBucketNotificationConfigurationOutput, error)) *MockS3Manager_PutBucketNotificationConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketOwnershipControls provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutBucketOwnershipControls(ctx context.Context, params *s3.PutBucketOwnershipControlsInput, optFns ...func(*s3.Options)) (*s3.PutBucketOwnershipControlsOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketOwnershipControls")
	}

	var r0 *s3.PutBucketOwnershipControlsOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketOwnershipControlsInput, ...func(*s3.Options)) (*s3.PutBucketOwnershipControlsOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketOwnershipControlsInput, ...func(*s3.Options)) *s3.PutBucketOwnershipControlsOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketOwnershipControlsOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketOwnershipControlsInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutBucketOwnershipControls_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketOwnershipControls'
type MockS3Manager_PutBucketOwnershipControls_Call struct {
	*mock.Call
}

// PutBucketOwnershipControls is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketOwnershipControlsInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutBucketOwnershipControls(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutBucketOwnershipControls_Call {
	return &MockS3Manager_PutBucketOwnershipControls_Call{Call: _e.mock.On("PutBucketOwnershipControls",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutBucketOwnershipControls_Call) Run(run func(ctx context.Context, params *s3.PutBucketOwnershipControlsInput, optFns ...func(*s3.Options))) *MockS3Manager_PutBucketOwnershipControls_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketOwnershipControlsInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketOwnershipControlsInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutBucketOwnershipControls_Call) Return(putBucketOwnershipControlsOutput *s3.PutBucketOwnershipControlsOutput, err error) *MockS3Manager_PutBucketOwnershipControls_Call {
	_c.Call.Return(putBucketOwnershipControlsOutput, err)
	return _c
}

func (_c *MockS3Manager_PutBucketOwnershipControls_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketOwnershipControlsInput, optFns ...func(*s3.Options)) (*s3.PutBucketOwnershipControlsOutput, error)) *MockS3Manager_PutBucketOwnershipControls_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketPolicy provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutBucketPolicy(ctx context.Context, params *s3.PutBucketPolicyInput, optFns ...func(*s3.Options)) (*s3.PutBucketPolicyOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketPolicy")
	}

	var r0 *s3.PutBucketPolicyOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketPolicyInput, ...func(*s3.Options)) (*s3.PutBucketPolicyOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketPolicyInput, ...func(*s3.Options)) *s3.PutBucketPolicyOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketPolicyOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketPolicyInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutBucketPolicy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketPolicy'
type MockS3Manager_PutBucketPolicy_Call struct {
	*mock.Call
}

// PutBucketPolicy is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketPolicyInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutBucketPolicy(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutBucketPolicy_Call {
	return &MockS3Manager_PutBucketPolicy_Call{Call: _e.mock.On("PutBucketPolicy",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutBucketPolicy_Call) Run(run func(ctx context.Context, params *s3.PutBucketPolicyInput, optFns ...func(*s3.Options))) *MockS3Manager_PutBucketPolicy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketPolicyInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketPolicyInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutBucketPolicy_Call) Return(putBucketPolicyOutput *s3.PutBucketPolicyOutput, err error) *MockS3Manager_PutBucketPolicy_Call {
	_c.Call.Return(putBucketPolicyOutput, err)
	return _c
}

func (_c *MockS3Manager_PutBucketPolicy_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketPolicyInput, optFns ...func(*s3.Options)) (*s3.PutBucketPolicyOutput, error)) *MockS3Manager_PutBucketPolicy_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketReplication provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutBucketReplication(ctx context.Context, params *s3.PutBucketReplicationInput, optFns ...func(*s3.Options)) (*s3.PutBucketReplicationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketReplication")
	}

	var r0 *s3.PutBucketReplicationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketReplicationInput, ...func(*s3.Options)) (*s3.PutBucketReplicationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketReplicationInput, ...func(*s3.Options)) *s3.PutBucketReplicationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketReplicationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketReplicationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutBucketReplication_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketReplication'
type MockS3Manager_PutBucketReplication_Call struct {
	*mock.Call
}

// PutBucketReplication is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketReplicationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutBucketReplication(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutBucketReplication_Call {
	return &MockS3Manager_PutBucketReplication_Call{Call: _e.mock.On("PutBucketReplication",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutBucketReplication_Call) Run(run func(ctx context.Context, params *s3.PutBucketReplicationInput, optFns ...func(*s3.Options))) *MockS3Manager_PutBucketReplication_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketReplicationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketReplicationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutBucketReplication_Call) Return(putBucketReplicationOutput *s3.PutBucketReplicationOutput, err error) *MockS3Manager_PutBucketReplication_Call {
	_c.Call.Return(putBucketReplicationOutput, err)
	return _c
}

func (_c *MockS3Manager_PutBucketReplication_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketReplicationInput, optFns ...func(*s3.Options)) (*s3.PutBucketReplicationOutput, error)) *MockS3Manager_PutBucketReplication_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketRequestPayment provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutBucketRequestPayment(ctx context.Context, params *s3.PutBucketRequestPaymentInput, optFns ...func(*s3.Options)) (*s3.PutBucketRequestPaymentOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketRequestPayment")
	}

	var r0 *s3.PutBucketRequestPaymentOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketRequestPaymentInput, ...func(*s3.Options)) (*s3.PutBucketRequestPaymentOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketRequestPaymentInput, ...func(*s3.Options)) *s3.PutBucketRequestPaymentOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketRequestPaymentOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketRequestPaymentInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutBucketRequestPayment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketRequestPayment'
type MockS3Manager_PutBucketRequestPayment_Call struct {
	*mock.Call
}

// PutBucketRequestPayment is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketRequestPaymentInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutBucketRequestPayment(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutBucketRequestPayment_Call {
	return &MockS3Manager_PutBucketRequestPayment_Call{Call: _e.mock.On("PutBucketRequestPayment",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutBucketRequestPayment_Call) Run(run func(ctx context.Context, params *s3.PutBucketRequestPaymentInput, optFns ...func(*s3.Options))) *MockS3Manager_PutBucketRequestPayment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketRequestPaymentInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketRequestPaymentInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutBucketRequestPayment_Call) Return(putBucketRequestPaymentOutput *s3.PutBucketRequestPaymentOutput, err error) *MockS3Manager_PutBucketRequestPayment_Call {
	_c.Call.Return(putBucketRequestPaymentOutput, err)
	return _c
}

func (_c *MockS3Manager_PutBucketRequestPayment_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketRequestPaymentInput, optFns ...func(*s3.Options)) (*s3.PutBucketRequestPaymentOutput, error)) *MockS3Manager_PutBucketRequestPayment_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketTagging provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutBucketTagging(ctx context.Context, params *s3.PutBucketTaggingInput, optFns ...func(*s3.Options)) (*s3.PutBucketTaggingOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketTagging")
	}

	var r0 *s3.PutBucketTaggingOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketTaggingInput, ...func(*s3.Options)) (*s3.PutBucketTaggingOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketTaggingInput, ...func(*s3.Options)) *s3.PutBucketTaggingOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketTaggingOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketTaggingInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutBucketTagging_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketTagging'
type MockS3Manager_PutBucketTagging_Call struct {
	*mock.Call
}

// PutBucketTagging is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketTaggingInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutBucketTagging(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutBucketTagging_Call {
	return &MockS3Manager_PutBucketTagging_Call{Call: _e.mock.On("PutBucketTagging",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutBucketTagging_Call) Run(run func(ctx context.Context, params *s3.PutBucketTaggingInput, optFns ...func(*s3.Options))) *MockS3Manager_PutBucketTagging_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketTaggingInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketTaggingInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutBucketTagging_Call) Return(putBucketTaggingOutput *s3.PutBucketTaggingOutput, err error) *MockS3Manager_PutBucketTagging_Call {
	_c.Call.Return(putBucketTaggingOutput, err)
	return _c
}

func (_c *MockS3Manager_PutBucketTagging_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketTaggingInput, optFns ...func(*s3.Options)) (*s3.PutBucketTaggingOutput, error)) *MockS3Manager_PutBucketTagging_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketVersioning provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutBucketVersioning(ctx context.Context, params *s3.PutBucketVersioningInput, optFns ...func(*s3.Options)) (*s3.PutBucketVersioningOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketVersioning")
	}

	var r0 *s3.PutBucketVersioningOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketVersioningInput, ...func(*s3.Options)) (*s3.PutBucketVersioningOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketVersioningInput, ...func(*s3.Options)) *s3.PutBucketVersioningOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketVersioningOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketVersioningInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutBucketVersioning_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketVersioning'
type MockS3Manager_PutBucketVersioning_Call struct {
	*mock.Call
}

// PutBucketVersioning is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketVersioningInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutBucketVersioning(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutBucketVersioning_Call {
	return &MockS3Manager_PutBucketVersioning_Call{Call: _e.mock.On("PutBucketVersioning",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutBucketVersioning_Call) Run(run func(ctx context.Context, params *s3.PutBucketVersioningInput, optFns ...func(*s3.Options))) *MockS3Manager_PutBucketVersioning_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketVersioningInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketVersioningInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutBucketVersioning_Call) Return(putBucketVersioningOutput *s3.PutBucketVersioningOutput, err error) *MockS3Manager_PutBucketVersioning_Call {
	_c.Call.Return(putBucketVersioningOutput, err)
	return _c
}

func (_c *MockS3Manager_PutBucketVersioning_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketVersioningInput, optFns ...func(*s3.Options)) (*s3.PutBucketVersioningOutput, error)) *MockS3Manager_PutBucketVersioning_Call {
	_c.Call.Return(run)
	return _c
}

// PutBucketWebsite provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutBucketWebsite(ctx context.Context, params *s3.PutBucketWebsiteInput, optFns ...func(*s3.Options)) (*s3.PutBucketWebsiteOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutBucketWebsite")
	}

	var r0 *s3.PutBucketWebsiteOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketWebsiteInput, ...func(*s3.Options)) (*s3.PutBucketWebsiteOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutBucketWebsiteInput, ...func(*s3.Options)) *s3.PutBucketWebsiteOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutBucketWebsiteOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutBucketWebsiteInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutBucketWebsite_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutBucketWebsite'
type MockS3Manager_PutBucketWebsite_Call struct {
	*mock.Call
}

// PutBucketWebsite is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutBucketWebsiteInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutBucketWebsite(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutBucketWebsite_Call {
	return &MockS3Manager_PutBucketWebsite_Call{Call: _e.mock.On("PutBucketWebsite",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutBucketWebsite_Call) Run(run func(ctx context.Context, params *s3.PutBucketWebsiteInput, optFns ...func(*s3.Options))) *MockS3Manager_PutBucketWebsite_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutBucketWebsiteInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutBucketWebsiteInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutBucketWebsite_Call) Return(putBucketWebsiteOutput *s3.PutBucketWebsiteOutput, err error) *MockS3Manager_PutBucketWebsite_Call {
	_c.Call.Return(putBucketWebsiteOutput, err)
	return _c
}

func (_c *MockS3Manager_PutBucketWebsite_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutBucketWebsiteInput, optFns ...func(*s3.Options)) (*s3.PutBucketWebsiteOutput, error)) *MockS3Manager_PutBucketWebsite_Call {
	_c.Call.Return(run)
	return _c
}

// PutObject provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutObject(ctx context.Context, params *s3.PutObjectInput, optFns ...func(*s3.Options)) (*s3.PutObjectOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutObject")
	}

	var r0 *s3.PutObjectOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectInput, ...func(*s3.Options)) (*s3.PutObjectOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectInput, ...func(*s3.Options)) *s3.PutObjectOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutObjectOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutObjectInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutObject'
type MockS3Manager_PutObject_Call struct {
	*mock.Call
}

// PutObject is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutObjectInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutObject(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutObject_Call {
	return &MockS3Manager_PutObject_Call{Call: _e.mock.On("PutObject",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutObject_Call) Run(run func(ctx context.Context, params *s3.PutObjectInput, optFns ...func(*s3.Options))) *MockS3Manager_PutObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutObjectInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutObjectInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutObject_Call) Return(putObjectOutput *s3.PutObjectOutput, err error) *MockS3Manager_PutObject_Call {
	_c.Call.Return(putObjectOutput, err)
	return _c
}

func (_c *MockS3Manager_PutObject_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutObjectInput, optFns ...func(*s3.Options)) (*s3.PutObjectOutput, error)) *MockS3Manager_PutObject_Call {
	_c.Call.Return(run)
	return _c
}

// PutObjectAcl provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutObjectAcl(ctx context.Context, params *s3.PutObjectAclInput, optFns ...func(*s3.Options)) (*s3.PutObjectAclOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutObjectAcl")
	}

	var r0 *s3.PutObjectAclOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectAclInput, ...func(*s3.Options)) (*s3.PutObjectAclOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectAclInput, ...func(*s3.Options)) *s3.PutObjectAclOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutObjectAclOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutObjectAclInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutObjectAcl_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutObjectAcl'
type MockS3Manager_PutObjectAcl_Call struct {
	*mock.Call
}

// PutObjectAcl is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutObjectAclInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutObjectAcl(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutObjectAcl_Call {
	return &MockS3Manager_PutObjectAcl_Call{Call: _e.mock.On("PutObjectAcl",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutObjectAcl_Call) Run(run func(ctx context.Context, params *s3.PutObjectAclInput, optFns ...func(*s3.Options))) *MockS3Manager_PutObjectAcl_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutObjectAclInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutObjectAclInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutObjectAcl_Call) Return(putObjectAclOutput *s3.PutObjectAclOutput, err error) *MockS3Manager_PutObjectAcl_Call {
	_c.Call.Return(putObjectAclOutput, err)
	return _c
}

func (_c *MockS3Manager_PutObjectAcl_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutObjectAclInput, optFns ...func(*s3.Options)) (*s3.PutObjectAclOutput, error)) *MockS3Manager_PutObjectAcl_Call {
	_c.Call.Return(run)
	return _c
}

// PutObjectLegalHold provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutObjectLegalHold(ctx context.Context, params *s3.PutObjectLegalHoldInput, optFns ...func(*s3.Options)) (*s3.PutObjectLegalHoldOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutObjectLegalHold")
	}

	var r0 *s3.PutObjectLegalHoldOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectLegalHoldInput, ...func(*s3.Options)) (*s3.PutObjectLegalHoldOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectLegalHoldInput, ...func(*s3.Options)) *s3.PutObjectLegalHoldOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutObjectLegalHoldOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutObjectLegalHoldInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutObjectLegalHold_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutObjectLegalHold'
type MockS3Manager_PutObjectLegalHold_Call struct {
	*mock.Call
}

// PutObjectLegalHold is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutObjectLegalHoldInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutObjectLegalHold(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutObjectLegalHold_Call {
	return &MockS3Manager_PutObjectLegalHold_Call{Call: _e.mock.On("PutObjectLegalHold",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutObjectLegalHold_Call) Run(run func(ctx context.Context, params *s3.PutObjectLegalHoldInput, optFns ...func(*s3.Options))) *MockS3Manager_PutObjectLegalHold_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutObjectLegalHoldInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutObjectLegalHoldInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutObjectLegalHold_Call) Return(putObjectLegalHoldOutput *s3.PutObjectLegalHoldOutput, err error) *MockS3Manager_PutObjectLegalHold_Call {
	_c.Call.Return(putObjectLegalHoldOutput, err)
	return _c
}

func (_c *MockS3Manager_PutObjectLegalHold_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutObjectLegalHoldInput, optFns ...func(*s3.Options)) (*s3.PutObjectLegalHoldOutput, error)) *MockS3Manager_PutObjectLegalHold_Call {
	_c.Call.Return(run)
	return _c
}

// PutObjectLockConfiguration provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutObjectLockConfiguration(ctx context.Context, params *s3.PutObjectLockConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutObjectLockConfigurationOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutObjectLockConfiguration")
	}

	var r0 *s3.PutObjectLockConfigurationOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectLockConfigurationInput, ...func(*s3.Options)) (*s3.PutObjectLockConfigurationOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectLockConfigurationInput, ...func(*s3.Options)) *s3.PutObjectLockConfigurationOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutObjectLockConfigurationOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutObjectLockConfigurationInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutObjectLockConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutObjectLockConfiguration'
type MockS3Manager_PutObjectLockConfiguration_Call struct {
	*mock.Call
}

// PutObjectLockConfiguration is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutObjectLockConfigurationInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutObjectLockConfiguration(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutObjectLockConfiguration_Call {
	return &MockS3Manager_PutObjectLockConfiguration_Call{Call: _e.mock.On("PutObjectLockConfiguration",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutObjectLockConfiguration_Call) Run(run func(ctx context.Context, params *s3.PutObjectLockConfigurationInput, optFns ...func(*s3.Options))) *MockS3Manager_PutObjectLockConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutObjectLockConfigurationInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutObjectLockConfigurationInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutObjectLockConfiguration_Call) Return(putObjectLockConfigurationOutput *s3.PutObjectLockConfigurationOutput, err error) *MockS3Manager_PutObjectLockConfiguration_Call {
	_c.Call.Return(putObjectLockConfigurationOutput, err)
	return _c
}

func (_c *MockS3Manager_PutObjectLockConfiguration_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutObjectLockConfigurationInput, optFns ...func(*s3.Options)) (*s3.PutObjectLockConfigurationOutput, error)) *MockS3Manager_PutObjectLockConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// PutObjectRetention provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutObjectRetention(ctx context.Context, params *s3.PutObjectRetentionInput, optFns ...func(*s3.Options)) (*s3.PutObjectRetentionOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutObjectRetention")
	}

	var r0 *s3.PutObjectRetentionOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectRetentionInput, ...func(*s3.Options)) (*s3.PutObjectRetentionOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectRetentionInput, ...func(*s3.Options)) *s3.PutObjectRetentionOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutObjectRetentionOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutObjectRetentionInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutObjectRetention_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutObjectRetention'
type MockS3Manager_PutObjectRetention_Call struct {
	*mock.Call
}

// PutObjectRetention is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutObjectRetentionInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutObjectRetention(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutObjectRetention_Call {
	return &MockS3Manager_PutObjectRetention_Call{Call: _e.mock.On("PutObjectRetention",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutObjectRetention_Call) Run(run func(ctx context.Context, params *s3.PutObjectRetentionInput, optFns ...func(*s3.Options))) *MockS3Manager_PutObjectRetention_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutObjectRetentionInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutObjectRetentionInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutObjectRetention_Call) Return(putObjectRetentionOutput *s3.PutObjectRetentionOutput, err error) *MockS3Manager_PutObjectRetention_Call {
	_c.Call.Return(putObjectRetentionOutput, err)
	return _c
}

func (_c *MockS3Manager_PutObjectRetention_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutObjectRetentionInput, optFns ...func(*s3.Options)) (*s3.PutObjectRetentionOutput, error)) *MockS3Manager_PutObjectRetention_Call {
	_c.Call.Return(run)
	return _c
}

// PutObjectTagging provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutObjectTagging(ctx context.Context, params *s3.PutObjectTaggingInput, optFns ...func(*s3.Options)) (*s3.PutObjectTaggingOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutObjectTagging")
	}

	var r0 *s3.PutObjectTaggingOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectTaggingInput, ...func(*s3.Options)) (*s3.PutObjectTaggingOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectTaggingInput, ...func(*s3.Options)) *s3.PutObjectTaggingOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutObjectTaggingOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutObjectTaggingInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutObjectTagging_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutObjectTagging'
type MockS3Manager_PutObjectTagging_Call struct {
	*mock.Call
}

// PutObjectTagging is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutObjectTaggingInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutObjectTagging(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutObjectTagging_Call {
	return &MockS3Manager_PutObjectTagging_Call{Call: _e.mock.On("PutObjectTagging",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutObjectTagging_Call) Run(run func(ctx context.Context, params *s3.PutObjectTaggingInput, optFns ...func(*s3.Options))) *MockS3Manager_PutObjectTagging_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutObjectTaggingInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutObjectTaggingInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutObjectTagging_Call) Return(putObjectTaggingOutput *s3.PutObjectTaggingOutput, err error) *MockS3Manager_PutObjectTagging_Call {
	_c.Call.Return(putObjectTaggingOutput, err)
	return _c
}

func (_c *MockS3Manager_PutObjectTagging_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutObjectTaggingInput, optFns ...func(*s3.Options)) (*s3.PutObjectTaggingOutput, error)) *MockS3Manager_PutObjectTagging_Call {
	_c.Call.Return(run)
	return _c
}

// PutPublicAccessBlock provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) PutPublicAccessBlock(ctx context.Context, params *s3.PutPublicAccessBlockInput, optFns ...func(*s3.Options)) (*s3.PutPublicAccessBlockOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PutPublicAccessBlock")
	}

	var r0 *s3.PutPublicAccessBlockOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutPublicAccessBlockInput, ...func(*s3.Options)) (*s3.PutPublicAccessBlockOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutPublicAccessBlockInput, ...func(*s3.Options)) *s3.PutPublicAccessBlockOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.PutPublicAccessBlockOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutPublicAccessBlockInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_PutPublicAccessBlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PutPublicAccessBlock'
type MockS3Manager_PutPublicAccessBlock_Call struct {
	*mock.Call
}

// PutPublicAccessBlock is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutPublicAccessBlockInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) PutPublicAccessBlock(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_PutPublicAccessBlock_Call {
	return &MockS3Manager_PutPublicAccessBlock_Call{Call: _e.mock.On("PutPublicAccessBlock",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_PutPublicAccessBlock_Call) Run(run func(ctx context.Context, params *s3.PutPublicAccessBlockInput, optFns ...func(*s3.Options))) *MockS3Manager_PutPublicAccessBlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutPublicAccessBlockInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutPublicAccessBlockInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_PutPublicAccessBlock_Call) Return(putPublicAccessBlockOutput *s3.PutPublicAccessBlockOutput, err error) *MockS3Manager_PutPublicAccessBlock_Call {
	_c.Call.Return(putPublicAccessBlockOutput, err)
	return _c
}

func (_c *MockS3Manager_PutPublicAccessBlock_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutPublicAccessBlockInput, optFns ...func(*s3.Options)) (*s3.PutPublicAccessBlockOutput, error)) *MockS3Manager_PutPublicAccessBlock_Call {
	_c.Call.Return(run)
	return _c
}

// RestoreObject provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) RestoreObject(ctx context.Context, params *s3.RestoreObjectInput, optFns ...func(*s3.Options)) (*s3.RestoreObjectOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for RestoreObject")
	}

	var r0 *s3.RestoreObjectOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.RestoreObjectInput, ...func(*s3.Options)) (*s3.RestoreObjectOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.RestoreObjectInput, ...func(*s3.Options)) *s3.RestoreObjectOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.RestoreObjectOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.RestoreObjectInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_RestoreObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestoreObject'
type MockS3Manager_RestoreObject_Call struct {
	*mock.Call
}

// RestoreObject is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.RestoreObjectInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) RestoreObject(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_RestoreObject_Call {
	return &MockS3Manager_RestoreObject_Call{Call: _e.mock.On("RestoreObject",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_RestoreObject_Call) Run(run func(ctx context.Context, params *s3.RestoreObjectInput, optFns ...func(*s3.Options))) *MockS3Manager_RestoreObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.RestoreObjectInput
		if args[1] != nil {
			arg1 = args[1].(*s3.RestoreObjectInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_RestoreObject_Call) Return(restoreObjectOutput *s3.RestoreObjectOutput, err error) *MockS3Manager_RestoreObject_Call {
	_c.Call.Return(restoreObjectOutput, err)
	return _c
}

func (_c *MockS3Manager_RestoreObject_Call) RunAndReturn(run func(ctx context.Context, params *s3.RestoreObjectInput, optFns ...func(*s3.Options)) (*s3.RestoreObjectOutput, error)) *MockS3Manager_RestoreObject_Call {
	_c.Call.Return(run)
	return _c
}

// SelectObjectContent provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) SelectObjectContent(ctx context.Context, params *s3.SelectObjectContentInput, optFns ...func(*s3.Options)) (*s3.SelectObjectContentOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for SelectObjectContent")
	}

	var r0 *s3.SelectObjectContentOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.SelectObjectContentInput, ...func(*s3.Options)) (*s3.SelectObjectContentOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.SelectObjectContentInput, ...func(*s3.Options)) *s3.SelectObjectContentOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.SelectObjectContentOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.SelectObjectContentInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_SelectObjectContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SelectObjectContent'
type MockS3Manager_SelectObjectContent_Call struct {
	*mock.Call
}

// SelectObjectContent is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.SelectObjectContentInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) SelectObjectContent(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_SelectObjectContent_Call {
	return &MockS3Manager_SelectObjectContent_Call{Call: _e.mock.On("SelectObjectContent",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_SelectObjectContent_Call) Run(run func(ctx context.Context, params *s3.SelectObjectContentInput, optFns ...func(*s3.Options))) *MockS3Manager_SelectObjectContent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.SelectObjectContentInput
		if args[1] != nil {
			arg1 = args[1].(*s3.SelectObjectContentInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_SelectObjectContent_Call) Return(selectObjectContentOutput *s3.SelectObjectContentOutput, err error) *MockS3Manager_SelectObjectContent_Call {
	_c.Call.Return(selectObjectContentOutput, err)
	return _c
}

func (_c *MockS3Manager_SelectObjectContent_Call) RunAndReturn(run func(ctx context.Context, params *s3.SelectObjectContentInput, optFns ...func(*s3.Options)) (*s3.SelectObjectContentOutput, error)) *MockS3Manager_SelectObjectContent_Call {
	_c.Call.Return(run)
	return _c
}

// UploadPart provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) UploadPart(ctx context.Context, params *s3.UploadPartInput, optFns ...func(*s3.Options)) (*s3.UploadPartOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for UploadPart")
	}

	var r0 *s3.UploadPartOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.UploadPartInput, ...func(*s3.Options)) (*s3.UploadPartOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.UploadPartInput, ...func(*s3.Options)) *s3.UploadPartOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.UploadPartOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.UploadPartInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_UploadPart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UploadPart'
type MockS3Manager_UploadPart_Call struct {
	*mock.Call
}

// UploadPart is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.UploadPartInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) UploadPart(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_UploadPart_Call {
	return &MockS3Manager_UploadPart_Call{Call: _e.mock.On("UploadPart",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_UploadPart_Call) Run(run func(ctx context.Context, params *s3.UploadPartInput, optFns ...func(*s3.Options))) *MockS3Manager_UploadPart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.UploadPartInput
		if args[1] != nil {
			arg1 = args[1].(*s3.UploadPartInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_UploadPart_Call) Return(uploadPartOutput *s3.UploadPartOutput, err error) *MockS3Manager_UploadPart_Call {
	_c.Call.Return(uploadPartOutput, err)
	return _c
}

func (_c *MockS3Manager_UploadPart_Call) RunAndReturn(run func(ctx context.Context, params *s3.UploadPartInput, optFns ...func(*s3.Options)) (*s3.UploadPartOutput, error)) *MockS3Manager_UploadPart_Call {
	_c.Call.Return(run)
	return _c
}

// UploadPartCopy provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) UploadPartCopy(ctx context.Context, params *s3.UploadPartCopyInput, optFns ...func(*s3.Options)) (*s3.UploadPartCopyOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for UploadPartCopy")
	}

	var r0 *s3.UploadPartCopyOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.UploadPartCopyInput, ...func(*s3.Options)) (*s3.UploadPartCopyOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.UploadPartCopyInput, ...func(*s3.Options)) *s3.UploadPartCopyOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.UploadPartCopyOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.UploadPartCopyInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_UploadPartCopy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UploadPartCopy'
type MockS3Manager_UploadPartCopy_Call struct {
	*mock.Call
}

// UploadPartCopy is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.UploadPartCopyInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) UploadPartCopy(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_UploadPartCopy_Call {
	return &MockS3Manager_UploadPartCopy_Call{Call: _e.mock.On("UploadPartCopy",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_UploadPartCopy_Call) Run(run func(ctx context.Context, params *s3.UploadPartCopyInput, optFns ...func(*s3.Options))) *MockS3Manager_UploadPartCopy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.UploadPartCopyInput
		if args[1] != nil {
			arg1 = args[1].(*s3.UploadPartCopyInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_UploadPartCopy_Call) Return(uploadPartCopyOutput *s3.UploadPartCopyOutput, err error) *MockS3Manager_UploadPartCopy_Call {
	_c.Call.Return(uploadPartCopyOutput, err)
	return _c
}

func (_c *MockS3Manager_UploadPartCopy_Call) RunAndReturn(run func(ctx context.Context, params *s3.UploadPartCopyInput, optFns ...func(*s3.Options)) (*s3.UploadPartCopyOutput, error)) *MockS3Manager_UploadPartCopy_Call {
	_c.Call.Return(run)
	return _c
}

// WriteGetObjectResponse provides a mock function for the type MockS3Manager
func (_mock *MockS3Manager) WriteGetObjectResponse(ctx context.Context, params *s3.WriteGetObjectResponseInput, optFns ...func(*s3.Options)) (*s3.WriteGetObjectResponseOutput, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for WriteGetObjectResponse")
	}

	var r0 *s3.WriteGetObjectResponseOutput
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.WriteGetObjectResponseInput, ...func(*s3.Options)) (*s3.WriteGetObjectResponseOutput, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.WriteGetObjectResponseInput, ...func(*s3.Options)) *s3.WriteGetObjectResponseOutput); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*s3.WriteGetObjectResponseOutput)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.WriteGetObjectResponseInput, ...func(*s3.Options)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockS3Manager_WriteGetObjectResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteGetObjectResponse'
type MockS3Manager_WriteGetObjectResponse_Call struct {
	*mock.Call
}

// WriteGetObjectResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.WriteGetObjectResponseInput
//   - optFns ...func(*s3.Options)
func (_e *MockS3Manager_Expecter) WriteGetObjectResponse(ctx interface{}, params interface{}, optFns ...interface{}) *MockS3Manager_WriteGetObjectResponse_Call {
	return &MockS3Manager_WriteGetObjectResponse_Call{Call: _e.mock.On("WriteGetObjectResponse",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockS3Manager_WriteGetObjectResponse_Call) Run(run func(ctx context.Context, params *s3.WriteGetObjectResponseInput, optFns ...func(*s3.Options))) *MockS3Manager_WriteGetObjectResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.WriteGetObjectResponseInput
		if args[1] != nil {
			arg1 = args[1].(*s3.WriteGetObjectResponseInput)
		}
		var arg2 []func(*s3.Options)
		var variadicArgs []func(*s3.Options)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.Options))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockS3Manager_WriteGetObjectResponse_Call) Return(writeGetObjectResponseOutput *s3.WriteGetObjectResponseOutput, err error) *MockS3Manager_WriteGetObjectResponse_Call {
	_c.Call.Return(writeGetObjectResponseOutput, err)
	return _c
}

func (_c *MockS3Manager_WriteGetObjectResponse_Call) RunAndReturn(run func(ctx context.Context, params *s3.WriteGetObjectResponseInput, optFns ...func(*s3.Options)) (*s3.WriteGetObjectResponseOutput, error)) *MockS3Manager_WriteGetObjectResponse_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockPresigner creates a new instance of MockPresigner. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockPresigner(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockPresigner {
	mock := &MockPresigner{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockPresigner is an autogenerated mock type for the Presigner type
type MockPresigner struct {
	mock.Mock
}

type MockPresigner_Expecter struct {
	mock *mock.Mock
}

func (_m *MockPresigner) EXPECT() *MockPresigner_Expecter {
	return &MockPresigner_Expecter{mock: &_m.Mock}
}

// PresignGetObject provides a mock function for the type MockPresigner
func (_mock *MockPresigner) PresignGetObject(ctx context.Context, params *s3.GetObjectInput, optFns ...func(*s3.PresignOptions)) (*v4.PresignedHTTPRequest, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PresignGetObject")
	}

	var r0 *v4.PresignedHTTPRequest
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectInput, ...func(*s3.PresignOptions)) (*v4.PresignedHTTPRequest, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.GetObjectInput, ...func(*s3.PresignOptions)) *v4.PresignedHTTPRequest); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v4.PresignedHTTPRequest)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.GetObjectInput, ...func(*s3.PresignOptions)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPresigner_PresignGetObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PresignGetObject'
type MockPresigner_PresignGetObject_Call struct {
	*mock.Call
}

// PresignGetObject is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.GetObjectInput
//   - optFns ...func(*s3.PresignOptions)
func (_e *MockPresigner_Expecter) PresignGetObject(ctx interface{}, params interface{}, optFns ...interface{}) *MockPresigner_PresignGetObject_Call {
	return &MockPresigner_PresignGetObject_Call{Call: _e.mock.On("PresignGetObject",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockPresigner_PresignGetObject_Call) Run(run func(ctx context.Context, params *s3.GetObjectInput, optFns ...func(*s3.PresignOptions))) *MockPresigner_PresignGetObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.GetObjectInput
		if args[1] != nil {
			arg1 = args[1].(*s3.GetObjectInput)
		}
		var arg2 []func(*s3.PresignOptions)
		var variadicArgs []func(*s3.PresignOptions)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.PresignOptions))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockPresigner_PresignGetObject_Call) Return(presignedHTTPRequest *v4.PresignedHTTPRequest, err error) *MockPresigner_PresignGetObject_Call {
	_c.Call.Return(presignedHTTPRequest, err)
	return _c
}

func (_c *MockPresigner_PresignGetObject_Call) RunAndReturn(run func(ctx context.Context, params *s3.GetObjectInput, optFns ...func(*s3.PresignOptions)) (*v4.PresignedHTTPRequest, error)) *MockPresigner_PresignGetObject_Call {
	_c.Call.Return(run)
	return _c
}

// PresignHeadObject provides a mock function for the type MockPresigner
func (_mock *MockPresigner) PresignHeadObject(ctx context.Context, params *s3.HeadObjectInput, optFns ...func(*s3.PresignOptions)) (*v4.PresignedHTTPRequest, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PresignHeadObject")
	}

	var r0 *v4.PresignedHTTPRequest
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.HeadObjectInput, ...func(*s3.PresignOptions)) (*v4.PresignedHTTPRequest, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.HeadObjectInput, ...func(*s3.PresignOptions)) *v4.PresignedHTTPRequest); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v4.PresignedHTTPRequest)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.HeadObjectInput, ...func(*s3.PresignOptions)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPresigner_PresignHeadObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PresignHeadObject'
type MockPresigner_PresignHeadObject_Call struct {
	*mock.Call
}

// PresignHeadObject is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.HeadObjectInput
//   - optFns ...func(*s3.PresignOptions)
func (_e *MockPresigner_Expecter) PresignHeadObject(ctx interface{}, params interface{}, optFns ...interface{}) *MockPresigner_PresignHeadObject_Call {
	return &MockPresigner_PresignHeadObject_Call{Call: _e.mock.On("PresignHeadObject",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockPresigner_PresignHeadObject_Call) Run(run func(ctx context.Context, params *s3.HeadObjectInput, optFns ...func(*s3.PresignOptions))) *MockPresigner_PresignHeadObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.HeadObjectInput
		if args[1] != nil {
			arg1 = args[1].(*s3.HeadObjectInput)
		}
		var arg2 []func(*s3.PresignOptions)
		var variadicArgs []func(*s3.PresignOptions)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.PresignOptions))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockPresigner_PresignHeadObject_Call) Return(presignedHTTPRequest *v4.PresignedHTTPRequest, err error) *MockPresigner_PresignHeadObject_Call {
	_c.Call.Return(presignedHTTPRequest, err)
	return _c
}

func (_c *MockPresigner_PresignHeadObject_Call) RunAndReturn(run func(ctx context.Context, params *s3.HeadObjectInput, optFns ...func(*s3.PresignOptions)) (*v4.PresignedHTTPRequest, error)) *MockPresigner_PresignHeadObject_Call {
	_c.Call.Return(run)
	return _c
}

// PresignPutObject provides a mock function for the type MockPresigner
func (_mock *MockPresigner) PresignPutObject(ctx context.Context, params *s3.PutObjectInput, optFns ...func(*s3.PresignOptions)) (*v4.PresignedHTTPRequest, error) {
	var tmpRet mock.Arguments
	if len(optFns) > 0 {
		tmpRet = _mock.Called(ctx, params, optFns)
	} else {
		tmpRet = _mock.Called(ctx, params)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for PresignPutObject")
	}

	var r0 *v4.PresignedHTTPRequest
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectInput, ...func(*s3.PresignOptions)) (*v4.PresignedHTTPRequest, error)); ok {
		return returnFunc(ctx, params, optFns...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *s3.PutObjectInput, ...func(*s3.PresignOptions)) *v4.PresignedHTTPRequest); ok {
		r0 = returnFunc(ctx, params, optFns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v4.PresignedHTTPRequest)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *s3.PutObjectInput, ...func(*s3.PresignOptions)) error); ok {
		r1 = returnFunc(ctx, params, optFns...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockPresigner_PresignPutObject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PresignPutObject'
type MockPresigner_PresignPutObject_Call struct {
	*mock.Call
}

// PresignPutObject is a helper method to define mock.On call
//   - ctx context.Context
//   - params *s3.PutObjectInput
//   - optFns ...func(*s3.PresignOptions)
func (_e *MockPresigner_Expecter) PresignPutObject(ctx interface{}, params interface{}, optFns ...interface{}) *MockPresigner_PresignPutObject_Call {
	return &MockPresigner_PresignPutObject_Call{Call: _e.mock.On("PresignPutObject",
		append([]interface{}{ctx, params}, optFns...)...)}
}

func (_c *MockPresigner_PresignPutObject_Call) Run(run func(ctx context.Context, params *s3.PutObjectInput, optFns ...func(*s3.PresignOptions))) *MockPresigner_PresignPutObject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *s3.PutObjectInput
		if args[1] != nil {
			arg1 = args[1].(*s3.PutObjectInput)
		}
		var arg2 []func(*s3.PresignOptions)
		var variadicArgs []func(*s3.PresignOptions)
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*s3.PresignOptions))
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockPresigner_PresignPutObject_Call) Return(presignedHTTPRequest *v4.PresignedHTTPRequest, err error) *MockPresigner_PresignPutObject_Call {
	_c.Call.Return(presignedHTTPRequest, err)
	return _c
}

func (_c *MockPresigner_PresignPutObject_Call) RunAndReturn(run func(ctx context.Context, params *s3.PutObjectInput, optFns ...func(*s3.PresignOptions)) (*v4.PresignedHTTPRequest, error)) *MockPresigner_PresignPutObject_Call {
	_c.Call.Return(run)
	return _c
}
