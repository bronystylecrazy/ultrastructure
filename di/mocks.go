// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package di

import (
	"reflect"

	mock "github.com/stretchr/testify/mock"
	"go.uber.org/fx"
)

// NewMockNode creates a new instance of MockNode. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockNode(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockNode {
	mock := &MockNode{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockNode is an autogenerated mock type for the Node type
type MockNode struct {
	mock.Mock
}

type MockNode_Expecter struct {
	mock *mock.Mock
}

func (_m *MockNode) EXPECT() *MockNode_Expecter {
	return &MockNode_Expecter{mock: &_m.Mock}
}

// Build provides a mock function for the type MockNode
func (_mock *MockNode) Build() (fx.Option, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Build")
	}

	var r0 fx.Option
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (fx.Option, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() fx.Option); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(fx.Option)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockNode_Build_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Build'
type MockNode_Build_Call struct {
	*mock.Call
}

// Build is a helper method to define mock.On call
func (_e *MockNode_Expecter) Build() *MockNode_Build_Call {
	return &MockNode_Build_Call{Call: _e.mock.On("Build")}
}

func (_c *MockNode_Build_Call) Run(run func()) *MockNode_Build_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockNode_Build_Call) Return(option fx.Option, err error) *MockNode_Build_Call {
	_c.Call.Return(option, err)
	return _c
}

func (_c *MockNode_Build_Call) RunAndReturn(run func() (fx.Option, error)) *MockNode_Build_Call {
	_c.Call.Return(run)
	return _c
}

// newMockautoGroupApplier creates a new instance of mockautoGroupApplier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockautoGroupApplier(t interface {
	mock.TestingT
	Cleanup(func())
}) *mockautoGroupApplier {
	mock := &mockautoGroupApplier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mockautoGroupApplier is an autogenerated mock type for the autoGroupApplier type
type mockautoGroupApplier struct {
	mock.Mock
}

type mockautoGroupApplier_Expecter struct {
	mock *mock.Mock
}

func (_m *mockautoGroupApplier) EXPECT() *mockautoGroupApplier_Expecter {
	return &mockautoGroupApplier_Expecter{mock: &_m.Mock}
}

// withAutoGroups provides a mock function for the type mockautoGroupApplier
func (_mock *mockautoGroupApplier) withAutoGroups(autoGroupSetMoqParam autoGroupSet) Node {
	ret := _mock.Called(autoGroupSetMoqParam)

	if len(ret) == 0 {
		panic("no return value specified for withAutoGroups")
	}

	var r0 Node
	if returnFunc, ok := ret.Get(0).(func(autoGroupSet) Node); ok {
		r0 = returnFunc(autoGroupSetMoqParam)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Node)
		}
	}
	return r0
}

// mockautoGroupApplier_withAutoGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'withAutoGroups'
type mockautoGroupApplier_withAutoGroups_Call struct {
	*mock.Call
}

// withAutoGroups is a helper method to define mock.On call
//   - autoGroupSetMoqParam autoGroupSet
func (_e *mockautoGroupApplier_Expecter) withAutoGroups(autoGroupSetMoqParam interface{}) *mockautoGroupApplier_withAutoGroups_Call {
	return &mockautoGroupApplier_withAutoGroups_Call{Call: _e.mock.On("withAutoGroups", autoGroupSetMoqParam)}
}

func (_c *mockautoGroupApplier_withAutoGroups_Call) Run(run func(autoGroupSetMoqParam autoGroupSet)) *mockautoGroupApplier_withAutoGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 autoGroupSet
		if args[0] != nil {
			arg0 = args[0].(autoGroupSet)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mockautoGroupApplier_withAutoGroups_Call) Return(node Node) *mockautoGroupApplier_withAutoGroups_Call {
	_c.Call.Return(node)
	return _c
}

func (_c *mockautoGroupApplier_withAutoGroups_Call) RunAndReturn(run func(autoGroupSetMoqParam autoGroupSet) Node) *mockautoGroupApplier_withAutoGroups_Call {
	_c.Call.Return(run)
	return _c
}

// newMockautoInjectApplier creates a new instance of mockautoInjectApplier. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockautoInjectApplier(t interface {
	mock.TestingT
	Cleanup(func())
}) *mockautoInjectApplier {
	mock := &mockautoInjectApplier{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mockautoInjectApplier is an autogenerated mock type for the autoInjectApplier type
type mockautoInjectApplier struct {
	mock.Mock
}

type mockautoInjectApplier_Expecter struct {
	mock *mock.Mock
}

func (_m *mockautoInjectApplier) EXPECT() *mockautoInjectApplier_Expecter {
	return &mockautoInjectApplier_Expecter{mock: &_m.Mock}
}

// withAutoInjectFields provides a mock function for the type mockautoInjectApplier
func (_mock *mockautoInjectApplier) withAutoInjectFields(b bool) Node {
	ret := _mock.Called(b)

	if len(ret) == 0 {
		panic("no return value specified for withAutoInjectFields")
	}

	var r0 Node
	if returnFunc, ok := ret.Get(0).(func(bool) Node); ok {
		r0 = returnFunc(b)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Node)
		}
	}
	return r0
}

// mockautoInjectApplier_withAutoInjectFields_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'withAutoInjectFields'
type mockautoInjectApplier_withAutoInjectFields_Call struct {
	*mock.Call
}

// withAutoInjectFields is a helper method to define mock.On call
//   - b bool
func (_e *mockautoInjectApplier_Expecter) withAutoInjectFields(b interface{}) *mockautoInjectApplier_withAutoInjectFields_Call {
	return &mockautoInjectApplier_withAutoInjectFields_Call{Call: _e.mock.On("withAutoInjectFields", b)}
}

func (_c *mockautoInjectApplier_withAutoInjectFields_Call) Run(run func(b bool)) *mockautoInjectApplier_withAutoInjectFields_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 bool
		if args[0] != nil {
			arg0 = args[0].(bool)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mockautoInjectApplier_withAutoInjectFields_Call) Return(node Node) *mockautoInjectApplier_withAutoInjectFields_Call {
	_c.Call.Return(node)
	return _c
}

func (_c *mockautoInjectApplier_withAutoInjectFields_Call) RunAndReturn(run func(b bool) Node) *mockautoInjectApplier_withAutoInjectFields_Call {
	_c.Call.Return(run)
	return _c
}

// newMockconfigTarget creates a new instance of mockconfigTarget. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockconfigTarget(t interface {
	mock.TestingT
	Cleanup(func())
}) *mockconfigTarget {
	mock := &mockconfigTarget{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mockconfigTarget is an autogenerated mock type for the configTarget type
type mockconfigTarget struct {
	mock.Mock
}

type mockconfigTarget_Expecter struct {
	mock *mock.Mock
}

func (_m *mockconfigTarget) EXPECT() *mockconfigTarget_Expecter {
	return &mockconfigTarget_Expecter{mock: &_m.Mock}
}

// configTarget provides a mock function for the type mockconfigTarget
func (_mock *mockconfigTarget) configTarget() (string, string, configConfig, bool) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for configTarget")
	}

	var r0 string
	var r1 string
	var r2 configConfig
	var r3 bool
	if returnFunc, ok := ret.Get(0).(func() (string, string, configConfig, bool)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func() string); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Get(1).(string)
	}
	if returnFunc, ok := ret.Get(2).(func() configConfig); ok {
		r2 = returnFunc()
	} else {
		r2 = ret.Get(2).(configConfig)
	}
	if returnFunc, ok := ret.Get(3).(func() bool); ok {
		r3 = returnFunc()
	} else {
		r3 = ret.Get(3).(bool)
	}
	return r0, r1, r2, r3
}

// mockconfigTarget_configTarget_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'configTarget'
type mockconfigTarget_configTarget_Call struct {
	*mock.Call
}

// configTarget is a helper method to define mock.On call
func (_e *mockconfigTarget_Expecter) configTarget() *mockconfigTarget_configTarget_Call {
	return &mockconfigTarget_configTarget_Call{Call: _e.mock.On("configTarget")}
}

func (_c *mockconfigTarget_configTarget_Call) Run(run func()) *mockconfigTarget_configTarget_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *mockconfigTarget_configTarget_Call) Return(path string, key string, cfg configConfig, ok bool) *mockconfigTarget_configTarget_Call {
	_c.Call.Return(path, key, cfg, ok)
	return _c
}

func (_c *mockconfigTarget_configTarget_Call) RunAndReturn(run func() (string, string, configConfig, bool)) *mockconfigTarget_configTarget_Call {
	_c.Call.Return(run)
	return _c
}

// configType provides a mock function for the type mockconfigTarget
func (_mock *mockconfigTarget) configType() reflect.Type {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for configType")
	}

	var r0 reflect.Type
	if returnFunc, ok := ret.Get(0).(func() reflect.Type); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(reflect.Type)
		}
	}
	return r0
}

// mockconfigTarget_configType_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'configType'
type mockconfigTarget_configType_Call struct {
	*mock.Call
}

// configType is a helper method to define mock.On call
func (_e *mockconfigTarget_Expecter) configType() *mockconfigTarget_configType_Call {
	return &mockconfigTarget_configType_Call{Call: _e.mock.On("configType")}
}

func (_c *mockconfigTarget_configType_Call) Run(run func()) *mockconfigTarget_configType_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *mockconfigTarget_configType_Call) Return(typeParam reflect.Type) *mockconfigTarget_configType_Call {
	_c.Call.Return(typeParam)
	return _c
}

func (_c *mockconfigTarget_configType_Call) RunAndReturn(run func() reflect.Type) *mockconfigTarget_configType_Call {
	_c.Call.Return(run)
	return _c
}

// newMockconfigSource creates a new instance of mockconfigSource. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockconfigSource(t interface {
	mock.TestingT
	Cleanup(func())
}) *mockconfigSource {
	mock := &mockconfigSource{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mockconfigSource is an autogenerated mock type for the configSource type
type mockconfigSource struct {
	mock.Mock
}

type mockconfigSource_Expecter struct {
	mock *mock.Mock
}

func (_m *mockconfigSource) EXPECT() *mockconfigSource_Expecter {
	return &mockconfigSource_Expecter{mock: &_m.Mock}
}

// configSource provides a mock function for the type mockconfigSource
func (_mock *mockconfigSource) configSource() (string, configConfig, bool) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for configSource")
	}

	var r0 string
	var r1 configConfig
	var r2 bool
	if returnFunc, ok := ret.Get(0).(func() (string, configConfig, bool)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func() configConfig); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Get(1).(configConfig)
	}
	if returnFunc, ok := ret.Get(2).(func() bool); ok {
		r2 = returnFunc()
	} else {
		r2 = ret.Get(2).(bool)
	}
	return r0, r1, r2
}

// mockconfigSource_configSource_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'configSource'
type mockconfigSource_configSource_Call struct {
	*mock.Call
}

// configSource is a helper method to define mock.On call
func (_e *mockconfigSource_Expecter) configSource() *mockconfigSource_configSource_Call {
	return &mockconfigSource_configSource_Call{Call: _e.mock.On("configSource")}
}

func (_c *mockconfigSource_configSource_Call) Run(run func()) *mockconfigSource_configSource_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *mockconfigSource_configSource_Call) Return(path string, cfg configConfig, ok bool) *mockconfigSource_configSource_Call {
	_c.Call.Return(path, cfg, ok)
	return _c
}

func (_c *mockconfigSource_configSource_Call) RunAndReturn(run func() (string, configConfig, bool)) *mockconfigSource_configSource_Call {
	_c.Call.Return(run)
	return _c
}

// newMockconfigScoper creates a new instance of mockconfigScoper. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockconfigScoper(t interface {
	mock.TestingT
	Cleanup(func())
}) *mockconfigScoper {
	mock := &mockconfigScoper{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mockconfigScoper is an autogenerated mock type for the configScoper type
type mockconfigScoper struct {
	mock.Mock
}

type mockconfigScoper_Expecter struct {
	mock *mock.Mock
}

func (_m *mockconfigScoper) EXPECT() *mockconfigScoper_Expecter {
	return &mockconfigScoper_Expecter{mock: &_m.Mock}
}

// withConfigScope provides a mock function for the type mockconfigScoper
func (_mock *mockconfigScoper) withConfigScope(s string) Node {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for withConfigScope")
	}

	var r0 Node
	if returnFunc, ok := ret.Get(0).(func(string) Node); ok {
		r0 = returnFunc(s)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Node)
		}
	}
	return r0
}

// mockconfigScoper_withConfigScope_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'withConfigScope'
type mockconfigScoper_withConfigScope_Call struct {
	*mock.Call
}

// withConfigScope is a helper method to define mock.On call
//   - s string
func (_e *mockconfigScoper_Expecter) withConfigScope(s interface{}) *mockconfigScoper_withConfigScope_Call {
	return &mockconfigScoper_withConfigScope_Call{Call: _e.mock.On("withConfigScope", s)}
}

func (_c *mockconfigScoper_withConfigScope_Call) Run(run func(s string)) *mockconfigScoper_withConfigScope_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mockconfigScoper_withConfigScope_Call) Return(node Node) *mockconfigScoper_withConfigScope_Call {
	_c.Call.Return(node)
	return _c
}

func (_c *mockconfigScoper_withConfigScope_Call) RunAndReturn(run func(s string) Node) *mockconfigScoper_withConfigScope_Call {
	_c.Call.Return(run)
	return _c
}

// newMockconfigOption creates a new instance of mockconfigOption. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockconfigOption(t interface {
	mock.TestingT
	Cleanup(func())
}) *mockconfigOption {
	mock := &mockconfigOption{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mockconfigOption is an autogenerated mock type for the configOption type
type mockconfigOption struct {
	mock.Mock
}

type mockconfigOption_Expecter struct {
	mock *mock.Mock
}

func (_m *mockconfigOption) EXPECT() *mockconfigOption_Expecter {
	return &mockconfigOption_Expecter{mock: &_m.Mock}
}

// applyConfig provides a mock function for the type mockconfigOption
func (_mock *mockconfigOption) applyConfig(configConfigMoqParam *configConfig) {
	_mock.Called(configConfigMoqParam)
	return
}

// mockconfigOption_applyConfig_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'applyConfig'
type mockconfigOption_applyConfig_Call struct {
	*mock.Call
}

// applyConfig is a helper method to define mock.On call
//   - configConfigMoqParam *configConfig
func (_e *mockconfigOption_Expecter) applyConfig(configConfigMoqParam interface{}) *mockconfigOption_applyConfig_Call {
	return &mockconfigOption_applyConfig_Call{Call: _e.mock.On("applyConfig", configConfigMoqParam)}
}

func (_c *mockconfigOption_applyConfig_Call) Run(run func(configConfigMoqParam *configConfig)) *mockconfigOption_applyConfig_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *configConfig
		if args[0] != nil {
			arg0 = args[0].(*configConfig)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *mockconfigOption_applyConfig_Call) Return() *mockconfigOption_applyConfig_Call {
	_c.Call.Return()
	return _c
}

func (_c *mockconfigOption_applyConfig_Call) RunAndReturn(run func(configConfigMoqParam *configConfig)) *mockconfigOption_applyConfig_Call {
	_c.Run(run)
	return _c
}

// NewMockConfigWatchOption creates a new instance of MockConfigWatchOption. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockConfigWatchOption(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockConfigWatchOption {
	mock := &MockConfigWatchOption{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockConfigWatchOption is an autogenerated mock type for the ConfigWatchOption type
type MockConfigWatchOption struct {
	mock.Mock
}

type MockConfigWatchOption_Expecter struct {
	mock *mock.Mock
}

func (_m *MockConfigWatchOption) EXPECT() *MockConfigWatchOption_Expecter {
	return &MockConfigWatchOption_Expecter{mock: &_m.Mock}
}

// applyWatch provides a mock function for the type MockConfigWatchOption
func (_mock *MockConfigWatchOption) applyWatch(configWatchConfigMoqParam *configWatchConfig) {
	_mock.Called(configWatchConfigMoqParam)
	return
}

// MockConfigWatchOption_applyWatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'applyWatch'
type MockConfigWatchOption_applyWatch_Call struct {
	*mock.Call
}

// applyWatch is a helper method to define mock.On call
//   - configWatchConfigMoqParam *configWatchConfig
func (_e *MockConfigWatchOption_Expecter) applyWatch(configWatchConfigMoqParam interface{}) *MockConfigWatchOption_applyWatch_Call {
	return &MockConfigWatchOption_applyWatch_Call{Call: _e.mock.On("applyWatch", configWatchConfigMoqParam)}
}

func (_c *MockConfigWatchOption_applyWatch_Call) Run(run func(configWatchConfigMoqParam *configWatchConfig)) *MockConfigWatchOption_applyWatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *configWatchConfig
		if args[0] != nil {
			arg0 = args[0].(*configWatchConfig)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockConfigWatchOption_applyWatch_Call) Return() *MockConfigWatchOption_applyWatch_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockConfigWatchOption_applyWatch_Call) RunAndReturn(run func(configWatchConfigMoqParam *configWatchConfig)) *MockConfigWatchOption_applyWatch_Call {
	_c.Run(run)
	return _c
}

// newMockerrorWithGraph creates a new instance of mockerrorWithGraph. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockerrorWithGraph(t interface {
	mock.TestingT
	Cleanup(func())
}) *mockerrorWithGraph {
	mock := &mockerrorWithGraph{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// mockerrorWithGraph is an autogenerated mock type for the errorWithGraph type
type mockerrorWithGraph struct {
	mock.Mock
}

type mockerrorWithGraph_Expecter struct {
	mock *mock.Mock
}

func (_m *mockerrorWithGraph) EXPECT() *mockerrorWithGraph_Expecter {
	return &mockerrorWithGraph_Expecter{mock: &_m.Mock}
}

// Graph provides a mock function for the type mockerrorWithGraph
func (_mock *mockerrorWithGraph) Graph() fx.DotGraph {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Graph")
	}

	var r0 fx.DotGraph
	if returnFunc, ok := ret.Get(0).(func() fx.DotGraph); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(fx.DotGraph)
	}
	return r0
}

// mockerrorWithGraph_Graph_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Graph'
type mockerrorWithGraph_Graph_Call struct {
	*mock.Call
}

// Graph is a helper method to define mock.On call
func (_e *mockerrorWithGraph_Expecter) Graph() *mockerrorWithGraph_Graph_Call {
	return &mockerrorWithGraph_Graph_Call{Call: _e.mock.On("Graph")}
}

func (_c *mockerrorWithGraph_Graph_Call) Run(run func()) *mockerrorWithGraph_Graph_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *mockerrorWithGraph_Graph_Call) Return(dotGraph fx.DotGraph) *mockerrorWithGraph_Graph_Call {
	_c.Call.Return(dotGraph)
	return _c
}

func (_c *mockerrorWithGraph_Graph_Call) RunAndReturn(run func() fx.DotGraph) *mockerrorWithGraph_Graph_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockOption creates a new instance of MockOption. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockOption(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockOption {
	mock := &MockOption{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockOption is an autogenerated mock type for the Option type
type MockOption struct {
	mock.Mock
}

type MockOption_Expecter struct {
	mock *mock.Mock
}

func (_m *MockOption) EXPECT() *MockOption_Expecter {
	return &MockOption_Expecter{mock: &_m.Mock}
}

// applyBind provides a mock function for the type MockOption
func (_mock *MockOption) applyBind(bindConfigMoqParam *bindConfig) {
	_mock.Called(bindConfigMoqParam)
	return
}

// MockOption_applyBind_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'applyBind'
type MockOption_applyBind_Call struct {
	*mock.Call
}

// applyBind is a helper method to define mock.On call
//   - bindConfigMoqParam *bindConfig
func (_e *MockOption_Expecter) applyBind(bindConfigMoqParam interface{}) *MockOption_applyBind_Call {
	return &MockOption_applyBind_Call{Call: _e.mock.On("applyBind", bindConfigMoqParam)}
}

func (_c *MockOption_applyBind_Call) Run(run func(bindConfigMoqParam *bindConfig)) *MockOption_applyBind_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *bindConfig
		if args[0] != nil {
			arg0 = args[0].(*bindConfig)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockOption_applyBind_Call) Return() *MockOption_applyBind_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockOption_applyBind_Call) RunAndReturn(run func(bindConfigMoqParam *bindConfig)) *MockOption_applyBind_Call {
	_c.Run(run)
	return _c
}

// applyParam provides a mock function for the type MockOption
func (_mock *MockOption) applyParam(paramConfigMoqParam *paramConfig) {
	_mock.Called(paramConfigMoqParam)
	return
}

// MockOption_applyParam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'applyParam'
type MockOption_applyParam_Call struct {
	*mock.Call
}

// applyParam is a helper method to define mock.On call
//   - paramConfigMoqParam *paramConfig
func (_e *MockOption_Expecter) applyParam(paramConfigMoqParam interface{}) *MockOption_applyParam_Call {
	return &MockOption_applyParam_Call{Call: _e.mock.On("applyParam", paramConfigMoqParam)}
}

func (_c *MockOption_applyParam_Call) Run(run func(paramConfigMoqParam *paramConfig)) *MockOption_applyParam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *paramConfig
		if args[0] != nil {
			arg0 = args[0].(*paramConfig)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockOption_applyParam_Call) Return() *MockOption_applyParam_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockOption_applyParam_Call) RunAndReturn(run func(paramConfigMoqParam *paramConfig)) *MockOption_applyParam_Call {
	_c.Run(run)
	return _c
}

// NewMockNodeOption creates a new instance of MockNodeOption. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockNodeOption(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockNodeOption {
	mock := &MockNodeOption{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockNodeOption is an autogenerated mock type for the NodeOption type
type MockNodeOption struct {
	mock.Mock
}

type MockNodeOption_Expecter struct {
	mock *mock.Mock
}

func (_m *MockNodeOption) EXPECT() *MockNodeOption_Expecter {
	return &MockNodeOption_Expecter{mock: &_m.Mock}
}

// Build provides a mock function for the type MockNodeOption
func (_mock *MockNodeOption) Build() (fx.Option, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Build")
	}

	var r0 fx.Option
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (fx.Option, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() fx.Option); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(fx.Option)
		}
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockNodeOption_Build_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Build'
type MockNodeOption_Build_Call struct {
	*mock.Call
}

// Build is a helper method to define mock.On call
func (_e *MockNodeOption_Expecter) Build() *MockNodeOption_Build_Call {
	return &MockNodeOption_Build_Call{Call: _e.mock.On("Build")}
}

func (_c *MockNodeOption_Build_Call) Run(run func()) *MockNodeOption_Build_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockNodeOption_Build_Call) Return(option fx.Option, err error) *MockNodeOption_Build_Call {
	_c.Call.Return(option, err)
	return _c
}

func (_c *MockNodeOption_Build_Call) RunAndReturn(run func() (fx.Option, error)) *MockNodeOption_Build_Call {
	_c.Call.Return(run)
	return _c
}

// applyBind provides a mock function for the type MockNodeOption
func (_mock *MockNodeOption) applyBind(bindConfigMoqParam *bindConfig) {
	_mock.Called(bindConfigMoqParam)
	return
}

// MockNodeOption_applyBind_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'applyBind'
type MockNodeOption_applyBind_Call struct {
	*mock.Call
}

// applyBind is a helper method to define mock.On call
//   - bindConfigMoqParam *bindConfig
func (_e *MockNodeOption_Expecter) applyBind(bindConfigMoqParam interface{}) *MockNodeOption_applyBind_Call {
	return &MockNodeOption_applyBind_Call{Call: _e.mock.On("applyBind", bindConfigMoqParam)}
}

func (_c *MockNodeOption_applyBind_Call) Run(run func(bindConfigMoqParam *bindConfig)) *MockNodeOption_applyBind_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *bindConfig
		if args[0] != nil {
			arg0 = args[0].(*bindConfig)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockNodeOption_applyBind_Call) Return() *MockNodeOption_applyBind_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockNodeOption_applyBind_Call) RunAndReturn(run func(bindConfigMoqParam *bindConfig)) *MockNodeOption_applyBind_Call {
	_c.Run(run)
	return _c
}

// applyParam provides a mock function for the type MockNodeOption
func (_mock *MockNodeOption) applyParam(paramConfigMoqParam *paramConfig) {
	_mock.Called(paramConfigMoqParam)
	return
}

// MockNodeOption_applyParam_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'applyParam'
type MockNodeOption_applyParam_Call struct {
	*mock.Call
}

// applyParam is a helper method to define mock.On call
//   - paramConfigMoqParam *paramConfig
func (_e *MockNodeOption_Expecter) applyParam(paramConfigMoqParam interface{}) *MockNodeOption_applyParam_Call {
	return &MockNodeOption_applyParam_Call{Call: _e.mock.On("applyParam", paramConfigMoqParam)}
}

func (_c *MockNodeOption_applyParam_Call) Run(run func(paramConfigMoqParam *paramConfig)) *MockNodeOption_applyParam_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *paramConfig
		if args[0] != nil {
			arg0 = args[0].(*paramConfig)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockNodeOption_applyParam_Call) Return() *MockNodeOption_applyParam_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockNodeOption_applyParam_Call) RunAndReturn(run func(paramConfigMoqParam *paramConfig)) *MockNodeOption_applyParam_Call {
	_c.Run(run)
	return _c
}
