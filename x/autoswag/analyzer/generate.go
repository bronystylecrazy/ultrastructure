package analyzer

import (
	"fmt"
	"regexp"
	"sort"
	"strconv"
	"strings"
)

type GenerateOptions struct {
	PackageName string
	FuncName    string
	ExactOnly   bool
	ToolVersion string
}

func GenerateHookSource(report *Report, opts GenerateOptions) (string, error) {
	if report == nil {
		return "", fmt.Errorf("report is nil")
	}
	pkgName := strings.TrimSpace(opts.PackageName)
	if pkgName == "" {
		pkgName = "autoswaggen"
	}
	funcName := strings.TrimSpace(opts.FuncName)
	if funcName == "" {
		funcName = "AutoSwagGenerator"
	}

	imports := map[string]string{
		"autoswag": "github.com/bronystylecrazy/ultrastructure/x/autoswag",
	}
	usedAliases := map[string]string{
		"autoswag": "github.com/bronystylecrazy/ultrastructure/x/autoswag",
	}
	aliasRemapByPkg := map[string]map[string]string{}

	handlerByKey := map[string]HandlerReport{}
	for _, p := range report.Packages {
		if _, ok := aliasRemapByPkg[p.Path]; !ok {
			aliasRemapByPkg[p.Path] = map[string]string{}
		}
		for _, h := range p.Handlers {
			if strings.TrimSpace(h.Key) != "" {
				handlerByKey[h.Key] = h
			}
			if h.Request != nil {
				collectTypeImports(h.Request.Type, p.Imports, imports, usedAliases, aliasRemapByPkg[p.Path], pkgName)
			}
			if h.Query != nil {
				collectTypeImports(h.Query.Type, p.Imports, imports, usedAliases, aliasRemapByPkg[p.Path], pkgName)
			}
			for _, r := range h.Responses {
				collectTypeImports(r.Type, p.Imports, imports, usedAliases, aliasRemapByPkg[p.Path], pkgName)
			}
		}
	}

	hasRouteCases := false
	needsReflect := false
	for _, p := range report.Packages {
		for _, route := range p.Routes {
			h, ok := handlerByKey[route.HandlerKey]
			if !ok {
				continue
			}
			hasRouteCases = true
			if handlerNeedsReflect(h) {
				needsReflect = true
			}
		}
	}

	hasFallbackCases := false
	for _, p := range report.Packages {
		for _, h := range p.Handlers {
			if h.Name != "" {
				hasFallbackCases = true
			}
			if handlerNeedsReflect(h) {
				needsReflect = true
			}
		}
	}
	if hasRouteCases {
		// Prefer exact method/path route bindings; only use fallback when route data is unavailable.
		hasFallbackCases = false
	}
	if needsReflect {
		imports["reflect"] = "reflect"
		usedAliases["reflect"] = "reflect"
	}
	if hasFallbackCases || hasRouteCases {
		imports["strings"] = "strings"
		usedAliases["strings"] = "strings"
	}
	fiberAlias := ensureFiberImportAliasForContentTypes(report, imports, usedAliases)
	httpAlias := ensureHTTPImportAliasForStatuses(report, imports, usedAliases)

	var b strings.Builder
	b.WriteString("//go:build !autoswag_analyze\n")
	b.WriteString("// +build !autoswag_analyze\n\n")
	b.WriteString("// Code generated by Ultrastructure AutoSwag " + strings.TrimSpace(generatedByVersion(opts.ToolVersion)) + "; DO NOT EDIT.\n\n")
	b.WriteString("package " + pkgName + "\n\n")
	b.WriteString("import (\n")

	aliases := make([]string, 0, len(imports))
	for alias := range imports {
		aliases = append(aliases, alias)
	}
	sort.Strings(aliases)
	for _, alias := range aliases {
		path := imports[alias]
		if alias == path {
			b.WriteString("\t\"" + path + "\"\n")
		} else {
			b.WriteString("\t" + alias + " \"" + path + "\"\n")
		}
	}
	b.WriteString(")\n\n")

	b.WriteString("func " + funcName + "(ctx *autoswag.Context) {\n")
	b.WriteString("\tif ctx == nil {\n\t\treturn\n\t}\n")
	b.WriteString("\tpath := strings.TrimSpace(ctx.Path)\n")
	b.WriteString("\tif path == \"\" {\n\t\tpath = \"/\"\n\t}\n")
	b.WriteString("\tif len(path) > 1 {\n\t\tpath = strings.TrimRight(path, \"/\")\n\t}\n")
	b.WriteString("\trouteKey := ctx.Method + \" \" + path\n")
	b.WriteString("\tswitch routeKey {\n")

	emittedRouteCase := 0
	type routeCaseEmission struct {
		key  string
		body string
	}
	emissions := make([]routeCaseEmission, 0)
	for _, p := range report.Packages {
		for _, route := range p.Routes {
			h, ok := handlerByKey[route.HandlerKey]
			if !ok {
				continue
			}
			emittedRouteCase++
			normalizedPath := strings.TrimSpace(route.Path)
			if normalizedPath == "" {
				normalizedPath = "/"
			}
			if len(normalizedPath) > 1 {
				normalizedPath = strings.TrimRight(normalizedPath, "/")
			}
			key := strings.ToUpper(strings.TrimSpace(route.Method)) + " " + normalizedPath
			var body strings.Builder
			if name := strings.TrimSpace(route.Name); name != "" {
				body.WriteString("\t\tctx.SetSummary(" + strconv.Quote(name) + ")\n")
			}
			if description := strings.TrimSpace(route.Description); description != "" {
				body.WriteString("\t\tctx.SetDescription(" + strconv.Quote(description) + ")\n")
			}
			if len(route.Tags) > 0 {
				tags := make([]string, 0, len(route.Tags))
				for _, tag := range route.Tags {
					tag = strings.TrimSpace(tag)
					if tag == "" {
						continue
					}
					tags = append(tags, strconv.Quote(tag))
				}
				if len(tags) > 0 {
					body.WriteString("\t\tctx.AddTag(" + strings.Join(tags, ", ") + ")\n")
				}
			}
			if len(route.TagDescriptions) > 0 {
				names := make([]string, 0, len(route.TagDescriptions))
				for name := range route.TagDescriptions {
					name = strings.TrimSpace(name)
					if name == "" {
						continue
					}
					names = append(names, name)
				}
				sort.Strings(names)
				for _, name := range names {
					desc := strings.TrimSpace(route.TagDescriptions[name])
					if desc == "" {
						continue
					}
					body.WriteString("\t\tctx.AddTagDescription(" + strconv.Quote(name) + ", " + strconv.Quote(desc) + ")\n")
				}
			}
			hForRoute := h
			if len(route.Responses) > 0 {
				hForRoute.Responses = mergeRouteResponses(h.Responses, route.Responses)
			}
			if len(route.ResponseHeaders) > 0 {
				hForRoute.Responses = mergeRouteResponseHeaders(hForRoute.Responses, route.ResponseHeaders)
			}
			if len(route.PathParams) > 0 {
				hForRoute.Path = mergeRoutePathParams(h.Path, route.PathParams)
			}
			emitHandlerMetadata(&body, hForRoute, pkgName, aliasRemapByPkg[p.Path], opts.ExactOnly, fiberAlias, httpAlias)
			body.WriteString("\t\treturn\n")
			emissions = append(emissions, routeCaseEmission{
				key:  key,
				body: body.String(),
			})
		}
	}
	if len(emissions) > 0 {
		type groupedEmission struct {
			keys []string
			body string
		}
		grouped := make([]groupedEmission, 0, len(emissions))
		indexByBody := make(map[string]int, len(emissions))
		for _, emission := range emissions {
			if idx, ok := indexByBody[emission.body]; ok {
				grouped[idx].keys = append(grouped[idx].keys, emission.key)
				continue
			}
			indexByBody[emission.body] = len(grouped)
			grouped = append(grouped, groupedEmission{
				keys: []string{emission.key},
				body: emission.body,
			})
		}
		for _, g := range grouped {
			quoted := make([]string, 0, len(g.keys))
			for _, key := range g.keys {
				quoted = append(quoted, strconv.Quote(key))
			}
			b.WriteString("\tcase " + strings.Join(quoted, ", ") + ":\n")
			b.WriteString(g.body)
		}
	}

	if emittedRouteCase == 0 && hasFallbackCases {
		b.WriteString("\tdefault:\n")
		b.WriteString("\t\thandler := strings.TrimSpace(ctx.Route.HandlerName)\n")
		b.WriteString("\t\tswitch {\n")

		for _, p := range report.Packages {
			for _, h := range p.Handlers {
				if h.Name == "" {
					continue
				}
				caseCond := fmt.Sprintf("strings.HasSuffix(handler, \".%s\") || strings.Contains(handler, \".%s-fm\")", h.Name, h.Name)
				b.WriteString("\t\tcase " + caseCond + ":\n")
				emitHandlerMetadata(&b, h, pkgName, aliasRemapByPkg[p.Path], opts.ExactOnly, fiberAlias, httpAlias)
				b.WriteString("\t\t\treturn\n")
			}
		}
		b.WriteString("\t\tdefault:\n\t\t\treturn\n\t\t}\n")
		b.WriteString("\t\treturn\n")
	}

	b.WriteString("\tdefault:\n\t\treturn\n\t}\n")
	b.WriteString("}\n")
	return b.String(), nil
}

func generatedByVersion(v string) string {
	v = strings.TrimSpace(v)
	if v == "" {
		return "vunknown"
	}
	// Tool version can look like:
	//   github.com/org/repo@v1.2.3|rev=...|modified=...
	// Keep only the version token for generated banners.
	if pipe := strings.Index(v, "|"); pipe >= 0 {
		v = strings.TrimSpace(v[:pipe])
	}
	if at := strings.LastIndex(v, "@"); at >= 0 && at < len(v)-1 {
		v = strings.TrimSpace(v[at+1:])
	}
	if v == "" || v == "(devel)" {
		return "(dev)"
	}
	if strings.HasPrefix(v, "v") {
		return v
	}
	return "v" + v
}

func emitHandlerMetadata(b *strings.Builder, h HandlerReport, localPkg string, aliasRemap map[string]string, exactOnly bool, fiberAlias string, httpAlias string) {
	if h.Request != nil && h.Request.Type != "" {
		if !(exactOnly && normalizeResponseConfidence(h.Request.Confidence) != responseConfidenceExact) {
			reqExpr := typeInitExpr(h.Request.Type, localPkg, aliasRemap)
			if len(h.Request.ContentTypes) > 0 {
				cts := make([]string, 0, len(h.Request.ContentTypes))
				for _, ct := range h.Request.ContentTypes {
					cts = append(cts, renderContentTypeExpr(ct, fiberAlias))
				}
				b.WriteString("\t\tctx.SetRequestBody(" + reqExpr + ", true, " + strings.Join(cts, ", ") + ")\n")
			} else {
				b.WriteString("\t\tctx.SetRequestBody(" + reqExpr + ", true)\n")
			}
			emitModelFieldDescriptions(b, reqExpr, h.Request.Fields)
		}
	}
	if h.Query != nil && h.Query.Type != "" {
		if !(exactOnly && normalizeResponseConfidence(h.Query.Confidence) != responseConfidenceExact) {
			queryExpr := typeInitExpr(h.Query.Type, localPkg, aliasRemap)
			if queryExpr != "" {
				b.WriteString("\t\tctx.SetQuery(" + queryExpr + ")\n")
				emitModelFieldDescriptions(b, queryExpr, h.Query.Fields)
			}
		}
	}
	for _, p := range h.Path {
		if exactOnly && normalizeResponseConfidence(p.Confidence) != responseConfidenceExact {
			continue
		}
		t := "reflect.TypeOf(\"\")"
		switch p.Type {
		case "integer":
			t = "reflect.TypeOf(int64(0))"
		case "number":
			t = "reflect.TypeOf(float64(0))"
		case "boolean":
			t = "reflect.TypeOf(false)"
		}
		paramExpr := "autoswag.ParameterMetadata{Name: " + strconv.Quote(p.Name) + ", In: \"path\", Type: " + t + ", Required: true"
		if d := strings.TrimSpace(p.Description); d != "" {
			paramExpr += ", Description: " + strconv.Quote(d)
		}
		paramExpr += "}"
		b.WriteString("\t\tctx.AddParameter(" + paramExpr + ")\n")
	}
	for _, r := range h.Responses {
		if exactOnly && strings.TrimSpace(r.Confidence) != "" && strings.TrimSpace(r.Confidence) != responseConfidenceExact {
			continue
		}
		modelExpr := typeInitExpr(r.Type, localPkg, aliasRemap)
		if modelExpr == "" {
			continue
		}
		description := strings.TrimSpace(r.Description)
		if description == "" {
			description = "Auto-detected"
		}
		if strings.TrimSpace(r.ContentType) != "" {
			b.WriteString("\t\tctx.SetResponseAs(" + renderStatusExpr(r.Status, httpAlias) + ", " + modelExpr + ", " + renderContentTypeExpr(r.ContentType, fiberAlias) + ", " + strconv.Quote(description) + ")\n")
		} else {
			b.WriteString("\t\tctx.SetResponse(" + renderStatusExpr(r.Status, httpAlias) + ", " + modelExpr + ", " + strconv.Quote(description) + ")\n")
		}
		emitModelFieldDescriptions(b, modelExpr, r.Fields)
		if len(r.Headers) > 0 {
			names := make([]string, 0, len(r.Headers))
			for name := range r.Headers {
				name = strings.TrimSpace(name)
				if name == "" {
					continue
				}
				names = append(names, name)
			}
			sort.Strings(names)
			for _, name := range names {
				header := r.Headers[name]
				desc := strings.TrimSpace(header.Description)
				if desc == "" {
					desc = "Auto-detected"
				}
				b.WriteString(
					"\t\tctx.AddResponseHeader(" +
						renderStatusExpr(r.Status, httpAlias) + ", " +
						strconv.Quote(name) + ", " +
						headerTypeExpr(header.Type) + ", " +
						strconv.Quote(desc) +
						")\n",
				)
			}
		}
	}
}

func emitModelFieldDescriptions(b *strings.Builder, modelExpr string, fields map[string]string) {
	if b == nil || len(fields) == 0 {
		return
	}
	modelExpr = strings.TrimSpace(modelExpr)
	if modelExpr == "" {
		return
	}
	names := make([]string, 0, len(fields))
	for name := range fields {
		name = strings.TrimSpace(name)
		if name == "" {
			continue
		}
		names = append(names, name)
	}
	sort.Strings(names)
	for _, name := range names {
		desc := strings.TrimSpace(fields[name])
		if desc == "" {
			continue
		}
		b.WriteString("\t\tctx.AddModelFieldDescription(" + modelExpr + ", " + strconv.Quote(name) + ", " + strconv.Quote(desc) + ")\n")
	}
}

func ensureFiberImportAliasForContentTypes(report *Report, imports map[string]string, usedAliases map[string]string) string {
	if !reportUsesKnownContentTypeConstants(report) {
		return ""
	}
	return assignImportAlias("fiber", "github.com/gofiber/fiber/v3", imports, usedAliases)
}

func ensureHTTPImportAliasForStatuses(report *Report, imports map[string]string, usedAliases map[string]string) string {
	if !reportUsesKnownStatusConstants(report) {
		return ""
	}
	return assignImportAlias("http", "net/http", imports, usedAliases)
}

func reportUsesKnownContentTypeConstants(report *Report) bool {
	if report == nil {
		return false
	}
	for _, p := range report.Packages {
		for _, h := range p.Handlers {
			if h.Request != nil {
				for _, ct := range h.Request.ContentTypes {
					if _, ok := contentTypeConstantName(ct); ok {
						return true
					}
				}
			}
			for _, r := range h.Responses {
				if _, ok := contentTypeConstantName(r.ContentType); ok {
					return true
				}
			}
		}
		for _, route := range p.Routes {
			for _, r := range route.Responses {
				if _, ok := contentTypeConstantName(r.ContentType); ok {
					return true
				}
			}
		}
	}
	return false
}

func reportUsesKnownStatusConstants(report *Report) bool {
	if report == nil {
		return false
	}
	for _, p := range report.Packages {
		for _, h := range p.Handlers {
			for _, r := range h.Responses {
				if _, ok := statusConstantName(r.Status); ok {
					return true
				}
			}
		}
		for _, route := range p.Routes {
			for _, r := range route.Responses {
				if _, ok := statusConstantName(r.Status); ok {
					return true
				}
			}
		}
	}
	return false
}

func renderContentTypeExpr(contentType, fiberAlias string) string {
	if constName, ok := contentTypeConstantName(contentType); ok && strings.TrimSpace(fiberAlias) != "" {
		return fiberAlias + "." + constName
	}
	return strconv.Quote(contentType)
}

func renderStatusExpr(status int, httpAlias string) string {
	if constName, ok := statusConstantName(status); ok && strings.TrimSpace(httpAlias) != "" {
		return httpAlias + "." + constName
	}
	return strconv.Itoa(status)
}

func statusConstantName(status int) (string, bool) {
	switch status {
	case 100:
		return "StatusContinue", true
	case 101:
		return "StatusSwitchingProtocols", true
	case 102:
		return "StatusProcessing", true
	case 103:
		return "StatusEarlyHints", true
	case 200:
		return "StatusOK", true
	case 201:
		return "StatusCreated", true
	case 202:
		return "StatusAccepted", true
	case 203:
		return "StatusNonAuthoritativeInfo", true
	case 204:
		return "StatusNoContent", true
	case 205:
		return "StatusResetContent", true
	case 206:
		return "StatusPartialContent", true
	case 207:
		return "StatusMultiStatus", true
	case 208:
		return "StatusAlreadyReported", true
	case 226:
		return "StatusIMUsed", true
	case 300:
		return "StatusMultipleChoices", true
	case 301:
		return "StatusMovedPermanently", true
	case 302:
		return "StatusFound", true
	case 303:
		return "StatusSeeOther", true
	case 304:
		return "StatusNotModified", true
	case 305:
		return "StatusUseProxy", true
	case 307:
		return "StatusTemporaryRedirect", true
	case 308:
		return "StatusPermanentRedirect", true
	case 400:
		return "StatusBadRequest", true
	case 401:
		return "StatusUnauthorized", true
	case 402:
		return "StatusPaymentRequired", true
	case 403:
		return "StatusForbidden", true
	case 404:
		return "StatusNotFound", true
	case 405:
		return "StatusMethodNotAllowed", true
	case 406:
		return "StatusNotAcceptable", true
	case 407:
		return "StatusProxyAuthRequired", true
	case 408:
		return "StatusRequestTimeout", true
	case 409:
		return "StatusConflict", true
	case 410:
		return "StatusGone", true
	case 411:
		return "StatusLengthRequired", true
	case 412:
		return "StatusPreconditionFailed", true
	case 413:
		return "StatusRequestEntityTooLarge", true
	case 414:
		return "StatusRequestURITooLong", true
	case 415:
		return "StatusUnsupportedMediaType", true
	case 416:
		return "StatusRequestedRangeNotSatisfiable", true
	case 417:
		return "StatusExpectationFailed", true
	case 418:
		return "StatusTeapot", true
	case 421:
		return "StatusMisdirectedRequest", true
	case 422:
		return "StatusUnprocessableEntity", true
	case 423:
		return "StatusLocked", true
	case 424:
		return "StatusFailedDependency", true
	case 425:
		return "StatusTooEarly", true
	case 426:
		return "StatusUpgradeRequired", true
	case 428:
		return "StatusPreconditionRequired", true
	case 429:
		return "StatusTooManyRequests", true
	case 431:
		return "StatusRequestHeaderFieldsTooLarge", true
	case 451:
		return "StatusUnavailableForLegalReasons", true
	case 500:
		return "StatusInternalServerError", true
	case 501:
		return "StatusNotImplemented", true
	case 502:
		return "StatusBadGateway", true
	case 503:
		return "StatusServiceUnavailable", true
	case 504:
		return "StatusGatewayTimeout", true
	case 505:
		return "StatusHTTPVersionNotSupported", true
	case 506:
		return "StatusVariantAlsoNegotiates", true
	case 507:
		return "StatusInsufficientStorage", true
	case 508:
		return "StatusLoopDetected", true
	case 510:
		return "StatusNotExtended", true
	case 511:
		return "StatusNetworkAuthenticationRequired", true
	default:
		return "", false
	}
}

func contentTypeConstantName(contentType string) (string, bool) {
	switch strings.TrimSpace(contentType) {
	case "application/json":
		return "MIMEApplicationJSON", true
	case "application/xml":
		return "MIMEApplicationXML", true
	case "application/x-www-form-urlencoded":
		return "MIMEApplicationForm", true
	case "application/octet-stream":
		return "MIMEOctetStream", true
	case "application/javascript":
		return "MIMEApplicationJavaScript", true
	case "application/cbor":
		return "MIMEApplicationCBOR", true
	case "application/vnd.msgpack":
		return "MIMEApplicationMsgPack", true
	case "multipart/form-data":
		return "MIMEMultipartForm", true
	case "text/plain":
		return "MIMETextPlain", true
	case "text/html":
		return "MIMETextHTML", true
	case "text/css":
		return "MIMETextCSS", true
	case "text/xml":
		return "MIMETextXML", true
	case "text/javascript":
		return "MIMETextJavaScript", true
	case "text/plain; charset=utf-8":
		return "MIMETextPlainCharsetUTF8", true
	case "text/html; charset=utf-8":
		return "MIMETextHTMLCharsetUTF8", true
	case "text/xml; charset=utf-8":
		return "MIMETextXMLCharsetUTF8", true
	case "text/javascript; charset=utf-8":
		return "MIMETextJavaScriptCharsetUTF8", true
	case "text/css; charset=utf-8":
		return "MIMETextCSSCharsetUTF8", true
	case "application/json; charset=utf-8":
		return "MIMEApplicationJSONCharsetUTF8", true
	case "application/xml; charset=utf-8":
		return "MIMEApplicationXMLCharsetUTF8", true
	default:
		return "", false
	}
}

func handlerNeedsReflect(h HandlerReport) bool {
	if len(h.Path) > 0 {
		return true
	}
	for _, r := range h.Responses {
		if len(r.Headers) > 0 {
			return true
		}
	}
	return false
}

func headerTypeExpr(typeName string) string {
	switch strings.TrimSpace(strings.ToLower(typeName)) {
	case "integer":
		return "reflect.TypeOf(int64(0))"
	case "number":
		return "reflect.TypeOf(float64(0))"
	case "boolean":
		return "reflect.TypeOf(false)"
	default:
		return "reflect.TypeOf(\"\")"
	}
}

func mergeRouteResponses(base []ResponseTypeReport, overrides []ResponseTypeReport) []ResponseTypeReport {
	if len(overrides) == 0 {
		return base
	}
	out := make([]ResponseTypeReport, 0, len(base)+len(overrides))
	seen := map[string]int{}
	keyFor := func(r ResponseTypeReport) string {
		return strconv.Itoa(r.Status) + "|" + strings.TrimSpace(r.ContentType)
	}
	for _, r := range base {
		key := keyFor(r)
		seen[key] = len(out)
		out = append(out, r)
	}
	for _, r := range overrides {
		key := keyFor(r)
		if idx, ok := seen[key]; ok {
			out[idx] = r
			continue
		}
		seen[key] = len(out)
		out = append(out, r)
	}
	return out
}

func mergeRoutePathParams(base []PathParamReport, overrides []PathParamReport) []PathParamReport {
	if len(overrides) == 0 {
		return base
	}
	out := make([]PathParamReport, 0, len(base)+len(overrides))
	indexByName := map[string]int{}
	for _, p := range base {
		key := strings.TrimSpace(p.Name)
		indexByName[key] = len(out)
		out = append(out, p)
	}
	for _, p := range overrides {
		key := strings.TrimSpace(p.Name)
		if key == "" {
			continue
		}
		if idx, ok := indexByName[key]; ok {
			out[idx] = p
			continue
		}
		indexByName[key] = len(out)
		out = append(out, p)
	}
	return out
}

func mergeRouteResponseHeaders(base []ResponseTypeReport, overrides []RouteResponseHeaderReport) []ResponseTypeReport {
	if len(overrides) == 0 {
		return base
	}
	out := append([]ResponseTypeReport(nil), base...)
	for _, hdr := range overrides {
		status := hdr.Status
		if status <= 0 {
			continue
		}
		targetIdx := -1
		for i := range out {
			if out[i].Status == status {
				targetIdx = i
				break
			}
		}
		if targetIdx < 0 {
			out = append(out, ResponseTypeReport{
				Status:     status,
				Type:       "string",
				Confidence: responseConfidenceExact,
			})
			targetIdx = len(out) - 1
		}

		if out[targetIdx].Headers == nil {
			out[targetIdx].Headers = map[string]ResponseHeaderReport{}
		}
		headerType := strings.TrimSpace(strings.ToLower(hdr.Type))
		if headerType == "" {
			headerType = "string"
		}
		desc := strings.TrimSpace(hdr.Description)
		if desc == "" {
			desc = "Auto-detected"
		}
		name := strings.TrimSpace(hdr.Name)
		if name == "" {
			continue
		}
		out[targetIdx].Headers[name] = ResponseHeaderReport{
			Type:        headerType,
			Description: desc,
			Confidence:  responseConfidenceExact,
		}
	}
	return out
}

func collectTypeImports(typeName string, pkgImports map[string]string, imports map[string]string, usedAliases map[string]string, remap map[string]string, localPkg string) {
	typeName = strings.TrimSpace(typeName)
	if typeName == "" {
		return
	}
	if typeName == "string" || typeName == "bool" || strings.HasPrefix(typeName, "int") || strings.HasPrefix(typeName, "uint") || strings.HasPrefix(typeName, "float") {
		return
	}
	aliasPattern := regexp.MustCompile(`\b([A-Za-z_][A-Za-z0-9_]*)\.`)
	matches := aliasPattern.FindAllStringSubmatch(typeName, -1)
	for _, m := range matches {
		if len(m) < 2 {
			continue
		}
		alias := strings.TrimSpace(m[1])
		if alias == "" || alias == localPkg {
			continue
		}
		if path, ok := pkgImports[alias]; ok && path != "" {
			finalAlias := assignImportAlias(alias, path, imports, usedAliases)
			remap[alias] = finalAlias
		}
	}
}

func assignImportAlias(preferredAlias, path string, imports map[string]string, usedAliases map[string]string) string {
	if existingAlias, ok := aliasForPath(path, usedAliases); ok {
		imports[existingAlias] = path
		return existingAlias
	}
	alias := sanitizeAlias(preferredAlias)
	if alias == "" {
		alias = "pkg"
	}
	if existingPath, ok := usedAliases[alias]; !ok || existingPath == path {
		usedAliases[alias] = path
		imports[alias] = path
		return alias
	}
	for i := 2; ; i++ {
		candidate := fmt.Sprintf("%s%d", alias, i)
		if existingPath, ok := usedAliases[candidate]; !ok || existingPath == path {
			usedAliases[candidate] = path
			imports[candidate] = path
			return candidate
		}
	}
}

func aliasForPath(path string, usedAliases map[string]string) (string, bool) {
	for alias, p := range usedAliases {
		if p == path {
			return alias, true
		}
	}
	return "", false
}

func sanitizeAlias(alias string) string {
	alias = strings.TrimSpace(alias)
	if alias == "" {
		return ""
	}
	var b strings.Builder
	for i, r := range alias {
		switch {
		case (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || r == '_':
			b.WriteRune(r)
		case i > 0 && (r >= '0' && r <= '9'):
			b.WriteRune(r)
		default:
			b.WriteRune('_')
		}
	}
	return b.String()
}

func typeInitExpr(typeName string, localPkg string, aliasRemap map[string]string) string {
	typeName = strings.TrimSpace(typeName)
	if typeName == "" {
		return ""
	}
	switch typeName {
	case "string":
		return "\"\""
	case "bool":
		return "false"
	case "any", "interface{}", "error":
		return ""
	}
	if strings.Contains(typeName, "interface{") {
		return ""
	}
	if strings.HasPrefix(typeName, "int") || strings.HasPrefix(typeName, "uint") {
		return "0"
	}
	if strings.HasPrefix(typeName, "float") {
		return "0.0"
	}
	if strings.HasPrefix(typeName, localPkg+".") {
		typeName = strings.TrimPrefix(typeName, localPkg+".")
	}
	if len(aliasRemap) > 0 {
		typeName = rewriteTypeAliases(typeName, aliasRemap)
	}
	return typeName + "{}"
}

func rewriteTypeAliases(typeName string, aliasRemap map[string]string) string {
	aliasPattern := regexp.MustCompile(`\b([A-Za-z_][A-Za-z0-9_]*)\.`)
	return aliasPattern.ReplaceAllStringFunc(typeName, func(token string) string {
		alias := strings.TrimSuffix(token, ".")
		if mapped, ok := aliasRemap[alias]; ok && mapped != "" {
			return mapped + "."
		}
		return token
	})
}
