package autoswag

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/bronystylecrazy/ultrastructure/meta"
	"go.uber.org/zap"
)

func TestWithEmitFiles_AppendsPaths(t *testing.T) {
	cfg := ResolveOptions(
		"/docs",
		WithEmitFiles("./docs/swagger.json", "./docs/swagger.yaml"),
	)

	if len(cfg.EmitFiles) != 2 {
		t.Fatalf("expected 2 emit files, got %d", len(cfg.EmitFiles))
	}
	if cfg.EmitFiles[0] != "./docs/swagger.json" {
		t.Fatalf("unexpected first emit file %q", cfg.EmitFiles[0])
	}
	if cfg.EmitFiles[1] != "./docs/swagger.yaml" {
		t.Fatalf("unexpected second emit file %q", cfg.EmitFiles[1])
	}
}

func TestWithEmitFiles_DefaultPathWhenEmpty(t *testing.T) {
	cfg := ResolveOptions("/docs", WithEmitFiles())
	if len(cfg.EmitFiles) != 1 {
		t.Fatalf("expected 1 default emit file, got %d", len(cfg.EmitFiles))
	}
	if cfg.EmitFiles[0] != defaultEmitFilePath {
		t.Fatalf("expected default emit file %q, got %q", defaultEmitFilePath, cfg.EmitFiles[0])
	}

	cfg = ResolveOptions("/docs", WithEmitFiles("  ", ""))
	if len(cfg.EmitFiles) != 1 {
		t.Fatalf("expected 1 default emit file for blank values, got %d", len(cfg.EmitFiles))
	}
	if cfg.EmitFiles[0] != defaultEmitFilePath {
		t.Fatalf("expected default emit file %q, got %q", defaultEmitFilePath, cfg.EmitFiles[0])
	}
}

func TestEmitOpenAPIFile_JSON(t *testing.T) {
	dir := t.TempDir()
	out := filepath.Join(dir, "swagger.json")
	spec := &OpenAPISpec{OpenAPI: "3.0.0", Info: OpenAPIInfo{Title: "Test API"}}

	if err := emitOpenAPIFile(out, spec); err != nil {
		t.Fatalf("emitOpenAPIFile returned error: %v", err)
	}

	b, err := os.ReadFile(out)
	if err != nil {
		t.Fatalf("failed reading output file: %v", err)
	}
	content := string(b)
	if !strings.Contains(content, "\"openapi\": \"3.0.0\"") {
		t.Fatalf("expected JSON content to contain openapi version, got %q", content)
	}
}

func TestEmitOpenAPIFile_YAML(t *testing.T) {
	dir := t.TempDir()
	out := filepath.Join(dir, "swagger.yaml")
	spec := &OpenAPISpec{OpenAPI: "3.0.0", Info: OpenAPIInfo{Title: "Test API"}}

	if err := emitOpenAPIFile(out, spec); err != nil {
		t.Fatalf("emitOpenAPIFile returned error: %v", err)
	}

	b, err := os.ReadFile(out)
	if err != nil {
		t.Fatalf("failed reading output file: %v", err)
	}
	content := string(b)
	if !strings.Contains(content, "openapi: 3.0.0") {
		t.Fatalf("expected YAML content to contain openapi version, got %q", content)
	}
	if !strings.Contains(content, "# Generated by Ultrastructure AutoSwag v") {
		t.Fatalf("expected YAML content to include emit banner comment, got %q", content)
	}
}

func TestMiddlewareEmitSpecFiles_DevelopmentOnly(t *testing.T) {
	orig := meta.Version
	defer func() { meta.Version = orig }()

	t.Run("dev emits", func(t *testing.T) {
		meta.Version = meta.NilVersion
		dir := t.TempDir()
		out := filepath.Join(dir, "swagger.json")
		m := &Middleware{
			emitFiles: []string{out},
			spec:      &OpenAPISpec{OpenAPI: "3.0.0"},
			logger:    zap.NewNop(),
		}

		m.emitSpecFiles()

		_, err := os.Stat(out)
		if emitFilesEnabledByTag {
			if err != nil {
				t.Fatalf("expected emitted file in dev mode: %v", err)
			}
		} else {
			if !os.IsNotExist(err) {
				t.Fatalf("expected no emitted file when autoswag_emit tag is not set")
			}
		}
	})

	t.Run("non-dev skips", func(t *testing.T) {
		meta.Version = "v1.2.3"
		dir := t.TempDir()
		out := filepath.Join(dir, "swagger.json")
		m := &Middleware{
			emitFiles: []string{out},
			spec:      &OpenAPISpec{OpenAPI: "3.0.0"},
			logger:    zap.NewNop(),
		}

		m.emitSpecFiles()

		if _, err := os.Stat(out); !os.IsNotExist(err) {
			t.Fatalf("expected no emitted file outside dev mode")
		}
	})
}

func TestMiddlewareEmitSpecFiles_EmitsVersionedSpecs(t *testing.T) {
	if !emitFilesEnabledByTag {
		t.Skip("autoswag_emit tag not enabled")
	}

	orig := meta.Version
	defer func() { meta.Version = orig }()
	meta.Version = meta.NilVersion

	dir := t.TempDir()
	base := filepath.Join(dir, "docs", "openapi.json")
	m := &Middleware{
		path:      "/docs",
		emitFiles: []string{base},
		spec:      &OpenAPISpec{OpenAPI: "3.0.0"},
		versionedSpecs: []mountedSpec{
			{path: "/docs/v1", spec: &OpenAPISpec{OpenAPI: "3.0.0", Info: OpenAPIInfo{Title: "v1"}}},
			{path: "/docs/v2", spec: &OpenAPISpec{OpenAPI: "3.0.0", Info: OpenAPIInfo{Title: "v2"}}},
		},
		logger: zap.NewNop(),
	}

	m.emitSpecFiles()

	paths := []string{
		base,
		filepath.Join(dir, "docs", "v1", "openapi.json"),
		filepath.Join(dir, "docs", "v2", "openapi.json"),
	}
	for _, p := range paths {
		if _, err := os.Stat(p); err != nil {
			t.Fatalf("expected emitted file %s: %v", p, err)
		}
	}
}

func TestMiddlewareEmitSpecFiles_NoTagNoEmit(t *testing.T) {
	if emitFilesEnabledByTag {
		t.Skip("only valid when autoswag_emit tag is disabled")
	}

	orig := meta.Version
	defer func() { meta.Version = orig }()
	meta.Version = meta.NilVersion

	dir := t.TempDir()
	out := filepath.Join(dir, "docs", "openapi.json")
	m := &Middleware{
		path:      "/docs",
		emitFiles: []string{out},
		spec:      &OpenAPISpec{OpenAPI: "3.0.0"},
		logger:    zap.NewNop(),
	}

	m.emitSpecFiles()

	if _, err := os.Stat(out); !os.IsNotExist(err) {
		t.Fatalf("expected no emitted file when autoswag_emit tag is disabled")
	}
}

func TestDeriveVersionedEmitPath(t *testing.T) {
	got, ok := deriveVersionedEmitPath("./docs/openapi.json", "/docs", "/docs/v1")
	if !ok {
		t.Fatal("expected versioned emit path to be derivable")
	}
	want := filepath.Clean(filepath.FromSlash("./docs/v1/openapi.json"))
	if filepath.Clean(got) != want {
		t.Fatalf("unexpected derived path: got %q want %q", got, want)
	}

	_, ok = deriveVersionedEmitPath("./docs/openapi.json", "/docs", "/api/v1/docs")
	if ok {
		t.Fatal("expected derivation to fail for unrelated docs path")
	}
}
